---
phase: 03.1-wire-email-realtime-compose
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/socket/rooms.ts
  - src/components/email/inbox-layout.tsx
  - src/app/api/email-signature/route.ts
  - src/app/(dashboard)/email/layout.tsx
autonomous: true
requirements:
  - REQ-IF-003
  - REQ-EM-001
  - REQ-EM-003
  - REQ-EM-006

must_haves:
  truths:
    - "Socket.IO clients join `mailbox:{kontoId}` room when viewing email -- rooms.ts handles `join:mailbox` and `leave:mailbox` events"
    - "When IMAP connection-manager emits `email:folder-update` to `mailbox:{kontoId}` room, browser clients in that room receive the event"
    - "folder-tree.tsx unread badge updates in real-time without page refresh when new email arrives"
    - "GET /api/email-signature?kontoId= returns rendered signature HTML by calling getSignatureForUser()"
    - "compose-popup.tsx signature preview shows the user's personalized signature from the email-signature API"
    - "ComposeManager provider is mounted in the email layout so useComposeManager() returns a working openCompose function"
    - "Room cleanup: leaving email pages emits leave:mailbox; switching kontoId leaves old room before joining new one"
  artifacts:
    - path: "src/lib/socket/rooms.ts"
      provides: "Socket.IO room handlers for mailbox rooms"
      contains: "join:mailbox"
    - path: "src/components/email/inbox-layout.tsx"
      provides: "Socket-to-CustomEvent bridge for email:folder-update and mailbox room join/leave lifecycle"
      contains: "join:mailbox"
    - path: "src/app/api/email-signature/route.ts"
      provides: "GET endpoint returning rendered email signature HTML"
      exports: ["GET"]
    - path: "src/app/(dashboard)/email/layout.tsx"
      provides: "Email layout wrapping children with ComposeManager provider"
      contains: "ComposeManager"
  key_links:
    - from: "src/lib/socket/rooms.ts"
      to: "src/lib/email/imap/connection-manager.ts"
      via: "Client joins mailbox:{kontoId} room that connection-manager already emits to"
      pattern: "mailbox:"
    - from: "src/components/email/inbox-layout.tsx"
      to: "src/components/email/folder-tree.tsx"
      via: "Bridge dispatches window CustomEvent email:folder-update that folder-tree already listens for"
      pattern: "email:folder-update"
    - from: "src/app/api/email-signature/route.ts"
      to: "src/lib/email/signature.ts"
      via: "Calls getSignatureForUser() which loads template and renders with user data"
      pattern: "getSignatureForUser"
    - from: "src/app/(dashboard)/email/layout.tsx"
      to: "src/components/email/compose-manager.tsx"
      via: "Wraps children with ComposeManager context provider"
      pattern: "ComposeManager"
---

<objective>
Wire three existing but disconnected integration points to close INT-001 (critical), INT-002 (medium), and INT-003 (low) from the v3.4 milestone audit:

1. **INT-001**: Add `join:mailbox` / `leave:mailbox` handlers to Socket.IO rooms.ts, emit room join from inbox-layout.tsx, bridge socket `email:folder-update` event to the window CustomEvent that folder-tree.tsx already listens on -- so real-time email arrival updates reach the browser.
2. **INT-002**: Create `GET /api/email-signature?kontoId=` route calling `getSignatureForUser()` from lib/email/signature.ts -- so compose-popup.tsx can preview the user's signature.
3. **INT-003**: Mount `<ComposeManager>` provider in the email layout -- so `useComposeManager()` works from any email page.

No new libraries. No schema changes. Pure wiring of existing code.

Output: Real-time email folder updates fire in the browser, compose preview shows signature, and compose-from-email-pages works via ComposeManager context.
</objective>

<execution_context>
@/Users/patrickbaumfalk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/patrickbaumfalk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03.1-wire-email-realtime-compose/03.1-RESEARCH.md
@src/lib/socket/rooms.ts
@src/components/email/inbox-layout.tsx
@src/components/email/folder-tree.tsx
@src/components/socket-provider.tsx
@src/app/(dashboard)/email/layout.tsx
@src/lib/email/signature.ts
@src/components/email/compose-manager.tsx
@src/components/email/compose-popup.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add mailbox room handlers to Socket.IO rooms.ts and create email-signature API route</name>
  <files>
    src/lib/socket/rooms.ts
    src/app/api/email-signature/route.ts
  </files>
  <action>
**1. Add mailbox room handlers to rooms.ts (src/lib/socket/rooms.ts):**

Add `join:mailbox` and `leave:mailbox` event handlers inside the existing `io.on("connection")` callback, immediately after the `leave:akte` handler block (before the `disconnect` handler). Follow the exact same pattern as `join:akte` / `leave:akte`:

```typescript
// Dynamic Mailbox room join (real-time email folder updates)
socket.on("join:mailbox", (kontoId: string) => {
  if (!kontoId || typeof kontoId !== "string") return;
  const mailboxRoom = `mailbox:${kontoId}`;
  socket.join(mailboxRoom);
  log.debug({ userId, kontoId }, "Joined mailbox room");
});

// Dynamic Mailbox room leave
socket.on("leave:mailbox", (kontoId: string) => {
  if (!kontoId || typeof kontoId !== "string") return;
  const mailboxRoom = `mailbox:${kontoId}`;
  socket.leave(mailboxRoom);
  log.debug({ userId, kontoId }, "Left mailbox room");
});
```

Also update the JSDoc comment at the top to include `mailbox:{kontoId}` in the room naming conventions list:
```
 * - `mailbox:{kontoId}` â€” email real-time updates (joined/left dynamically)
```

**2. Create email-signature API route (src/app/api/email-signature/route.ts):**

Create a new file at `src/app/api/email-signature/route.ts`. Follow the exact pattern of other API routes in this project (see `src/app/api/notifications/route.ts` for auth pattern):

```typescript
import { NextRequest, NextResponse } from "next/server";
import { auth } from "@/lib/auth";
import { getSignatureForUser } from "@/lib/email/signature";

export async function GET(req: NextRequest) {
  const session = await auth();
  if (!session?.user?.id) {
    return NextResponse.json({ error: "Nicht autorisiert" }, { status: 401 });
  }

  const kontoId = req.nextUrl.searchParams.get("kontoId");
  if (!kontoId) {
    return NextResponse.json(
      { error: "kontoId Parameter fehlt" },
      { status: 400 }
    );
  }

  try {
    const signature = await getSignatureForUser(session.user.id, kontoId);
    return NextResponse.json({ signature });
  } catch (err) {
    console.error("[email-signature] Error:", err);
    return NextResponse.json(
      { error: "Fehler beim Laden der Signatur" },
      { status: 500 }
    );
  }
}
```

Note: This is a thin route. `getSignatureForUser()` already handles the DB lookup, user profile loading, and placeholder substitution. The route just validates auth and params, then delegates.
  </action>
  <verify>
    <automated>cd /Users/patrickbaumfalk/Projekte/AI-Lawyer && npx tsc --noEmit --pretty 2>&1 | head -30</automated>
    <manual>Verify rooms.ts has join:mailbox and leave:mailbox handlers; verify src/app/api/email-signature/route.ts exists and exports GET</manual>
  </verify>
  <done>
- rooms.ts has join:mailbox and leave:mailbox handlers following the exact join:akte pattern
- rooms.ts JSDoc includes mailbox:{kontoId} in room naming conventions
- GET /api/email-signature?kontoId= route exists, validates auth, calls getSignatureForUser(), returns { signature: string }
- Route returns 401 without session, 400 without kontoId, 500 on error
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire Socket.IO mailbox room join/leave and event bridge in inbox-layout.tsx</name>
  <files>
    src/components/email/inbox-layout.tsx
  </files>
  <action>
Modify `src/components/email/inbox-layout.tsx` to:
1. Import the socket hook
2. Join/leave the mailbox room based on selectedKontoId
3. Bridge the socket `email:folder-update` event to the window CustomEvent that folder-tree.tsx already listens for

**1. Add imports at the top (after existing imports):**
```typescript
import { useSocket } from "@/components/socket-provider";
import { useEffect } from "react"; // already imported via useState, useCallback -- just add useEffect to the existing import
```

Update the existing import line `import { useState, useCallback } from "react";` to:
```typescript
import { useState, useCallback, useEffect } from "react";
```

**2. Inside the InboxLayout component, after `const emailStore = useEmailStore();`, add:**

```typescript
const { socket, isConnected } = useSocket();

// Join/leave mailbox room for real-time email updates (INT-001)
useEffect(() => {
  if (!socket || !isConnected || !emailStore.selectedKontoId) return;

  const kontoId = emailStore.selectedKontoId;
  socket.emit("join:mailbox", kontoId);

  return () => {
    socket.emit("leave:mailbox", kontoId);
  };
}, [socket, isConnected, emailStore.selectedKontoId]);

// Bridge Socket.IO email:folder-update to window CustomEvent for folder-tree (INT-001)
useEffect(() => {
  if (!socket) return;

  const handleFolderUpdate = (data: {
    kontoId: string;
    ordnerId: string;
    ungeleseneAnzahl: number;
  }) => {
    window.dispatchEvent(
      new CustomEvent("email:folder-update", { detail: data })
    );
  };

  socket.on("email:folder-update", handleFolderUpdate);
  return () => {
    socket.off("email:folder-update", handleFolderUpdate);
  };
}, [socket]);
```

**IMPORTANT notes:**
- The bridge dispatches to `window` CustomEvent which folder-tree.tsx already listens for (lines 136-160). Do NOT modify folder-tree.tsx -- the bridge approach is the minimal-change solution per research recommendation.
- The first useEffect handles room join/leave lifecycle. When `selectedKontoId` changes, the cleanup function leaves the old room before the effect re-runs to join the new room. This prevents room accumulation.
- The second useEffect is separate because it should persist regardless of kontoId changes -- the socket listener handles ALL folder updates for any room the client is in.
- `isConnected` check in the first effect prevents emitting `join:mailbox` before the socket is connected.
  </action>
  <verify>
    <automated>cd /Users/patrickbaumfalk/Projekte/AI-Lawyer && npx tsc --noEmit --pretty 2>&1 | head -30</automated>
    <manual>Review inbox-layout.tsx for: useSocket import, join:mailbox emit with cleanup, email:folder-update bridge to window CustomEvent, no duplicate bridge (only in inbox-layout, not in folder-tree)</manual>
  </verify>
  <done>
- inbox-layout.tsx imports useSocket from socket-provider
- join:mailbox emitted on mount with selectedKontoId, leave:mailbox on cleanup/kontoId change
- isConnected check prevents emit before socket ready
- Socket email:folder-update event bridged to window CustomEvent for folder-tree consumption
- Bridge is in exactly ONE place (inbox-layout) to prevent duplicate dispatches
  </done>
</task>

<task type="auto">
  <name>Task 3: Mount ComposeManager provider in email layout</name>
  <files>
    src/app/(dashboard)/email/layout.tsx
  </files>
  <action>
Replace the entire contents of `src/app/(dashboard)/email/layout.tsx` to add `"use client"` directive and wrap children with `<ComposeManager>`.

**Why "use client":** ComposeManager uses useState/useContext which require client rendering. The current email layout is a server component with no server-only code (no data fetching, no server imports), so converting to client component is safe and is the recommended approach from the research document.

**New content for email/layout.tsx:**

```typescript
"use client";

import { ComposeManager } from "@/components/email/compose-manager";

/**
 * Email-specific layout that removes outer padding from the dashboard
 * and provides the ComposeManager context for compose-from-anywhere.
 * Full-height email view subtracting header height (4rem).
 */
export default function EmailLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <ComposeManager>
      <div className="h-[calc(100vh-4rem)] -m-6 overflow-hidden">
        {children}
      </div>
    </ComposeManager>
  );
}
```

**Notes:**
- ComposeManager is mounted at the email layout level (not dashboard level) per the research recommendation. It only needs to be available on email pages for now. If compose-from-anywhere is needed in the future, it can be moved to the dashboard layout in that phase.
- The `<div>` with height/margin stays inside ComposeManager since it is the actual layout container. ComposeManager renders `{children}` plus floating compose popups and minimized tabs, so order matters.
  </action>
  <verify>
    <automated>cd /Users/patrickbaumfalk/Projekte/AI-Lawyer && npx tsc --noEmit --pretty 2>&1 | head -30</automated>
    <manual>Verify email/layout.tsx has "use client", imports ComposeManager, wraps children with ComposeManager provider</manual>
  </verify>
  <done>
- email/layout.tsx has "use client" directive
- ComposeManager imported from @/components/email/compose-manager
- Children wrapped with ComposeManager so useComposeManager() works from any email page
- Layout div preserved inside ComposeManager for correct styling
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no new errors
2. `src/lib/socket/rooms.ts` handles `join:mailbox` and `leave:mailbox` events inside the connection handler
3. `src/components/email/inbox-layout.tsx` emits `join:mailbox` on mount with selectedKontoId and `leave:mailbox` on cleanup
4. `src/components/email/inbox-layout.tsx` bridges socket `email:folder-update` to window CustomEvent
5. `src/app/api/email-signature/route.ts` exports GET handler that calls getSignatureForUser()
6. `src/app/(dashboard)/email/layout.tsx` wraps children with ComposeManager and has "use client"
7. No duplicate CustomEvent dispatching (bridge only in inbox-layout.tsx)
8. Room cleanup on kontoId change (leave old room before joining new)
</verification>

<success_criteria>
- Socket.IO clients join mailbox:{kontoId} room when viewing email
- email:folder-update emitted by IMAP connection-manager reaches the browser and updates folder-tree unread badges
- GET /api/email-signature?kontoId= returns rendered signature HTML
- ComposeManager provider is mounted in email layout, useComposeManager() returns working openCompose
- INT-001, INT-002, INT-003 from v3.4 audit are all resolved
</success_criteria>

<output>
After completion, create `.planning/phases/03.1-wire-email-realtime-compose/03.1-01-SUMMARY.md`
</output>
