---
phase: 04-document-pipeline-ocr-rag-ingestion
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - docker-compose.yml
  - prisma/schema.prisma
  - src/lib/queue/queues.ts
  - src/lib/ocr/stirling-client.ts
  - src/lib/ocr/types.ts
  - src/lib/queue/processors/ocr.processor.ts
  - src/lib/queue/processors/preview.processor.ts
  - src/lib/meilisearch.ts
  - src/worker.ts
  - src/app/api/akten/[id]/dokumente/route.ts
  - src/app/api/dokumente/[id]/ocr/route.ts
  - src/app/api/admin/pipeline/route.ts
  - src/components/dokumente/ocr-status-badge.tsx
  - src/components/dokumente/upload-panel.tsx
  - src/components/providers/upload-provider.tsx
  - src/components/dokumente/dokumente-tab.tsx
  - src/app/(dashboard)/einstellungen/dokument-tags/page.tsx
  - src/app/api/dokumente/tags/route.ts
  - .env.example
autonomous: true
requirements:
  - REQ-IF-004
  - REQ-DV-004
  - REQ-DV-005

must_haves:
  truths:
    - "Stirling-PDF Docker container starts and responds to health checks"
    - "A PDF uploaded to a case automatically triggers an OCR job in the background"
    - "Already-searchable PDFs are detected and OCR is skipped (ocrType skip-text)"
    - "Non-PDF documents (DOCX, images) are converted to PDF preview via Stirling-PDF"
    - "OCR status is visible as a colored badge on documents in lists (gray/blue/green/red)"
    - "OCR-processed text is indexed in Meilisearch and the document becomes searchable by content"
    - "Auto-retry 2x with backoff on OCR failure, then manual retry button available"
    - "Admin can view OCR pipeline dashboard with queue depth, failed documents, and bulk retry"
    - "Floating upload panel shows per-file progress and persists across page navigation"
    - "Case documents tab has a drag-and-drop zone and file picker button for uploading documents"
  artifacts:
    - path: "docker-compose.yml"
      provides: "Stirling-PDF sidecar service"
      contains: "stirling-pdf"
    - path: "src/lib/ocr/stirling-client.ts"
      provides: "Stirling-PDF REST API client"
      exports: ["ocrPdf", "convertToPdf", "convertImageToPdf"]
    - path: "src/lib/queue/processors/ocr.processor.ts"
      provides: "OCR job processor with auto-retry and pipeline chaining"
      exports: ["processOcrJob"]
    - path: "src/lib/queue/queues.ts"
      provides: "OCR, embedding, and preview queues"
      contains: "ocrQueue"
    - path: "prisma/schema.prisma"
      provides: "OcrStatus enum, Dokument OCR fields, DocumentChunk model, DokumentTagKategorie model"
      contains: "OcrStatus"
    - path: "src/components/dokumente/ocr-status-badge.tsx"
      provides: "Color-coded OCR status badge component"
    - path: "src/components/dokumente/upload-panel.tsx"
      provides: "Floating upload panel (Google Drive style)"
    - path: "src/components/dokumente/dokumente-tab.tsx"
      provides: "Drag-and-drop upload zone and file picker button on case documents tab"
      contains: "onDrop"
  key_links:
    - from: "src/app/api/akten/[id]/dokumente/route.ts"
      to: "src/lib/queue/queues.ts"
      via: "ocrQueue.add() on file upload"
      pattern: "ocrQueue\\.add"
    - from: "src/lib/queue/processors/ocr.processor.ts"
      to: "src/lib/ocr/stirling-client.ts"
      via: "calls ocrPdf/convertToPdf for processing"
      pattern: "ocrPdf|convertToPdf"
    - from: "src/lib/queue/processors/ocr.processor.ts"
      to: "src/lib/meilisearch.ts"
      via: "indexes OCR text in Meilisearch after processing"
      pattern: "indexDokument"
    - from: "src/worker.ts"
      to: "src/lib/queue/processors/ocr.processor.ts"
      via: "registers OCR worker processor"
      pattern: "processOcrJob"
    - from: "src/components/dokumente/dokumente-tab.tsx"
      to: "src/components/providers/upload-provider.tsx"
      via: "drag-and-drop zone calls uploadProvider.addFiles(akteId, files)"
      pattern: "addFiles"
---

<objective>
Set up the Stirling-PDF Docker sidecar, build the auto-OCR processing pipeline with BullMQ, extend the Prisma schema with OCR/tag/embedding models, and create the upload experience with OCR status feedback.

Purpose: This is the foundation for the entire document pipeline -- every subsequent plan depends on the OCR infrastructure, schema changes, and processing queues established here.

Output: Working OCR pipeline that processes uploaded documents automatically, with visible status badges, admin monitoring dashboard, floating upload panel with drag-and-drop upload on the case documents tab, and Meilisearch full-text indexing of OCR'd text.
</objective>

<execution_context>
@/Users/patrickbaumfalk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/patrickbaumfalk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-document-pipeline-ocr-rag-ingestion/04-RESEARCH.md
@.planning/phases/04-document-pipeline-ocr-rag-ingestion/04-CONTEXT.md
@docker-compose.yml
@prisma/schema.prisma
@src/lib/queue/queues.ts
@src/lib/meilisearch.ts
@src/lib/storage.ts
@src/worker.ts
@src/app/api/akten/[id]/dokumente/route.ts
@src/components/dokumente/dokumente-tab.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Docker + Schema + Queues + Stirling-PDF Client</name>
  <files>
    docker-compose.yml
    prisma/schema.prisma
    src/lib/queue/queues.ts
    src/lib/ocr/stirling-client.ts
    src/lib/ocr/types.ts
    .env.example
  </files>
  <action>
    **1. Add Stirling-PDF to docker-compose.yml:**
    Add a new `stirling-pdf` service after `meilisearch`:
    ```yaml
    stirling-pdf:
      image: stirlingtools/stirling-pdf:latest
      container_name: ailawyer-stirling-pdf
      restart: unless-stopped
      ports:
        - "8081:8080"
      environment:
        DOCKER_ENABLE_SECURITY: "false"
        SYSTEM_DEFAULTLOCALE: de-DE
        SYSTEM_MAXFILESIZE: 100
        TESSERACT_LANGS: deu,eng
      volumes:
        - stirling_configs:/configs
        - stirling_logs:/logs
        - stirling_tessdata:/usr/share/tessdata
      deploy:
        resources:
          limits:
            memory: 4g
      healthcheck:
        test: ["CMD", "curl", "-f", "http://localhost:8080/api/v1/info/status"]
        interval: 30s
        timeout: 10s
        retries: 3
        start_period: 60s
    ```
    Add `stirling_configs`, `stirling_logs`, `stirling_tessdata` to volumes section.
    Add `STIRLING_PDF_URL: http://stirling-pdf:8080` to `app` and `worker` environment sections.
    Add `stirling-pdf` to worker depends_on (condition: service_healthy).

    Also add Ollama service with `profiles: ["ai"]` so it is optional:
    ```yaml
    ollama:
      image: ollama/ollama:latest
      container_name: ailawyer-ollama
      restart: unless-stopped
      profiles: ["ai"]
      ports:
        - "11434:11434"
      volumes:
        - ollama_data:/root/.ollama
      environment:
        OLLAMA_HOST: "0.0.0.0"
      deploy:
        resources:
          limits:
            memory: 8g
    ```
    Add `ollama_data` to volumes. Add `OLLAMA_URL: http://ollama:11434` to worker environment.

    **2. Extend Prisma schema:**
    Add new enum `OcrStatus` with values: `AUSSTEHEND`, `IN_BEARBEITUNG`, `ABGESCHLOSSEN`, `FEHLGESCHLAGEN`, `NICHT_NOETIG`.

    Add fields to existing `Dokument` model:
    - `ocrStatus OcrStatus @default(AUSSTEHEND)`
    - `ocrFehler String? @db.Text` (error message if failed)
    - `ocrVersuche Int @default(0)` (attempt count)
    - `ocrAbgeschlossen DateTime?` (when OCR completed)
    - `previewPfad String?` (MinIO path for generated PDF preview of non-PDF files)
    Add relation `chunks DocumentChunk[]` to Dokument.

    Add new model `DocumentChunk`:
    ```prisma
    model DocumentChunk {
      id           String   @id @default(cuid())
      dokumentId   String
      dokument     Dokument @relation(fields: [dokumentId], references: [id], onDelete: Cascade)
      chunkIndex   Int
      content      String   @db.Text
      embedding    Unsupported("vector(1024)")?
      modelVersion String
      createdAt    DateTime @default(now())
      @@unique([dokumentId, chunkIndex])
      @@index([dokumentId])
      @@map("document_chunks")
    }
    ```

    Add new model `DokumentTagKategorie`:
    ```prisma
    model DokumentTagKategorie {
      id         String   @id @default(cuid())
      name       String   @unique
      farbe      String   // Hex color
      sortierung Int      @default(0)
      system     Boolean  @default(false)
      createdAt  DateTime @default(now())
      updatedAt  DateTime @updatedAt
      @@map("dokument_tag_kategorien")
    }
    ```

    Enable `postgresqlExtensions` preview feature in generator and add `extensions = [vector]` to datasource.

    **3. Add OCR, embedding, and preview queues to queues.ts:**
    Add three new queues after existing ones:
    - `ocrQueue` ("document-ocr") with attempts: 3
    - `embeddingQueue` ("document-embedding") with attempts: 2
    - `previewQueue` ("document-preview") with attempts: 2
    Add all three to `ALL_QUEUES` array.

    **4. Create Stirling-PDF REST API client (src/lib/ocr/stirling-client.ts):**
    Implement:
    - `ocrPdf(pdfBuffer: Buffer, languages?: string): Promise<Buffer>` -- calls `/api/v1/misc/ocr-pdf` with `ocrType: "skip-text"` and `ocrRenderType: "hocr"`
    - `convertToPdf(fileBuffer: Buffer, filename: string): Promise<Buffer>` -- calls `/api/v1/convert/file/pdf`
    - `convertImageToPdf(imageBuffer: Buffer, filename: string): Promise<Buffer>` -- calls `/api/v1/convert/img/pdf`
    - `checkStirlingHealth(): Promise<boolean>` -- GET `/api/v1/info/status`
    Use `STIRLING_PDF_URL` env var (default: `http://stirling-pdf:8080`).
    Use native `fetch` with `FormData` for multipart uploads.

    **5. Create OCR types (src/lib/ocr/types.ts):**
    Export interfaces:
    - `OcrJobData { dokumentId: string; akteId: string; storagePath: string; mimeType: string; fileName: string; }`
    - `EmbeddingJobData { dokumentId: string; akteId: string; ocrText: string; }`
    - `PreviewJobData { dokumentId: string; storagePath: string; mimeType: string; fileName: string; akteId: string; }`

    **6. Update .env.example:** Add `STIRLING_PDF_URL`, `OLLAMA_URL`, `EMBEDDING_MODEL` vars.

    Run `npx prisma db push` to apply schema changes (do NOT run prisma migrate -- the project uses db push).
  </action>
  <verify>
    <automated>cd /Users/patrickbaumfalk/Projekte/AI-Lawyer && npx prisma validate && npx tsc --noEmit --pretty 2>&1 | head -30</automated>
    <manual>Check docker-compose.yml has stirling-pdf and ollama services, Prisma schema compiles, TypeScript compiles</manual>
  </verify>
  <done>
    - Stirling-PDF and Ollama services defined in docker-compose.yml with health checks
    - Prisma schema has OcrStatus enum, Dokument OCR fields, DocumentChunk model, DokumentTagKategorie model
    - Three new BullMQ queues (ocr, embedding, preview) registered in ALL_QUEUES
    - Stirling-PDF client provides ocrPdf, convertToPdf, convertImageToPdf functions
    - OCR job type interfaces defined
  </done>
</task>

<task type="auto">
  <name>Task 2: OCR Processor + Preview Processor + Worker Registration + Upload Pipeline + APIs</name>
  <files>
    src/lib/queue/processors/ocr.processor.ts
    src/lib/queue/processors/preview.processor.ts
    src/worker.ts
    src/app/api/akten/[id]/dokumente/route.ts
    src/app/api/dokumente/[id]/ocr/route.ts
    src/app/api/admin/pipeline/route.ts
    src/app/api/dokumente/tags/route.ts
    src/lib/meilisearch.ts
  </files>
  <action>
    **1. Create OCR processor (src/lib/queue/processors/ocr.processor.ts):**
    Export `processOcrJob(job: Job<OcrJobData>)`:
    - Fetch file from MinIO via `getFileStream(job.data.storagePath)`
    - Route by MIME type:
      - `application/pdf`: Call `ocrPdf()` directly
      - `image/jpeg`, `image/png`, `image/tiff`: Call `convertImageToPdf()` then `ocrPdf()`
      - `application/vnd.openxmlformats-officedocument.wordprocessingml.document`, `application/vnd.oasis.opendocument.text`, etc.: Call `convertToPdf()`, extract text from PDF
      - `text/plain`, `text/csv`, `text/html`: Read directly as text (no OCR needed)
    - Update Dokument record: set `ocrStatus: "IN_BEARBEITUNG"` at start, `ocrVersuche` increment
    - On success: Update `ocrStatus: "ABGESCHLOSSEN"`, `ocrAbgeschlossen: new Date()`, store extracted text in `ocrText` field
    - Upload OCR'd PDF back to MinIO (replace original for PDFs, or store as previewPfad for non-PDFs)
    - Re-index document in Meilisearch with OCR text via `indexDokument()` -- include new fields (ocrStatus, dokumentStatus, createdAt timestamp)
    - Enqueue embedding job via `embeddingQueue.add()` with extracted text
    - On failure: Set `ocrStatus: "FEHLGESCHLAGEN"`, `ocrFehler: error.message`
    - After 3 attempts failed, mark as `FEHLGESCHLAGEN` permanently
    - Emit Socket.IO notification on OCR completion (success or failure) via the socket emitter pattern from Phase 1

    **2. Create preview processor (src/lib/queue/processors/preview.processor.ts):**
    Export `processPreviewJob(job: Job<PreviewJobData>)`:
    - For non-PDF files, generate PDF preview via `convertToPdf()`
    - Store generated preview at `akten/{akteId}/previews/{dokumentId}.pdf` in MinIO
    - Update Dokument record `previewPfad` with MinIO key
    - Lower priority than OCR (will be naturally lower since OCR runs first)

    **3. Register processors in worker.ts:**
    Import `processOcrJob` and `processPreviewJob`.
    Create BullMQ Worker for "document-ocr" queue with concurrency: 1 (memory-heavy).
    Create BullMQ Worker for "document-preview" queue with concurrency: 2.
    Attach completion/failure handlers that emit Socket.IO notifications (follow existing email worker pattern).
    Add both workers to graceful shutdown handler.

    **4. Update document upload API (src/app/api/akten/[id]/dokumente/route.ts):**
    In the POST handler, after creating the Dokument record in Prisma and uploading to MinIO:
    - Determine if file needs OCR: PDFs and images -> OCR queue; text files -> set `ocrStatus: "NICHT_NOETIG"` and directly index text in Meilisearch
    - Enqueue OCR job: `ocrQueue.add("ocr-document", { dokumentId, akteId, storagePath, mimeType, fileName })`
    - For non-PDF files also enqueue preview job: `previewQueue.add("generate-preview", { dokumentId, storagePath, mimeType, fileName, akteId })`
    - Enforce 100 MB file size limit (return 413 if exceeded)
    - Return the Dokument record with `ocrStatus` included

    **5. Create manual re-OCR endpoint (src/app/api/dokumente/[id]/ocr/route.ts):**
    POST handler: Auth check, find Dokument, reset `ocrStatus` to `AUSSTEHEND`, `ocrVersuche` to 0, `ocrFehler` to null.
    Enqueue new OCR job. Return 200 with updated status.

    **6. Create admin pipeline dashboard API (src/app/api/admin/pipeline/route.ts):**
    GET handler (ADMIN role required):
    - Return OCR queue stats (waiting, active, completed, failed counts) from `ocrQueue.getJobCounts()`
    - Return embedding queue stats similarly
    - Return list of failed OCR documents from Prisma: `dokument.findMany({ where: { ocrStatus: "FEHLGESCHLAGEN" }, take: 50 })`
    POST handler: Bulk retry -- accept `{ action: "retry-all-failed" }`, find all FEHLGESCHLAGEN documents, reset and re-enqueue.

    **7. Update Meilisearch index (src/lib/meilisearch.ts):**
    Update `DokumentSearchRecord` interface: add `ocrStatus`, `dokumentStatus`, `createdByName` fields.
    Update `ensureDokumenteIndex()`: add `ocrStatus`, `dokumentStatus`, `createdAt` to filterableAttributes. Add `createdByName` to searchableAttributes.
    Update `searchDokumente()`: add support for `tags`, `ocrStatus`, `dokumentStatus`, `createdById`, `dateFrom`, `dateTo` filter parameters. Add `attributesToHighlight: ["ocrText", "name"]` and `highlightPreTag`/`highlightPostTag` to search options for snippet support.

    **8. Create tag management API (src/app/api/dokumente/tags/route.ts):**
    GET: List all DokumentTagKategorie records ordered by sortierung.
    POST (ADMIN only): Create new tag category `{ name, farbe, system? }`.
    PATCH: Update tag category `{ id, name?, farbe?, sortierung? }`.
    DELETE (ADMIN only): Delete tag category by id.
  </action>
  <verify>
    <automated>cd /Users/patrickbaumfalk/Projekte/AI-Lawyer && npx tsc --noEmit --pretty 2>&1 | head -30</automated>
    <manual>Check that upload API enqueues OCR jobs, OCR processor handles PDF/image/text routing, admin pipeline API returns queue stats, tag API has CRUD operations</manual>
  </verify>
  <done>
    - OCR processor fetches files from MinIO, routes by MIME type, calls Stirling-PDF, stores result, indexes in Meilisearch, chains to embedding queue
    - Preview processor generates PDF previews for non-PDF documents
    - Both processors registered in worker.ts with Socket.IO notifications
    - Document upload POST enqueues OCR job automatically with 100 MB limit
    - Manual re-OCR endpoint allows retry of failed documents
    - Admin pipeline dashboard shows queue stats and failed documents with bulk retry
    - Meilisearch index enhanced with OCR status, document status, date filtering, and search highlighting
    - Tag management CRUD API with admin-only create/delete
  </done>
</task>

<task type="auto">
  <name>Task 3: OCR Badge + Upload Provider + Upload Panel + Drag-and-Drop Zone + Tag Settings Page</name>
  <files>
    src/components/dokumente/ocr-status-badge.tsx
    src/components/providers/upload-provider.tsx
    src/components/dokumente/upload-panel.tsx
    src/components/dokumente/dokumente-tab.tsx
    src/app/(dashboard)/einstellungen/dokument-tags/page.tsx
  </files>
  <action>
    **1. Create OCR status badge component (src/components/dokumente/ocr-status-badge.tsx):**
    Client component showing color-coded OCR status:
    - AUSSTEHEND: gray badge "OCR ausstehend"
    - IN_BEARBEITUNG: blue badge with spinner "OCR laeuft..."
    - ABGESCHLOSSEN: green badge "OCR abgeschlossen"
    - FEHLGESCHLAGEN: red badge "OCR fehlgeschlagen" with retry button (calls POST /api/dokumente/{id}/ocr)
    - NICHT_NOETIG: no badge (hidden)
    Use shadcn Badge component with appropriate variant colors.

    **2. Create UploadProvider (src/components/providers/upload-provider.tsx):**
    React context providing:
    - `addFiles(akteId: string, files: File[]): void` -- starts upload for each file
    - `uploads: UploadItem[]` -- current upload state
    - `clearCompleted(): void` -- remove done items
    - `isUploading: boolean` -- any active uploads
    UploadItem: `{ id, file, akteId, progress, status: "uploading" | "ocr-queued" | "done" | "error", error? }`
    Upload logic: For each file, POST to `/api/akten/{akteId}/dokumente` as FormData, track progress via XMLHttpRequest (for progress events). On success, set status to "ocr-queued". Listen for Socket.IO `document:ocr-complete` events to update status to "done".

    Mount `<UploadProvider>` in the dashboard layout (src/app/(dashboard)/layout.tsx) AFTER existing providers.

    **3. Create floating upload panel (src/components/dokumente/upload-panel.tsx):**
    Fixed-position bottom-right panel (Google Drive style):
    - Only visible when `uploads.length > 0`
    - Collapsible header showing "{N} Uploads" with expand/collapse toggle
    - Per-file row: filename, progress bar, status icon (spinner/check/error)
    - "Alle entfernen" button to clear completed
    - Use Tailwind for styling: `fixed bottom-4 right-4 z-50 w-80 shadow-lg rounded-lg`
    Render UploadPanel inside UploadProvider (in layout, after main content).

    **4. Add drag-and-drop upload zone to case documents tab (src/components/dokumente/dokumente-tab.tsx):**
    This is a locked user decision: "Drag-and-drop zone + traditional file picker button on case documents tab, multi-file support."
    - Import `useUpload` from the UploadProvider context
    - Add a drag-and-drop zone wrapping the document list area. Use `onDragOver`, `onDragEnter`, `onDragLeave`, `onDrop` handlers on a container div:
      - On drag enter/over: Show a visual overlay with dashed border and "Dateien hier ablegen" text (prevent default to allow drop)
      - On drop: Extract files from `e.dataTransfer.files`, call `uploadProvider.addFiles(akteId, files)` where `akteId` comes from the component's props/context
      - On drag leave: Remove the visual overlay
    - Add a file picker button (styled with shadcn Button + Upload icon) that opens a native file input (`<input type="file" multiple accept="*/*" />`)
      - On file selection: Call `uploadProvider.addFiles(akteId, selectedFiles)`
    - Position the file picker button in the existing toolbar area alongside the existing upload button (replace or enhance the existing `UploadDialog` trigger)
    - Multi-file support: both drag-and-drop and file picker accept multiple files
    - The drag-and-drop zone should cover the entire documents area so users can drop files anywhere on the tab

    **5. Create tag management settings page (src/app/(dashboard)/einstellungen/dokument-tags/page.tsx):**
    Admin-only page following existing Kanzlei-Einstellungen tab pattern:
    - List of tag categories with color swatch, name, system flag
    - Add/edit/delete operations
    - Seed predefined system tags on first load: Schriftsatz (blue), Vertrag (purple), Rechnung (green), Gutachten (orange), Korrespondenz (slate), Vollmacht (teal), Bescheid (amber), Sonstiges (gray)
    - Consistent with existing settings pages (glass card sections, form inputs).
  </action>
  <verify>
    <automated>cd /Users/patrickbaumfalk/Projekte/AI-Lawyer && npx tsc --noEmit --pretty 2>&1 | head -30</automated>
    <manual>Check that OCR badge shows colored status, upload panel renders in bottom-right, drag-and-drop zone is visible on case documents tab with drop overlay, file picker button opens native file dialog, tag management page works</manual>
  </verify>
  <done>
    - OCR status badge shows colored status on documents with retry button for failed
    - UploadProvider context mounted in dashboard layout, provides addFiles/uploads/clearCompleted
    - Floating upload panel persists across navigation, shows per-file progress
    - Case documents tab has drag-and-drop zone covering the document area with visual drop indicator
    - File picker button on case documents tab opens native multi-file dialog
    - Both drag-and-drop and file picker call uploadProvider.addFiles(akteId, files)
    - Tag management settings page with predefined categories and CRUD operations
  </done>
</task>

</tasks>

<verification>
1. `npx prisma validate` passes (schema is valid)
2. `npx tsc --noEmit` passes (TypeScript compiles)
3. Stirling-PDF service defined in docker-compose.yml with health check
4. OCR queue, embedding queue, and preview queue registered in ALL_QUEUES
5. Document upload POST handler enqueues OCR job
6. OCR processor handles PDF, image, and text file types
7. Meilisearch index settings include OCR status and document status filters
8. Case documents tab has drag-and-drop zone and file picker button
</verification>

<success_criteria>
- A PDF uploaded via the API triggers an OCR BullMQ job that calls Stirling-PDF and stores extracted text
- OCR status is tracked per document (AUSSTEHEND -> IN_BEARBEITUNG -> ABGESCHLOSSEN/FEHLGESCHLAGEN)
- OCR'd text is indexed in Meilisearch for full-text search
- Non-PDF documents get PDF preview generated via Stirling-PDF
- Floating upload panel shows progress and OCR status
- Drag-and-drop zone on case documents tab allows file upload via drop or file picker button
- Admin can view pipeline stats and bulk-retry failed OCR jobs
- Tag categories can be managed by admins
</success_criteria>

<output>
After completion, create `.planning/phases/04-document-pipeline-ocr-rag-ingestion/04-01-SUMMARY.md`
</output>
