---
phase: 13-hybrid-search-reranking
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/ai/reranker.ts
  - src/lib/embedding/hybrid-search.ts
autonomous: true
requirements:
  - RAGQ-01
  - RAGQ-03

must_haves:
  truths:
    - "hybridSearch() returns HybridSearchResult[] with contextContent populated from parent or STANDALONE chunk"
    - "rerankWithOllama() scores 50 candidates via single Ollama batch prompt and returns Top-10"
    - "rerankWithOllama() falls back silently to RRF order when Ollama times out or returns non-JSON"
    - "reciprocalRankFusion() merges BM25 and vector ranked lists with k=60 formula"
  artifacts:
    - path: "src/lib/ai/reranker.ts"
      provides: "rerankWithOllama() with AbortSignal.timeout(3000) fallback"
      exports: ["rerankWithOllama", "RrfCandidate"]
    - path: "src/lib/embedding/hybrid-search.ts"
      provides: "hybridSearch() orchestrator — BM25 + pgvector + RRF + reranker"
      exports: ["hybridSearch", "HybridSearchResult", "reciprocalRankFusion"]
  key_links:
    - from: "src/lib/embedding/hybrid-search.ts"
      to: "src/lib/ai/reranker.ts"
      via: "rerankWithOllama() call after RRF"
      pattern: "rerankWithOllama"
    - from: "src/lib/embedding/hybrid-search.ts"
      to: "src/lib/meilisearch.ts"
      via: "searchDokumente() for BM25 candidates"
      pattern: "searchDokumente"
    - from: "src/lib/embedding/hybrid-search.ts"
      to: "src/lib/embedding/vector-store.ts"
      via: "searchSimilar() for vector candidates (updated in Plan 02 to filter PARENT)"
      pattern: "searchSimilar"
---

<objective>
Create the two new library files that form the core of Phase 13's hybrid retrieval pipeline: a reranker module and a hybrid-search orchestrator.

Purpose: These files define the contracts and implementation for RRF fusion and LLM-as-reranker. Plan 03 wires them into the live routes. Plan 02 (parallel) upgrades chunking and storage. Having all exports defined here lets Plan 03 import without discovery.

Output: `src/lib/ai/reranker.ts` and `src/lib/embedding/hybrid-search.ts` — both fully implemented and TypeScript-clean.
</objective>

<execution_context>
@/Users/patrickbaumfalk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/patrickbaumfalk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/13-hybrid-search-reranking/13-RESEARCH.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From src/lib/meilisearch.ts:
```typescript
export interface DokumentSearchRecord {
  id: string;          // dokumentId (NOT chunk ID)
  akteId: string;
  name: string;
  ocrText: string | null;
  aktenzeichen: string;
  kurzrubrum: string;
  // ... more fields
}

// searchDokumente returns Meilisearch SearchResponse with hits: DokumentSearchRecord[]
// hits[i]._rankingScore: number (0-1, BM25 relevance)
export async function searchDokumente(
  query: string,
  options?: { akteId?: string; limit?: number; offset?: number; /* ... */ }
): Promise<SearchResponse<DokumentSearchRecord>>
```

From src/lib/embedding/vector-store.ts (current — Plan 02 will add chunkType/parentChunkId to RawRow):
```typescript
export interface SearchResult {
  content: string;
  dokumentId: string;
  dokumentName: string;
  akteAktenzeichen: string;
  akteBeschreibung: string;
  score: number;
  chunkIndex: number;
}

export async function searchSimilar(
  queryEmbedding: number[],
  opts: { akteId?: string; limit?: number; modelVersion?: string; crossAkte?: boolean; userId?: string }
): Promise<SearchResult[]>
```

Note: Plan 02 (parallel) adds `chunkType` and `parentChunkId` to `SearchResult` and filters PARENT chunks.
The `hybridSearch()` function in this plan must handle STANDALONE chunks gracefully (no parentChunkId).

From src/lib/db.ts:
```typescript
import { prisma } from "@/lib/db";
// prisma is a PrismaClient instance
```

ChunkType enum (from Prisma schema, Phase 12):
```typescript
// Available values: 'STANDALONE' | 'PARENT' | 'CHILD'
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create reranker module</name>
  <files>src/lib/ai/reranker.ts</files>
  <action>
Create `src/lib/ai/reranker.ts`. First check if `src/lib/ai/` directory exists; if not, create it.

The module exports:

1. `RrfCandidate` interface — shared type used by both reranker and hybrid-search:
```typescript
export interface RrfCandidate {
  id: string;           // chunk ID (DocumentChunk.id)
  dokumentId: string;
  dokumentName: string;
  akteAktenzeichen: string;
  akteBeschreibung: string;
  content: string;      // child chunk content (500 tokens) — retrieval match
  chunkType: string;    // 'STANDALONE' | 'CHILD' | 'PARENT'
  parentChunkId: string | null;
  score: number;        // RRF score
  sources: ('bm25' | 'vector')[];
}
```

2. `rerankWithOllama(query, candidates, timeoutMs?)` — pointwise batch reranker:
- Reads `OLLAMA_URL` from `process.env.OLLAMA_URL ?? 'http://localhost:11434'`
- Uses model `qwen3.5:35b`
- Builds a single batch prompt with all candidates (truncate each to 300 chars) — NOT one call per candidate
- Prompt format: German legal context, ask for integer score 0-10 per passage id, respond with JSON only
- Ollama call: POST `/api/generate` with `stream: false`, `temperature: 0`, `num_predict: 500`
- Use `AbortSignal.timeout(timeoutMs ?? 3000)` on the fetch call
- JSON extraction from response: use regex `response.match(/\{[\s\S]*\}/)` FIRST (handles Qwen3 `<think>...</think>` prefix), then `JSON.parse()` on the matched string
- On ANY error (timeout, non-JSON, Ollama down): `console.warn('[reranker] Fallback to RRF order:', err)` and return `candidates.slice(0, 10)`
- On success: sort candidates by extracted score descending, take Top-10; candidates with missing score get score 0

Avoid: individual Ollama calls per candidate (50 calls = 10-25s). Use one batch prompt for all candidates.
  </action>
  <verify>
    <automated>cd /Users/patrickbaumfalk/Projekte/AI-Lawyer && npx tsc --noEmit --skipLibCheck 2>&1 | grep -E "reranker|error TS" | head -20</automated>
  </verify>
  <done>src/lib/ai/reranker.ts exists, exports RrfCandidate and rerankWithOllama, TypeScript compiles without errors in that file</done>
</task>

<task type="auto">
  <name>Task 2: Create hybrid-search orchestrator</name>
  <files>src/lib/embedding/hybrid-search.ts</files>
  <action>
Create `src/lib/embedding/hybrid-search.ts`.

The module exports:

1. `HybridSearchResult` interface:
```typescript
export interface HybridSearchResult {
  id: string;
  dokumentId: string;
  dokumentName: string;
  akteAktenzeichen: string;
  akteBeschreibung: string;
  content: string;          // child chunk content — retrieval match evidence
  contextContent: string;   // parent content (2000 tokens) or STANDALONE content — used in LLM prompt
  score: number;            // RRF score
  sources: ('bm25' | 'vector')[];
}
```

2. `reciprocalRankFusion(bm25Results, vectorResults, limit)` — pure TypeScript RRF:
- k=60 (hardcoded constant per RRF paper)
- Formula: `score(doc) = Σ 1 / (k + rank_i(doc))` summed over both lists
- Use `Map<string, { score, data, sources }>` keyed by chunk ID
- Return array sorted by score descending, sliced to `limit`
- Export this function (used in tests and Plan 03)

3. `hybridSearch(queryText, queryEmbedding, opts)` — main orchestrator:

```typescript
export async function hybridSearch(
  queryText: string,
  queryEmbedding: number[],
  opts: {
    akteId?: string;
    crossAkte?: boolean;
    userId?: string;
    bm25Limit?: number;
    vectorLimit?: number;
    finalLimit?: number;
  }
): Promise<HybridSearchResult[]>
```

Implementation steps inside `hybridSearch`:

Step 1: Parallel retrieval
- BM25: call `searchDokumente(queryText, { akteId, limit: bm25Limit })` from `src/lib/meilisearch.ts`
  - For cross-Akte mode: if `crossAkte && userId`, fetch accessible akteIds from `prisma.akte.findMany({ where: { OR: [{ anwaltId: userId }, { sachbearbeiterId: userId }] }, select: { id: true } })`, then call searchDokumente without akteId filter (Meilisearch has no multi-akteId filter syntax) — BUT apply the accessible list as a post-filter on hits
  - If BM25 returns 0 hits: skip BM25 in RRF entirely, return vector-only results
- Vector: call `searchSimilar(queryEmbedding, { akteId, crossAkte, userId, limit: vectorLimit })` from `src/lib/embedding/vector-store.ts`

Step 2: BM25 document-to-chunk resolution
- Meilisearch returns document-level hits. For each BM25 document hit, find its best child chunk via a single pgvector query: `WHERE d.id = ANY(${bm25DocumentIds}) AND dc.chunkType != 'PARENT' AND dc.embedding IS NOT NULL ORDER BY dc.embedding <=> ${vectorSql}::vector ASC LIMIT 1 per document`
- Use raw SQL with `prisma.$queryRaw` and `DISTINCT ON (dc."dokumentId")` to get one chunk per BM25 document in a single round-trip (not N+1)
- Assign the BM25 rank of the source document to the resolved chunk

Step 3: RRF fusion
- Call `reciprocalRankFusion(bm25ChunkCandidates, vectorHits, 50)`

Step 4: Reranking
- Call `rerankWithOllama(queryText, rrfTop50, 3000)` from `src/lib/ai/reranker.ts`

Step 5: Parent content lookup
- Filter reranked results for `chunkType === 'CHILD'` — fetch parent content via single raw SQL JOIN on `parentChunkId`
- Use `Map<childId, parentContent>`
- For `chunkType === 'STANDALONE'`: use `content` as `contextContent`
- Apply 12,000-char total budget: top 3 results get full parentContent, remaining get child content (prevents LLM context overflow per research pitfall 6)

Step 6: Return `HybridSearchResult[]` with `contextContent` populated

Important edge cases:
- If `queryText` is empty: return `[]` immediately
- If both BM25 and vector return 0 results: return `[]`
- STANDALONE chunk handling: `contextContent = content` (no parent lookup needed)
- Cross-Akte RBAC: Meilisearch does not enforce per-user access. In cross-Akte mode, post-filter BM25 hits to only include documents from accessible akteIds.
  </action>
  <verify>
    <automated>cd /Users/patrickbaumfalk/Projekte/AI-Lawyer && npx tsc --noEmit --skipLibCheck 2>&1 | grep -E "hybrid-search|error TS" | head -20</automated>
  </verify>
  <done>src/lib/embedding/hybrid-search.ts exists, exports HybridSearchResult, reciprocalRankFusion, hybridSearch — TypeScript compiles without errors in that file</done>
</task>

</tasks>

<verification>
Run full TypeScript check: `cd /Users/patrickbaumfalk/Projekte/AI-Lawyer && npx tsc --noEmit --skipLibCheck 2>&1 | head -30`

Both new files must be TypeScript-clean. The files should be importable from Plan 03 without modification.
</verification>

<success_criteria>
- `src/lib/ai/reranker.ts` exists with `RrfCandidate` interface and `rerankWithOllama()` function
- `src/lib/embedding/hybrid-search.ts` exists with `HybridSearchResult` interface, `reciprocalRankFusion()`, and `hybridSearch()`
- TypeScript compilation succeeds (`npx tsc --noEmit`) with no errors in these files
- Reranker uses single batch prompt (not per-candidate), AbortSignal.timeout(3000), regex JSON extraction, graceful fallback
- hybridSearch handles STANDALONE backward compatibility (contextContent = content for STANDALONE)
- Cross-Akte RBAC enforced: BM25 hits post-filtered to accessible akteIds in cross-Akte mode
</success_criteria>

<output>
After completion, create `.planning/phases/13-hybrid-search-reranking/13-01-SUMMARY.md`
</output>
