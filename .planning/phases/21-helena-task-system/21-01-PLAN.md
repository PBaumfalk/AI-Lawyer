---
phase: 21-helena-task-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/helena/at-mention-parser.ts
  - src/lib/helena/task-service.ts
  - src/lib/queue/queues.ts
  - src/lib/queue/processors/helena-task.processor.ts
autonomous: true
requirements: [TASK-01, TASK-03, TASK-04, AGNT-07]

must_haves:
  truths:
    - "@Helena mention in text is detected and parsed into a task instruction"
    - "HelenaTask record is created with PENDING status and correct priority before BullMQ job is enqueued"
    - "BullMQ helena-task queue uses lockDuration 120000 to prevent stall during long LLM calls"
    - "Helena-task processor runs runHelenaAgent() and stores complete AgentStep[] trace in HelenaTask.steps"
    - "Socket.IO progress events are emitted per step with taskId, akteId, stepNumber, and toolName"
    - "Manual @-tag tasks get priority 8 (BullMQ priority 2), scanner tasks get priority 3 (BullMQ priority 7)"
  artifacts:
    - path: "src/lib/helena/at-mention-parser.ts"
      provides: "@Helena mention detection and task text extraction"
      exports: ["parseHelenaMention", "hasHelenaMention"]
    - path: "src/lib/helena/task-service.ts"
      provides: "HelenaTask CRUD with BullMQ job enqueue"
      exports: ["createHelenaTask", "CreateTaskOptions"]
    - path: "src/lib/queue/queues.ts"
      provides: "helenaTaskQueue with lockDuration 120000"
      contains: "helenaTaskQueue"
    - path: "src/lib/queue/processors/helena-task.processor.ts"
      provides: "BullMQ processor bridging jobs to runHelenaAgent()"
      exports: ["processHelenaTask", "abortTask", "HelenaTaskJobData"]
  key_links:
    - from: "src/lib/helena/task-service.ts"
      to: "src/lib/queue/queues.ts"
      via: "helenaTaskQueue.add()"
      pattern: "helenaTaskQueue\\.add"
    - from: "src/lib/queue/processors/helena-task.processor.ts"
      to: "src/lib/helena/index.ts"
      via: "runHelenaAgent()"
      pattern: "runHelenaAgent"
    - from: "src/lib/queue/processors/helena-task.processor.ts"
      to: "src/lib/socket/emitter.ts"
      via: "getSocketEmitter()"
      pattern: "getSocketEmitter"
---

<objective>
Create the @Helena mention parser, task service, BullMQ helena-task queue, and processor that bridges BullMQ jobs to runHelenaAgent() with Socket.IO progress events.

Purpose: This is the infrastructure layer that enables all Helena task execution -- parsing @Helena mentions, creating HelenaTask records, enqueuing BullMQ jobs with priority, and executing the agent loop with full trace capture and real-time progress reporting.

Output: 4 new files providing the complete task creation and execution pipeline. Plan 02 wires these into API routes and the worker process.
</objective>

<execution_context>
@/Users/patrickbaumfalk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/patrickbaumfalk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-helena-task-system/21-RESEARCH.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From src/lib/helena/index.ts:
```typescript
export interface HelenaAgentOptions {
  prisma: PrismaClient;
  userId: string;
  userRole: UserRole;
  userName: string;
  akteId: string | null;
  message: string;
  conversationHistory?: CoreMessage[];
  mode?: "inline" | "background" | "auto";
  onStepUpdate?: (step: StepUpdate) => void;
  abortSignal?: AbortSignal;
  helenaMemory?: Record<string, unknown> | null;
}

export interface HelenaAgentResult {
  text: string;
  mode: "inline" | "background";
  tier: 1 | 2 | 3;
  steps: AgentStep[];
  totalTokens: { prompt: number; completion: number };
  finishReason: string;
  capReached: boolean;
  continueInBackground?: boolean;
  rateLimited?: boolean;
}
```

From src/lib/helena/orchestrator.ts:
```typescript
export interface StepUpdate {
  stepNumber: number;
  maxSteps: number;
  toolName: string | null;
  toolParams?: Record<string, unknown>;
  resultSummary: string;
  tokenEstimate: number;
}

export interface AgentStep {
  type: "thought" | "toolCall" | "toolResult" | "error";
  content: string;
  toolName?: string;
  toolParams?: Record<string, unknown>;
  timestamp: string;
}
```

From prisma/schema.prisma:
```prisma
model HelenaTask {
  id          String           @id @default(cuid())
  akteId      String
  userId      String
  auftrag     String           @db.Text
  status      HelenaTaskStatus @default(PENDING)
  modus       String           @default("BACKGROUND")
  prioritaet  Int              @default(5)
  steps       Json             @default("[]")
  ergebnis    String?          @db.Text
  fehler      String?          @db.Text
  startedAt   DateTime?
  completedAt DateTime?
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt
  drafts      HelenaDraft[]
}

enum HelenaTaskStatus {
  PENDING
  RUNNING
  DONE
  FAILED
  WAITING_APPROVAL
  ABGEBROCHEN
}
```

From src/lib/queue/queues.ts (pattern):
```typescript
import { Queue } from "bullmq";
import { getQueueConnection } from "@/lib/queue/connection";

export const embeddingQueue = new Queue("document-embedding", {
  connection: getQueueConnection(),
  defaultJobOptions: {
    attempts: 3,
    backoff: { type: "custom" },
    removeOnComplete: { age: 86_400 },
    removeOnFail: { age: 604_800 },
  },
});

export const ALL_QUEUES: Queue[] = [ /* all queues listed */ ];
```

From src/lib/socket/emitter.ts:
```typescript
export function getSocketEmitter(): Emitter;
// Emits to rooms: user:{userId}, akte:{akteId}, role:{roleName}
```

From src/lib/queue/connection.ts:
```typescript
export function getQueueConnection(): Redis;
export function getWorkerConnection(): Redis;
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: @Helena mention parser and task service</name>
  <files>
    src/lib/helena/at-mention-parser.ts
    src/lib/helena/task-service.ts
  </files>
  <action>
**1. Create `src/lib/helena/at-mention-parser.ts`:**

Export two functions:

`parseHelenaMention(text: string): string | null`
- Match `@Helena` (case-insensitive) followed by text using regex `/@helena\s+(.+)/is`
- Use `s` flag (dotall) so multiline instructions work
- Return trimmed instruction text, or null if no match / empty text after @Helena
- Strip HTML tags from input before regex matching (simple `text.replace(/<[^>]*>/g, "")`) to handle rich text editors
- If `@Helena` appears alone with no text after it, return `null` (will be handled upstream as "infer from context")

`hasHelenaMention(text: string): boolean`
- Simple test: `/@helena\b/i.test(text)`
- Does not strip HTML (caller decides whether to strip first)

Both functions are pure, no side effects, no imports beyond standard library.

**2. Create `src/lib/helena/task-service.ts`:**

Import: `prisma` from `@/lib/db`, `helenaTaskQueue` from `@/lib/queue/queues`, `createLogger` from `@/lib/logger`.

Export interface `CreateTaskOptions`:
```typescript
{
  userId: string;
  userRole: string;
  userName: string;
  akteId: string;
  auftrag: string;
  /** 1-10, higher = more urgent. Manual @-tag: 8, scanner: 3 */
  prioritaet?: number;
  /** Source: "at-mention" | "manual" | "scanner" | "chat" */
  quelle?: string;
}
```

Export async function `createHelenaTask(options: CreateTaskOptions)`:
1. Destructure with defaults: `prioritaet = 5`, `quelle = "manual"`
2. Create HelenaTask record via `prisma.helenaTask.create()` with `status: "PENDING"`, `modus: "BACKGROUND"`, all fields from options
3. Calculate BullMQ priority: `const bullmqPriority = Math.max(1, 10 - prioritaet)` (inverted: higher domain priority -> lower BullMQ number -> processed first)
4. Build `HelenaTaskJobData` object (import type from processor)
5. Enqueue via `helenaTaskQueue.add("helena-task", jobData, { priority: bullmqPriority, jobId: \`helena-task-${task.id}\` })`
6. Log task creation: `log.info({ taskId: task.id, akteId, prioritaet, quelle }, "Helena task created")`
7. Return the created task record

**Important:** Always `await` the Prisma create BEFORE `helenaTaskQueue.add()` to prevent race condition (Pitfall 3 from research).
  </action>
  <verify>
    <automated>npx tsc --noEmit src/lib/helena/at-mention-parser.ts src/lib/helena/task-service.ts 2>&1 | head -20</automated>
  </verify>
  <done>
    - parseHelenaMention correctly extracts instruction text from "@Helena [text]" patterns (case-insensitive, HTML-stripped)
    - hasHelenaMention detects @Helena presence
    - createHelenaTask creates Prisma record then enqueues BullMQ job with inverted priority mapping
    - Priority mapping: manual (8) -> BullMQ 2, scanner (3) -> BullMQ 7
  </done>
</task>

<task type="auto">
  <name>Task 2: BullMQ helena-task queue and processor with Socket.IO progress</name>
  <files>
    src/lib/queue/queues.ts
    src/lib/queue/processors/helena-task.processor.ts
  </files>
  <action>
**1. Add `helenaTaskQueue` to `src/lib/queue/queues.ts`:**

Add after the last existing queue definition (musterIngestionQueue) and before the `ALL_QUEUES` array:

```typescript
/** Helena-Task queue for @Helena agent runs */
export const helenaTaskQueue = new Queue("helena-task", {
  connection: getQueueConnection(),
  defaultJobOptions: {
    attempts: 1,               // Agent tasks are NOT retryable (not idempotent)
    removeOnComplete: { age: 86_400 * 7 },  // 7 days for audit trail
    removeOnFail: { age: 86_400 * 30 },     // 30 days for debugging
  },
});
```

Add `helenaTaskQueue` to the `ALL_QUEUES` array.

**2. Create `src/lib/queue/processors/helena-task.processor.ts`:**

Import: `type Job` from `bullmq`, `prisma` from `@/lib/db`, `runHelenaAgent` from `@/lib/helena`, `getSocketEmitter` from `@/lib/socket/emitter`, `createLogger` from `@/lib/logger`, `type UserRole` from `@prisma/client`.

Export interface `HelenaTaskJobData`:
```typescript
{
  taskId: string;
  userId: string;
  userRole: string;
  userName: string;
  akteId: string;
  auftrag: string;
  prioritaet: number;
}
```

**AbortController Management:**
- Module-level `const abortControllers = new Map<string, AbortController>()`
- Export function `abortTask(taskId: string): boolean` -- looks up controller, calls `.abort("user-cancel")`, returns true if found
- Export function `getActiveTaskIds(): string[]` -- returns `Array.from(abortControllers.keys())` (for startup recovery)

**Export async function `processHelenaTask(job: Job<HelenaTaskJobData>)`:**

1. Destructure `{ taskId, userId, userRole, userName, akteId, auftrag }` from `job.data`
2. Get socket emitter: `const emitter = getSocketEmitter()`
3. Create AbortController, store in map: `abortControllers.set(taskId, controller)`
4. Wrap in try/catch/finally:

**try block:**
a. Update task status to RUNNING: `prisma.helenaTask.update({ where: { id: taskId }, data: { status: "RUNNING", startedAt: new Date() } })`
b. Emit `helena:task-started` to `user:${userId}` room with `{ taskId, akteId, auftrag }`
c. **Load HelenaMemory if exists** (Phase 19 model exists): `const memory = await prisma.helenaMemory.findUnique({ where: { akteId } })`. Pass `memory?.content as Record<string, unknown> | null` to agent options. This gives immediate benefit before Phase 25.
d. Call `runHelenaAgent()` with:
   - `prisma`, `userId`, `userRole: userRole as UserRole`, `userName`, `akteId`, `message: auftrag`
   - `mode: "background"` (always background for queued tasks)
   - `abortSignal: controller.signal`
   - `helenaMemory: memory?.content ?? null`
   - `onStepUpdate: (step) => { ... }` callback that:
     - Calls `job.updateProgress({ stepNumber: step.stepNumber, maxSteps: step.maxSteps, toolName: step.toolName, resultSummary: step.resultSummary })` -- this resets BullMQ lock timer (anti-stall, AGNT-07)
     - Emits `helena:task-progress` to `user:${userId}` room with `{ taskId, akteId, stepNumber: step.stepNumber, maxSteps: step.maxSteps, toolName: step.toolName, resultSummary: step.resultSummary }`
e. Determine final status: `result.finishReason === "abort" ? "ABGEBROCHEN" : "DONE"`
f. Update task with result: `prisma.helenaTask.update({ where: { id: taskId }, data: { status: finalStatus, steps: result.steps as any, ergebnis: result.text, completedAt: new Date() } })`
g. Emit `helena:task-completed` to `user:${userId}` with `{ taskId, akteId, status: finalStatus, ergebnis: result.text.slice(0, 200) }`

**catch block:**
- Extract error message: `const errMsg = error instanceof Error ? error.message : String(error)`
- Log error: `log.error({ taskId, error: errMsg }, "Helena task failed")`
- Update task: `prisma.helenaTask.update({ where: { id: taskId }, data: { status: "FAILED", fehler: errMsg, completedAt: new Date() } })`
- Emit `helena:task-failed` to `user:${userId}` with `{ taskId, akteId, error: errMsg }`

**finally block:**
- Clean up: `abortControllers.delete(taskId)`

**Socket.IO Event Types (document in JSDoc):**
- `helena:task-started` -> `{ taskId, akteId, auftrag }`
- `helena:task-progress` -> `{ taskId, akteId, stepNumber, maxSteps, toolName, resultSummary }`
- `helena:task-completed` -> `{ taskId, akteId, status, ergebnis }`
- `helena:task-failed` -> `{ taskId, akteId, error }`

**Anti-patterns to avoid:**
- Do NOT set `attempts > 1` on the queue (agent runs are not idempotent)
- Do NOT use default lockDuration (30s) -- set on Worker, not Queue (Plan 02 handles Worker config)
- Do NOT store AbortControllers in Redis (must be in-process)
- Do NOT enqueue before creating HelenaTask (race condition)
  </action>
  <verify>
    <automated>npx tsc --noEmit src/lib/queue/queues.ts src/lib/queue/processors/helena-task.processor.ts 2>&1 | head -20</automated>
  </verify>
  <done>
    - helenaTaskQueue is defined with attempts: 1, 7-day complete retention, 30-day fail retention
    - helenaTaskQueue appears in ALL_QUEUES array
    - processHelenaTask bridges BullMQ job to runHelenaAgent() with progress and abort
    - job.updateProgress() called in onStepUpdate callback (resets lock timer per AGNT-07)
    - Socket.IO events emitted for started/progress/completed/failed
    - AbortController map with abortTask() export for abort API
    - HelenaMemory loaded from DB and passed to agent (if exists)
    - Complete AgentStep[] trace stored in HelenaTask.steps on completion (TASK-03)
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` compiles all 4 new files without errors
2. `at-mention-parser.ts` has no external dependencies (pure functions)
3. `task-service.ts` imports from existing `@/lib/db`, `@/lib/queue/queues`, and `@/lib/logger`
4. `helena-task.processor.ts` imports from existing `@/lib/helena`, `@/lib/db`, `@/lib/socket/emitter`
5. `helenaTaskQueue` is listed in `ALL_QUEUES` in `queues.ts`
6. No new npm packages needed
</verification>

<success_criteria>
- @Helena mention detection works for case-insensitive patterns with HTML stripping
- Task service creates HelenaTask record then enqueues BullMQ job (correct order)
- Priority inversion mapping documented and correct: domain 8 -> BullMQ 2
- helena-task queue has attempts: 1 (no retry for non-idempotent agent runs)
- Processor uses runHelenaAgent() with mode: "background" and full trace capture
- Socket.IO progress events fire per step with correct room targeting
- AbortController lifecycle: create -> store in Map -> abort on signal -> delete in finally
</success_criteria>

<output>
After completion, create `.planning/phases/21-helena-task-system/21-01-SUMMARY.md`
</output>
