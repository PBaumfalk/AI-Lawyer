---
phase: 17-urteile-rag
plan: "02"
type: execute
wave: 2
depends_on: ["17-01"]
files_modified:
  - src/lib/queue/processors/urteile-sync.processor.ts
  - src/lib/queue/queues.ts
  - src/worker.ts
autonomous: true
requirements: [URTEIL-01, URTEIL-02]

must_haves:
  truths:
    - "processUrteileSyncJob() fetches all 7 RSS feeds, skips GUIDs already in cache, ingests new items with PII gate, saves cache at end — returns { inserted, skipped, piiRejected, failed } counts"
    - "urteileSyncQueue is registered in queues.ts and exported alongside gesetzeSyncQueue"
    - "registerUrteileSyncJob() registers a daily cron at 03:00 Europe/Berlin using upsertJobScheduler — idempotent (safe to call on every worker boot)"
    - "urteile-sync Worker is registered in worker.ts and appears in the workers[] array"
    - "A per-court RSS fetch failure (network error) increments failed count and continues to next court — never aborts the full sync"
  artifacts:
    - path: "src/lib/queue/processors/urteile-sync.processor.ts"
      provides: "BullMQ processor: processUrteileSyncJob() orchestrates all 7 courts"
      exports: ["processUrteileSyncJob"]
    - path: "src/lib/queue/queues.ts"
      provides: "urteileSyncQueue + registerUrteileSyncJob() — mirrors gesetzeSyncQueue pattern"
      exports: ["urteileSyncQueue", "registerUrteileSyncJob"]
    - path: "src/worker.ts"
      provides: "urteile-sync Worker registration + startup cron call"
  key_links:
    - from: "src/lib/queue/processors/urteile-sync.processor.ts"
      to: "src/lib/urteile/ingestion.ts"
      via: "ingestUrteilItem() + loadGuidCache() + saveGuidCache() imports"
      pattern: "ingestUrteilItem"
    - from: "src/lib/queue/processors/urteile-sync.processor.ts"
      to: "src/lib/urteile/rss-client.ts"
      via: "fetchUrteileFeed() + BMJ_RSS_FEEDS imports"
      pattern: "fetchUrteileFeed"
    - from: "src/worker.ts"
      to: "src/lib/queue/queues.ts"
      via: "registerUrteileSyncJob() called in startup sequence"
      pattern: "registerUrteileSyncJob"
---

<objective>
Wire the Urteile sync BullMQ processor, queue, and daily cron. This plan makes the RSS ingestion pipeline operational — importable from the library (Plan 01), executable by BullMQ workers.

Purpose: Without this plan, no urteil_chunks are ever populated. The daily incremental feed (URTEIL-02) and initial full sweep (URTEIL-01) both run through this queue.

Output: A processor file, queue + cron registration in queues.ts, and worker registration in worker.ts — mirroring the gesetze-sync pattern exactly.
</objective>

<execution_context>
@/Users/patrickbaumfalk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/patrickbaumfalk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/17-urteile-rag/17-RESEARCH.md
@.planning/phases/17-urteile-rag/17-01-SUMMARY.md

<interfaces>
<!-- Key types and contracts from existing codebase — verified. -->

From src/lib/urteile/ingestion.ts (created in Plan 01):
```typescript
export async function ingestUrteilItem(item: UrteilRssItem): Promise<"inserted" | "pii_rejected" | "error">
export async function loadGuidCache(): Promise<Set<string>>
export async function saveGuidCache(guids: Set<string>): Promise<void>
```

From src/lib/urteile/rss-client.ts (created in Plan 01):
```typescript
export const BMJ_RSS_FEEDS: Record<string, string>  // 7 court codes
export async function fetchUrteileFeed(gerichtCode: string): Promise<UrteilRssItem[]>
```

From src/lib/logger.ts:
```typescript
export function createLogger(name: string): Logger  // pino-style, { err, gerichtCode } etc.
```

From src/lib/queue/queues.ts (existing pattern to mirror — lines 124-165, 248-265):
```typescript
// EXISTING gesetzeSyncQueue pattern:
export const gesetzeSyncQueue = new Queue("gesetze-sync", {
  connection: getQueueConnection(),
  defaultJobOptions: {
    attempts: 2,
    backoff: { type: "custom" },
    removeOnComplete: { age: 86_400 },
    removeOnFail: { age: 604_800 },
  },
});
export async function registerGesetzeSyncJob(cronPattern = "0 2 * * *"): Promise<void> {
  await gesetzeSyncQueue.upsertJobScheduler(
    "gesetze-sync-daily",
    { pattern: cronPattern, tz: "Europe/Berlin" },
    { name: "sync-gesetze", data: {}, opts: { removeOnComplete: { count: 10 }, removeOnFail: { count: 20 } } }
  );
}
```

From src/worker.ts (existing gesetze-sync Worker pattern — lines 524-566, 718-723):
```typescript
// EXISTING pattern to mirror for urteile-sync:
const gesetzeSyncWorker = new Worker("gesetze-sync", processGesetzeSyncJob, {
  connection: getQueueConnection(),
  concurrency: 1,
});
gesetzeSyncWorker.on("completed", (job) => { log.info(...); });
gesetzeSyncWorker.on("failed", (job, err) => { log.error(...); });
gesetzeSyncWorker.on("error", (err) => { log.error(...); });
workers.push(gesetzeSyncWorker);
log.info("[Worker] gesetze-sync processor registered");
// In startup sequence (line 720):
await registerGesetzeSyncJob();
// In graceful shutdown queue list (line 782):
"gesetze-sync"
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create urteile-sync.processor.ts — BullMQ processor for all 7 courts</name>
  <files>src/lib/queue/processors/urteile-sync.processor.ts</files>
  <action>
Create `src/lib/queue/processors/urteile-sync.processor.ts`. Mirror `gesetze-sync.processor.ts` structure.

```typescript
/**
 * BullMQ processor for daily Urteile RSS sync.
 * Fetches all 7 BMJ RSS feeds, skips already-seen GUIDs,
 * ingests new items through the inline PII gate.
 */
import { createLogger } from "@/lib/logger";
import { fetchUrteileFeed, BMJ_RSS_FEEDS } from "@/lib/urteile/rss-client";
import { ingestUrteilItem, loadGuidCache, saveGuidCache } from "@/lib/urteile/ingestion";

const log = createLogger("urteile-sync-processor");

export async function processUrteileSyncJob(): Promise<{
  inserted: number;
  skipped: number;
  piiRejected: number;
  failed: number;
}> {
  const guidCache = await loadGuidCache();
  let inserted = 0, skipped = 0, piiRejected = 0, failed = 0;

  for (const gerichtCode of Object.keys(BMJ_RSS_FEEDS)) {
    let items;
    try {
      items = await fetchUrteileFeed(gerichtCode);
    } catch (err) {
      log.error({ err, gerichtCode }, "RSS fetch failed — skipping court");
      failed++;
      continue;
    }

    for (const item of items) {
      if (guidCache.has(item.guid)) {
        skipped++;
        continue;
      }

      const result = await ingestUrteilItem(item);

      if (result === "inserted") {
        guidCache.add(item.guid);
        inserted++;
      } else if (result === "pii_rejected") {
        guidCache.add(item.guid); // Mark seen — do NOT retry PII-rejected items
        piiRejected++;
      } else {
        // "error" — do NOT add to guidCache (retry on next cron)
        failed++;
      }
    }
  }

  // Save cache AFTER all courts processed (batch save, same as gesetze SHA cache pattern)
  await saveGuidCache(guidCache);
  log.info({ inserted, skipped, piiRejected, failed }, "Urteile sync completed");
  return { inserted, skipped, piiRejected, failed };
}
```

**Key behaviors to implement exactly:**
- Per-court RSS fetch failure → log + `failed++` + continue (never aborts full sync)
- `"error"` from ingestUrteilItem → `failed++` but GUID NOT added to cache (enables retry on next cron)
- `"pii_rejected"` → GUID IS added to cache (prevents expensive NER re-run on same item)
- saveGuidCache called once at end (not after each court) — mirrors SHA cache batch pattern
  </action>
  <verify>
    <automated>cd /Users/patrickbaumfalk/Projekte/AI-Lawyer && npx tsc --noEmit 2>&1 | grep "urteile-sync\|urteile" | head -20</automated>
  </verify>
  <done>
    src/lib/queue/processors/urteile-sync.processor.ts exists, exports processUrteileSyncJob. Zero TypeScript errors for this file.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire urteileSyncQueue + Worker in queues.ts and worker.ts</name>
  <files>src/lib/queue/queues.ts, src/worker.ts</files>
  <action>
**In `src/lib/queue/queues.ts`:**

Read the file first. Add immediately after the gesetzeSyncQueue block (which ends around line 265):

1. Add `urteileSyncQueue` Queue instance:
```typescript
export const urteileSyncQueue = new Queue("urteile-sync", {
  connection: getQueueConnection(),
  defaultJobOptions: {
    attempts: 2,
    backoff: { type: "custom" },
    removeOnComplete: { age: 86_400 },
    removeOnFail: { age: 604_800 },
  },
});
```

2. Add `registerUrteileSyncJob()` — daily at 03:00 Europe/Berlin (one hour after gesetzeSyncJob at 02:00):
```typescript
export async function registerUrteileSyncJob(cronPattern = "0 3 * * *"): Promise<void> {
  await urteileSyncQueue.upsertJobScheduler(
    "urteile-sync-daily",
    { pattern: cronPattern, tz: "Europe/Berlin" },
    {
      name: "sync-urteile",
      data: {},
      opts: { removeOnComplete: { count: 10 }, removeOnFail: { count: 20 } },
    }
  );
}
```

3. Add `urteileSyncQueue` to the existing `allQueues` array (or equivalent export used by graceful shutdown). Read the file to find the correct array name — it may be `queues` or inline in worker.ts.

**In `src/worker.ts`:**

Read the file first. Make 3 targeted additions:

1. **Import** (add alongside other processor imports at top):
```typescript
import { processUrteileSyncJob } from "@/lib/queue/processors/urteile-sync.processor";
```

2. **Import** `registerUrteileSyncJob` and `urteileSyncQueue` from queues.ts (add to existing import line from `@/lib/queue/queues`).

3. **Worker registration** (add immediately after gesetzeSyncWorker block, before `workers.push(gesetzeSyncWorker)`'s closing section):
```typescript
const urteileSyncWorker = new Worker("urteile-sync", processUrteileSyncJob, {
  connection: getQueueConnection(),
  concurrency: 1,
});
urteileSyncWorker.on("completed", (job) => {
  log.info({ jobId: job.id }, "[Worker] urteile-sync job completed");
});
urteileSyncWorker.on("failed", (job, err) => {
  log.error({ jobId: job?.id, err }, "[Worker] urteile-sync job failed");
});
urteileSyncWorker.on("error", (err) => {
  log.error({ err }, "[Worker] urteile-sync worker error");
});
workers.push(urteileSyncWorker);
log.info("[Worker] urteile-sync processor registered");
```

4. **Startup cron registration** — add `await registerUrteileSyncJob();` immediately after the existing `await registerGesetzeSyncJob();` call in the startup sequence (around line 720).

5. **Graceful shutdown** — add `"urteile-sync"` to the queue name list used in shutdown (same line/array as `"gesetze-sync"`). Read the file to find the exact location — it's around line 782.

**Do NOT change anything else in worker.ts.** Only add the 5 targeted insertions above.
  </action>
  <verify>
    <automated>cd /Users/patrickbaumfalk/Projekte/AI-Lawyer && npx tsc --noEmit 2>&1 | head -30</automated>
  </verify>
  <done>
    - urteileSyncQueue exported from queues.ts
    - registerUrteileSyncJob exported from queues.ts
    - urteile-sync Worker registered in worker.ts with completed/failed/error handlers
    - registerUrteileSyncJob() called in worker startup sequence
    - "urteile-sync" in graceful shutdown queue list
    - npx tsc --noEmit exits 0 (zero errors)
  </done>
</task>

</tasks>

<verification>
After both tasks:
1. `npx tsc --noEmit` exits 0
2. `grep "urteile-sync" src/worker.ts` shows Worker registration AND startup cron call AND shutdown list
3. `grep "registerUrteileSyncJob\|urteileSyncQueue" src/lib/queue/queues.ts` shows both exports
4. `grep "pii_rejected" src/lib/queue/processors/urteile-sync.processor.ts` confirms PII-rejected GUIDs ARE cached (no re-retry)
5. `grep '"error"' src/lib/queue/processors/urteile-sync.processor.ts` confirms error GUIDs are NOT cached (retry enabled)
</verification>

<success_criteria>
- processUrteileSyncJob() orchestrates all 7 BMJ RSS feeds with per-court error isolation
- urteileSyncQueue + registerUrteileSyncJob() wired in queues.ts (daily 03:00 Europe/Berlin)
- urteile-sync Worker registered in worker.ts — appears in workers[] array and graceful shutdown list
- TypeScript compiles clean across all modified files
- Plan 03 (ki-chat Chain E) can proceed in parallel — it only needs Plan 01 exports, not Plan 02
</success_criteria>

<output>
After completion, create `.planning/phases/17-urteile-rag/17-02-SUMMARY.md`
</output>
