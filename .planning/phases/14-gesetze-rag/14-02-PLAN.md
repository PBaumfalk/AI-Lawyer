---
phase: 14-gesetze-rag
plan: "02"
type: execute
wave: 2
depends_on: ["14-01"]
files_modified:
  - src/lib/queue/processors/gesetze-sync.processor.ts
  - src/lib/queue/queues.ts
  - src/worker.ts
autonomous: true
requirements: [GESETZ-02]

must_haves:
  truths:
    - "gesetze-sync queue exists and worker processes jobs from it"
    - "registerGesetzeSyncJob() schedules a cron at 02:00 Europe/Berlin via upsertJobScheduler"
    - "On cron trigger: GitHub tree is fetched, unchanged files are skipped via SHA comparison, changed files are parsed + ingested"
    - "Encoding smoke test prevents ingestion of files where § appears as 'Â§'"
    - "SHA cache is persisted to SystemSetting after each sync so the next cron run skips already-processed files"
    - "startup() in worker.ts calls registerGesetzeSyncJob() and the gesetze-sync Worker is registered"
  artifacts:
    - path: "src/lib/queue/processors/gesetze-sync.processor.ts"
      provides: "Full sync logic — processGesetzeSyncJob() orchestrates GitHub fetch + parse + ingest + SHA cache"
      exports: ["processGesetzeSyncJob"]
    - path: "src/lib/queue/queues.ts"
      provides: "gesetzeSyncQueue + registerGesetzeSyncJob() added"
      contains: "gesetzeSyncQueue"
    - path: "src/worker.ts"
      provides: "gesetze-sync Worker registered, registerGesetzeSyncJob() called in startup()"
      contains: "gesetze-sync"
  key_links:
    - from: "src/worker.ts startup()"
      to: "gesetzeSyncQueue.upsertJobScheduler"
      via: "registerGesetzeSyncJob()"
      pattern: "registerGesetzeSyncJob"
    - from: "src/lib/queue/processors/gesetze-sync.processor.ts"
      to: "src/lib/gesetze/ingestion.ts"
      via: "upsertLawChunks + loadShaCache + saveShaCache"
      pattern: "upsertLawChunks"
    - from: "src/lib/queue/processors/gesetze-sync.processor.ts"
      to: "src/lib/gesetze/github-client.ts"
      via: "fetchAllGesetzeFiles + fetchRawFileContent"
      pattern: "fetchAllGesetzeFiles"
---

<objective>
Build the BullMQ gesetze-sync cron processor and wire it into the queue system and worker.

Purpose: GESETZ-02 requires daily automatic sync at 02:00 Europe/Berlin with SHA-based incremental change detection and encoding smoke test. This plan implements the full cron logic and registers it in the existing BullMQ worker infrastructure.

Output:
- src/lib/queue/processors/gesetze-sync.processor.ts — processGesetzeSyncJob() with full sync loop
- src/lib/queue/queues.ts — gesetzeSyncQueue + registerGesetzeSyncJob() added
- src/worker.ts — gesetze-sync Worker instantiation + startup() registration
</objective>

<execution_context>
@/Users/patrickbaumfalk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/patrickbaumfalk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/14-gesetze-rag/14-RESEARCH.md
@.planning/phases/14-gesetze-rag/14-01-SUMMARY.md

<interfaces>
<!-- Key contracts the executor needs. Verified from codebase. -->

From src/lib/queue/queues.ts (existing pattern to follow):
```typescript
import { Queue, type JobsOptions } from "bullmq";
import { getQueueConnection } from "@/lib/queue/connection";

// Existing pattern for cron queues (attempts: 2 for cron jobs):
export const fristReminderQueue = new Queue("frist-reminder", {
  connection: getQueueConnection(),
  defaultJobOptions: {
    attempts: 3,
    backoff: { type: "custom" },
    removeOnComplete: { age: 86_400 },
    removeOnFail: { age: 604_800 },
  },
});

export async function registerFristReminderJob(cronPattern = "0 6 * * *"): Promise<void> {
  await fristReminderQueue.upsertJobScheduler(
    "frist-reminder-daily",
    { pattern: cronPattern, tz: "Europe/Berlin" },
    { name: "check-fristen", data: {}, opts: { removeOnComplete: { count: 100 }, removeOnFail: { count: 50 } } }
  );
}

// Must also add gesetzeSyncQueue to ALL_QUEUES array (for Bull Board auto-discovery)
export const ALL_QUEUES: Queue[] = [ /* existing queues */ ];
```

From src/worker.ts (existing Worker registration pattern):
```typescript
import { Worker } from "bullmq";
import { createRedisConnection } from "@/lib/redis";
import { calculateBackoff, registerFristReminderJob, /* ... */ } from "@/lib/queue/queues";

const connection = createRedisConnection({ maxRetriesPerRequest: null });
const workers: Worker[] = [];

const fristReminderWorker = new Worker(
  "frist-reminder",
  async () => processFristReminders(),
  { connection, concurrency: 1, settings: { backoffStrategy: (n) => calculateBackoff(n) } }
);
fristReminderWorker.on("completed", ...);
fristReminderWorker.on("failed", ...);
fristReminderWorker.on("error", ...);
workers.push(fristReminderWorker);

// In startup():
async function startup() {
  await registerFristReminderJob(cronPattern);
  // ... other registrations
}
```

From src/lib/gesetze/ (created in Plan 01):
```typescript
// github-client.ts
export interface GitTreeItem { path: string; type: string; sha: string; }
export async function fetchAllGesetzeFiles(): Promise<GitTreeItem[]>;
export async function fetchRawFileContent(path: string): Promise<string>;

// markdown-parser.ts
export interface LawParagraph { gesetzKuerzel, paragraphNr, titel, inhalt, stand, slug }
export function encodingSmokePassed(content: string, slug: string): boolean;
export function parseGesetzeMarkdown(markdown: string, fallbackSlug: string): LawParagraph[];

// ingestion.ts
export async function upsertLawChunks(paragraphs: LawParagraph[], modelVersion?: string): Promise<{ inserted: number; skipped: number }>;
export async function loadShaCache(): Promise<Record<string, string>>;
export async function saveShaCache(cache: Record<string, string>): Promise<void>;
```

From src/lib/logger.ts (existing pattern):
```typescript
import { createLogger } from "@/lib/logger";
const log = createLogger("gesetze-sync-processor");
log.info({ count }, "message");
log.warn({ path, err }, "warning message");
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: gesetze-sync processor + queue registration</name>
  <files>
    src/lib/queue/processors/gesetze-sync.processor.ts
    src/lib/queue/queues.ts
  </files>
  <action>
Create `src/lib/queue/processors/gesetze-sync.processor.ts`:

```typescript
/**
 * BullMQ processor for daily Gesetze sync from bundestag/gesetze GitHub repo.
 *
 * Flow:
 * 1. Load SHA cache from SystemSetting (track which files were last processed)
 * 2. Fetch all file paths+SHAs from GitHub git trees API (one request)
 * 3. For each index.md: skip if SHA unchanged, otherwise:
 *    a. Fetch raw Markdown content
 *    b. Encoding smoke test (reject if § appears as "Â§")
 *    c. Parse Markdown into LawParagraph[]
 *    d. Upsert law_chunks (delete + re-insert with fresh embedding)
 *    e. Update SHA cache entry
 * 4. Persist SHA cache to SystemSetting (save only at end or per-Gesetz)
 */

import { createLogger } from "@/lib/logger";
import { fetchAllGesetzeFiles, fetchRawFileContent } from "@/lib/gesetze/github-client";
import { encodingSmokePassed, parseGesetzeMarkdown } from "@/lib/gesetze/markdown-parser";
import { upsertLawChunks, loadShaCache, saveShaCache } from "@/lib/gesetze/ingestion";

const log = createLogger("gesetze-sync-processor");

export interface GesetzeSyncResult {
  processed: number;
  skipped: number;
  failed: number;
}

/**
 * Main processor for the gesetze-sync BullMQ job.
 * Called by the gesetze-sync Worker in src/worker.ts.
 * No job data required — runs as cron sweep.
 */
export async function processGesetzeSyncJob(): Promise<GesetzeSyncResult> {
  log.info("Starting Gesetze sync from bundestag/gesetze");

  // 1. Load SHA cache (empty on first run)
  const shaCache = await loadShaCache();

  // 2. Fetch all file paths + SHAs from GitHub (one API request)
  let allFiles;
  try {
    allFiles = await fetchAllGesetzeFiles();
    log.info({ total: allFiles.length }, "GitHub tree fetched");
  } catch (err) {
    log.error({ err }, "Failed to fetch GitHub tree — aborting sync");
    throw err; // Let BullMQ retry (attempts: 2)
  }

  let processed = 0;
  let skipped = 0;
  let failed = 0;

  for (const file of allFiles) {
    // 3. Skip unchanged files (SHA comparison)
    if (shaCache[file.path] === file.sha) {
      skipped++;
      continue;
    }

    // Extract slug from path format: {letter}/{slug}/index.md
    const pathParts = file.path.split("/");
    const slug = pathParts[1];

    try {
      // 4a. Fetch raw Markdown
      const content = await fetchRawFileContent(file.path);

      // 4b. Encoding smoke test — skip files with mojibake §
      if (!encodingSmokePassed(content, slug)) {
        failed++;
        continue;
      }

      // 4c. Parse Markdown into paragraphs
      const paragraphs = parseGesetzeMarkdown(content, slug);
      if (paragraphs.length === 0) {
        log.warn({ path: file.path }, "No paragraphs parsed — skipping (no ##### § headings found)");
        failed++;
        continue;
      }

      // 4d. Upsert law_chunks (delete existing + insert with fresh embedding)
      const { inserted, skipped: chunkSkipped } = await upsertLawChunks(paragraphs);

      // 4e. Update SHA cache entry for this file
      shaCache[file.path] = file.sha;
      processed++;

      log.info(
        { slug, inserted, chunkSkipped, paragraphsFound: paragraphs.length },
        "Gesetz synced"
      );
    } catch (err) {
      log.warn({ path: file.path, slug, err }, "Failed to sync Gesetz (non-fatal, continuing with next)");
      failed++;
      // Do NOT update shaCache[file.path] — will retry on next cron run
    }
  }

  // 5. Persist updated SHA cache (batch save at end — avoids N Settings writes)
  try {
    await saveShaCache(shaCache);
  } catch (err) {
    log.error({ err }, "Failed to persist SHA cache — progress may be lost");
    // Non-fatal: files will be re-processed on next run (idempotent)
  }

  log.info({ processed, skipped, failed }, "Gesetze sync completed");
  return { processed, skipped, failed };
}
```

Modify `src/lib/queue/queues.ts` — add gesetze-sync queue and scheduler at end of file, before the closing:

ADD after aiProactiveQueue definition (before ALL_QUEUES):
```typescript
/** Gesetze-sync queue for daily bundestag/gesetze ingestion cron */
export const gesetzeSyncQueue = new Queue("gesetze-sync", {
  connection: getQueueConnection(),
  defaultJobOptions: {
    attempts: 2,
    backoff: { type: "custom" },
    removeOnComplete: { age: 86_400 },   // 24h
    removeOnFail: { age: 604_800 },      // 7 days
  },
});
```

ADD gesetzeSyncQueue to ALL_QUEUES array:
```typescript
export const ALL_QUEUES: Queue[] = [
  testQueue,
  fristReminderQueue,
  emailSendQueue,
  emailSyncQueue,
  ocrQueue,
  embeddingQueue,
  previewQueue,
  aiScanQueue,
  aiBriefingQueue,
  aiProactiveQueue,
  gesetzeSyncQueue,  // ADD THIS
];
```

ADD registerGesetzeSyncJob function at end of file:
```typescript
/**
 * Register the daily Gesetze sync cron job.
 * Uses upsertJobScheduler for idempotent (re)registration.
 *
 * @param cronPattern - Cron expression (default: "0 2 * * *" = 02:00 daily)
 */
export async function registerGesetzeSyncJob(
  cronPattern = "0 2 * * *"
): Promise<void> {
  await gesetzeSyncQueue.upsertJobScheduler(
    "gesetze-sync-daily",
    {
      pattern: cronPattern,
      tz: "Europe/Berlin",
    },
    {
      name: "sync-gesetze",
      data: {},
      opts: {
        removeOnComplete: { count: 10 },
        removeOnFail: { count: 20 },
      },
    }
  );
}
```
  </action>
  <verify>npx tsc --noEmit 2>&1 | grep -E "gesetze-sync|queues" | head -20; echo "TypeScript check done"</verify>
  <done>gesetze-sync.processor.ts compiles without errors. queues.ts has gesetzeSyncQueue in ALL_QUEUES and exports registerGesetzeSyncJob. processGesetzeSyncJob is exported from processor.</done>
</task>

<task type="auto">
  <name>Task 2: Wire gesetze-sync Worker into worker.ts</name>
  <files>
    src/worker.ts
  </files>
  <action>
Modify `src/worker.ts` to add the gesetze-sync Worker.

ADD to imports at top of file:
```typescript
import { calculateBackoff, registerFristReminderJob, registerAiProactiveJob, registerAiBriefingJob, registerGesetzeSyncJob, ocrQueue, gesetzeSyncQueue } from "@/lib/queue/queues";
import { processGesetzeSyncJob } from "@/lib/queue/processors/gesetze-sync.processor";
```

ADD the Worker definition after the aiProactiveWorker section (before gracefulShutdown), following the exact same pattern as other cron workers:
```typescript
// ─── Gesetze-Sync Queue Worker ──────────────────────────────────────────────

const gesetzeSyncWorker = new Worker(
  "gesetze-sync",
  async () => processGesetzeSyncJob(),
  {
    connection,
    concurrency: 1, // Sequential sync — avoids GitHub rate limit pressure and Ollama contention
    settings: {
      backoffStrategy: (attemptsMade: number) => calculateBackoff(attemptsMade),
    },
  }
);

gesetzeSyncWorker.on("completed", (job) => {
  if (!job) return;
  log.info(
    { jobId: job.id, result: job.returnvalue },
    "Gesetze sync completed"
  );
});

gesetzeSyncWorker.on("failed", (job, err) => {
  if (!job) return;
  log.error(
    { jobId: job.id, err: err.message, attemptsMade: job.attemptsMade },
    "Gesetze sync failed"
  );

  if (job.attemptsMade >= (job.opts.attempts ?? 2)) {
    socketEmitter.to("role:ADMIN").emit("notification", {
      type: "job:failed",
      title: "Gesetze-Sync fehlgeschlagen",
      message: `Täglicher Gesetze-Sync fehlgeschlagen: ${err.message}`,
      data: { jobId: job.id, queue: "gesetze-sync" },
    });
  }
});

gesetzeSyncWorker.on("error", (err) => {
  log.error({ err }, "Gesetze sync worker error");
});

workers.push(gesetzeSyncWorker);
log.info("[Worker] gesetze-sync processor registered");
```

ADD to startup() function (after the AI jobs try/catch block, before the IMAP startImapConnections call):
```typescript
// Register daily Gesetze sync cron job
try {
  await registerGesetzeSyncJob();
  log.info("Gesetze sync job registered (02:00 Europe/Berlin daily)");
} catch (err) {
  log.warn({ err }, "Failed to register Gesetze sync job (non-fatal)");
}
```

UPDATE the log.info at the end of startup() to include "gesetze-sync" in the queues array:
```typescript
queues: [
  "test", "frist-reminder", "email-send", "email-sync",
  "document-ocr", "document-preview", "document-embedding",
  "ai-scan", "ai-briefing", "ai-proactive", "gesetze-sync",
],
```

Also update the import line — replace the existing import from queues to add registerGesetzeSyncJob and gesetzeSyncQueue. The existing import line is:
```typescript
import { calculateBackoff, registerFristReminderJob, registerAiProactiveJob, registerAiBriefingJob, ocrQueue } from "@/lib/queue/queues";
```
Replace with:
```typescript
import { calculateBackoff, registerFristReminderJob, registerAiProactiveJob, registerAiBriefingJob, registerGesetzeSyncJob, ocrQueue } from "@/lib/queue/queues";
```
(gesetzeSyncQueue is not needed as a direct import in worker.ts — the Worker constructor takes the queue name string "gesetze-sync" directly)
  </action>
  <verify>npx tsc --noEmit 2>&1 | grep "worker.ts" | head -20; echo "TypeScript check done"</verify>
  <done>worker.ts compiles without errors. gesetzeSyncWorker is instantiated with concurrency:1 and registered via workers.push(). startup() calls registerGesetzeSyncJob(). The gesetze-sync queue name appears in the startup log.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit 2>&1 | grep -E "gesetze|queues|worker" | head -30` — zero TypeScript errors
- `grep -n "gesetze-sync" src/worker.ts` — shows Worker instantiation + startup registration
- `grep -n "gesetzeSyncQueue\|registerGesetzeSyncJob" src/lib/queue/queues.ts` — shows queue + function
- `grep -n "ALL_QUEUES" src/lib/queue/queues.ts` — gesetzeSyncQueue present in array
</verification>

<success_criteria>
Daily cron is wired end-to-end: startup() calls registerGesetzeSyncJob(), Worker processes jobs from "gesetze-sync" queue, processGesetzeSyncJob() runs the full sync loop with SHA-based incremental detection and encoding smoke test. Zero TypeScript errors. First manual trigger via Bull Board would ingest all 2000+ Gesetze (empty SHA cache on first run).
</success_criteria>

<output>
After completion, create `.planning/phases/14-gesetze-rag/14-02-SUMMARY.md` following the summary template.
</output>
