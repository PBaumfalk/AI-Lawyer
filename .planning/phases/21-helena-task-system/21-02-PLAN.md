---
phase: 21-helena-task-system
plan: 02
type: execute
wave: 2
depends_on: ["21-01"]
files_modified:
  - src/app/api/helena/tasks/route.ts
  - src/app/api/helena/tasks/[id]/route.ts
  - src/worker.ts
autonomous: true
requirements: [TASK-01, TASK-05, AGNT-07]

must_haves:
  truths:
    - "POST /api/helena/tasks creates a HelenaTask and enqueues a BullMQ job"
    - "GET /api/helena/tasks returns paginated task list filterable by status, akteId, and source"
    - "GET /api/helena/tasks/[id] returns full task detail including steps trace"
    - "PATCH /api/helena/tasks/[id] with action=abort sets status to ABGEBROCHEN and signals the in-process AbortController"
    - "helena-task BullMQ worker registered in worker.ts with lockDuration: 120_000 and concurrency: 1"
    - "Worker startup recovers stuck RUNNING HelenaTask records by marking them FAILED"
    - "User can only abort their own tasks (RBAC enforcement)"
  artifacts:
    - path: "src/app/api/helena/tasks/route.ts"
      provides: "POST (create task) and GET (list tasks) endpoints"
      exports: ["POST", "GET"]
    - path: "src/app/api/helena/tasks/[id]/route.ts"
      provides: "GET (task detail) and PATCH (abort) endpoints"
      exports: ["GET", "PATCH"]
    - path: "src/worker.ts"
      provides: "helena-task worker registration with lockDuration: 120_000"
      contains: "helenaTaskWorker"
  key_links:
    - from: "src/app/api/helena/tasks/route.ts"
      to: "src/lib/helena/task-service.ts"
      via: "createHelenaTask()"
      pattern: "createHelenaTask"
    - from: "src/app/api/helena/tasks/[id]/route.ts"
      to: "src/lib/queue/processors/helena-task.processor.ts"
      via: "abortTask()"
      pattern: "abortTask"
    - from: "src/worker.ts"
      to: "src/lib/queue/processors/helena-task.processor.ts"
      via: "processHelenaTask()"
      pattern: "processHelenaTask"
---

<objective>
Wire the Phase 21 infrastructure into production: REST API routes for task creation/listing/detail/abort, helena-task BullMQ worker registration with lockDuration: 120_000, and startup recovery for stuck tasks.

Purpose: Users can create Helena tasks via API (consumed by @Helena UI in Phase 26), view task status and traces, abort running tasks, and the worker process executes tasks with anti-stall protection.

Output: 2 API route files and updated worker.ts. Completes the full @Helena task-system backend.
</objective>

<execution_context>
@/Users/patrickbaumfalk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/patrickbaumfalk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-helena-task-system/21-RESEARCH.md
@.planning/phases/21-helena-task-system/21-01-SUMMARY.md

<interfaces>
<!-- Key types from Plan 01 that this plan consumes -->

From src/lib/helena/task-service.ts (created in Plan 01):
```typescript
export interface CreateTaskOptions {
  userId: string;
  userRole: string;
  userName: string;
  akteId: string;
  auftrag: string;
  prioritaet?: number;
  quelle?: string;
}
export async function createHelenaTask(options: CreateTaskOptions): Promise<HelenaTask>;
```

From src/lib/helena/at-mention-parser.ts (created in Plan 01):
```typescript
export function parseHelenaMention(text: string): string | null;
export function hasHelenaMention(text: string): boolean;
```

From src/lib/queue/processors/helena-task.processor.ts (created in Plan 01):
```typescript
export interface HelenaTaskJobData {
  taskId: string;
  userId: string;
  userRole: string;
  userName: string;
  akteId: string;
  auftrag: string;
  prioritaet: number;
}
export async function processHelenaTask(job: Job<HelenaTaskJobData>): Promise<void>;
export function abortTask(taskId: string): boolean;
export function getActiveTaskIds(): string[];
```

From src/lib/queue/queues.ts (modified in Plan 01):
```typescript
export const helenaTaskQueue: Queue;
```

From src/worker.ts (existing pattern):
```typescript
import { Worker } from "bullmq";
const connection = getWorkerConnection();
const workers: Worker[] = [];
// Each worker: new Worker(queueName, processor, { connection, concurrency, ... })
// workers.push(worker); log.info("[Worker] name registered");
// startup() function runs recovery, cron registration
```

From src/lib/auth (existing pattern):
```typescript
import { auth } from "@/lib/auth";
// session = await auth(); session.user.id, session.user.role, session.user.name
```

Existing queue backoff helper:
```typescript
import { calculateBackoff } from "@/lib/queue/queues";
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Helena task API routes (create, list, detail, abort)</name>
  <files>
    src/app/api/helena/tasks/route.ts
    src/app/api/helena/tasks/[id]/route.ts
  </files>
  <action>
**1. Create `src/app/api/helena/tasks/route.ts` (POST + GET):**

Imports: `NextRequest` from `next/server`, `auth` from `@/lib/auth`, `prisma` from `@/lib/db`, `createHelenaTask` from `@/lib/helena/task-service`, `parseHelenaMention` from `@/lib/helena/at-mention-parser`, `z` from `zod`.

**POST handler** -- creates a new Helena task:

a. Auth check: `const session = await auth()`. If no session or no `session.user?.id`, return 401.
b. RBAC check: Only ADMIN, ANWALT, SACHBEARBEITER, SEKRETARIAT can use @Helena (per CONTEXT.md decision). If role is PRAKTIKANT, return 403 with `{ error: "Keine Berechtigung fuer Helena-Tasks" }`.
c. Parse request body with Zod schema:
   ```typescript
   const schema = z.object({
     akteId: z.string().min(1),
     auftrag: z.string().min(1).max(5000),
     prioritaet: z.number().int().min(1).max(10).optional(),
     quelle: z.enum(["at-mention", "manual", "scanner", "chat"]).optional(),
   });
   ```
d. Validate body. On validation error, return 400 with `{ error: "Ungueltige Eingabe", details: error.errors }`.
e. Verify the user has access to the Akte: `await prisma.akte.findFirst({ where: { id: akteId, ...buildAccessFilter(session.user) } })`. If not found, return 404 with `{ error: "Akte nicht gefunden" }`. Use the existing Akte access filter pattern from `@/lib/rbac` if available, otherwise a simple `findFirst` with `id` check.
f. Call `createHelenaTask()` with session user data and request body.
g. Return 201 with `{ task }`.

**GET handler** -- lists tasks for the current user:

a. Auth check (same as POST).
b. Parse query params: `status` (optional HelenaTaskStatus), `akteId` (optional string), `quelle` (optional), `page` (default 1), `pageSize` (default 20, max 100).
c. Build Prisma `where` clause:
   - Always filter by `userId: session.user.id` (users see their own tasks; ADMIN sees all)
   - If ADMIN role, skip userId filter
   - Add optional filters for `status`, `akteId`
d. Query with pagination: `prisma.helenaTask.findMany({ where, orderBy: { createdAt: "desc" }, skip, take, include: { akte: { select: { id: true, aktenzeichen: true, rubrum: true } } } })`
e. Get total count: `prisma.helenaTask.count({ where })`
f. Return 200 with `{ tasks, total, page, pageSize }`.

**2. Create `src/app/api/helena/tasks/[id]/route.ts` (GET + PATCH):**

Imports: `NextRequest` from `next/server`, `auth` from `@/lib/auth`, `prisma` from `@/lib/db`, `abortTask` from `@/lib/queue/processors/helena-task.processor`, `z` from `zod`.

**GET handler** -- returns full task detail including steps trace:

a. Auth check.
b. Fetch task: `prisma.helenaTask.findUnique({ where: { id: params.id }, include: { akte: { select: { id: true, aktenzeichen: true, rubrum: true } }, user: { select: { id: true, name: true } }, drafts: { select: { id: true, typ: true, status: true, titel: true, createdAt: true } } } })`
c. If not found, return 404.
d. Ownership check: task.userId must equal session.user.id (or ADMIN role). Return 403 if not.
e. Return 200 with `{ task }`.

**PATCH handler** -- abort a running task:

a. Auth check.
b. Parse body with schema: `z.object({ action: z.literal("abort") })`. Return 400 on invalid action.
c. Fetch task: `prisma.helenaTask.findUnique({ where: { id: params.id } })`. Return 404 if not found.
d. Ownership check (same as GET). Return 403 if not owner and not ADMIN.
e. Status check: only PENDING or RUNNING tasks can be aborted. If task.status is not PENDING/RUNNING, return 409 with `{ error: "Task kann nicht abgebrochen werden", status: task.status }`.
f. Update task status: `prisma.helenaTask.update({ where: { id: params.id }, data: { status: "ABGEBROCHEN", completedAt: new Date() } })`
g. Signal in-process abort: `const aborted = abortTask(params.id)` (from processor module). This returns false if the task already completed or the worker restarted (AbortController no longer in Map).
h. Return 200 with `{ success: true, abortedInProcess: aborted }`.

**Route segment config:** For the `[id]` route, use the Next.js App Router params pattern. Extract `id` from `{ params }` arg. Use `Promise<{ id: string }>` type for params per Next.js 14+ convention:
```typescript
export async function GET(
  req: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  const { id } = await params;
  // ...
}
```
  </action>
  <verify>
    <automated>npx tsc --noEmit src/app/api/helena/tasks/route.ts src/app/api/helena/tasks/\[id\]/route.ts 2>&1 | head -20</automated>
  </verify>
  <done>
    - POST /api/helena/tasks validates input with Zod, checks RBAC (no PRAKTIKANT), creates task via task-service
    - GET /api/helena/tasks returns paginated list with status/akteId filters, users see own tasks, ADMIN sees all
    - GET /api/helena/tasks/[id] returns full task with steps trace, drafts, and Akte info
    - PATCH /api/helena/tasks/[id] with action=abort changes status to ABGEBROCHEN and signals AbortController
    - Ownership enforced: users can only abort their own tasks (or ADMIN)
    - Only PENDING/RUNNING tasks can be aborted (409 for other statuses)
  </done>
</task>

<task type="auto">
  <name>Task 2: Register helena-task worker with lockDuration and startup recovery</name>
  <files>src/worker.ts</files>
  <action>
**1. Add helena-task worker registration to `src/worker.ts`:**

Add import at top of file (with other processor imports):
```typescript
import { processHelenaTask, type HelenaTaskJobData } from "@/lib/queue/processors/helena-task.processor";
```

Add worker registration after the last existing worker block (muster-ingestion) and before the `gracefulShutdown` function. Follow the exact pattern of existing workers:

```typescript
// --- Helena-Task Queue Worker -----------------------------------------------

const helenaTaskWorker = new Worker<HelenaTaskJobData>(
  "helena-task",
  async (job) => processHelenaTask(job),
  {
    connection,
    concurrency: 1,         // Sequential: avoid Ollama GPU contention
    lockDuration: 120_000,  // 2min lock -- LLM calls take 30-120s per step
    settings: {
      backoffStrategy: (attemptsMade: number) => calculateBackoff(attemptsMade),
    },
  }
);

helenaTaskWorker.on("completed", (job) => {
  if (!job) return;
  log.info(
    { jobId: job.id, taskId: job.data.taskId },
    "[Worker] helena-task job completed"
  );
});

helenaTaskWorker.on("failed", (job, err) => {
  if (!job) return;
  log.error(
    { jobId: job.id, taskId: job.data.taskId, err: err.message },
    "[Worker] helena-task job failed"
  );
});

helenaTaskWorker.on("error", (err) => {
  log.error({ err }, "[Worker] helena-task worker error");
});

workers.push(helenaTaskWorker);
log.info("[Worker] helena-task processor registered");
```

Key decisions:
- `concurrency: 1` -- sequential execution avoids Ollama GPU contention (per research recommendation, starting conservative; Phase 24 scanner tasks will also use this queue indirectly)
- `lockDuration: 120_000` -- 2 minutes, combined with `job.updateProgress()` in the processor's onStepUpdate callback, prevents BullMQ from marking long-running LLM calls as stalled (AGNT-07)
- `attempts: 1` already set on queue defaultJobOptions (Plan 01), no override needed on Worker

**2. Add startup recovery for stuck Helena tasks:**

In the `startup()` function, after the existing `recoverStuckNerJobs()` block and before `processMusterIngestPending()`, add:

```typescript
// Recover any HelenaTask stuck in RUNNING from a previous crashed worker
try {
  const stuckTasks = await prisma.helenaTask.updateMany({
    where: { status: "RUNNING" },
    data: {
      status: "FAILED",
      fehler: "Worker wurde neu gestartet â€” Task war noch in Bearbeitung",
      completedAt: new Date(),
    },
  });
  if (stuckTasks.count > 0) {
    log.info(
      { count: stuckTasks.count },
      "Recovered stuck Helena tasks from previous worker crash"
    );
  }
} catch (err) {
  log.warn({ err }, "Failed to recover stuck Helena tasks (non-fatal)");
}
```

This follows the exact same recovery pattern as `recoverStuckNerJobs()` -- on worker startup, find any records stuck in a running state from a previous crashed worker instance and mark them as failed with an explanatory German message.

**Do NOT:**
- Set concurrency > 1 (Ollama GPU contention risk)
- Skip the startup recovery (orphaned RUNNING tasks would be stuck forever)
- Add lockDuration to the queue definition (it belongs on the Worker, per BullMQ v5 docs)
  </action>
  <verify>
    <automated>npx tsc --noEmit src/worker.ts 2>&1 | head -20</automated>
  </verify>
  <done>
    - helena-task worker registered with concurrency: 1 and lockDuration: 120_000
    - Worker follows existing pattern (completed/failed/error handlers, pushed to workers array, log.info registration)
    - Startup recovery marks any RUNNING HelenaTask records as FAILED with German error message
    - Worker is part of graceful shutdown via workers array
    - calculateBackoff used for backoff strategy (consistent with other workers)
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` compiles all modified/created files without errors
2. POST /api/helena/tasks accepts `{ akteId, auftrag, prioritaet?, quelle? }` and returns 201
3. PATCH /api/helena/tasks/[id] with `{ action: "abort" }` returns 200 with `{ success: true }`
4. worker.ts imports and registers helena-task processor
5. worker.ts startup() recovers stuck RUNNING HelenaTask records
6. No new npm packages needed
</verification>

<success_criteria>
- Complete REST API for Helena tasks: create, list, detail, abort
- RBAC enforced: PRAKTIKANT excluded, users see own tasks, ADMIN sees all
- Abort flow: DB status update + in-process AbortController signal
- Worker registered with lockDuration: 120_000 for anti-stall protection
- Startup recovery prevents orphaned RUNNING tasks after worker crash
- All files compile with TypeScript
</success_criteria>

<output>
After completion, create `.planning/phases/21-helena-task-system/21-02-SUMMARY.md`
</output>
