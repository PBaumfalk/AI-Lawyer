---
phase: 02.1-wire-frist-reminder-pipeline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/queue/queues.ts
  - src/lib/queues.ts
  - src/worker.ts
  - src/lib/email/send.ts
  - src/lib/settings/defaults.ts
  - src/workers/processors/frist-reminder.ts
  - .env.example
autonomous: true
requirements:
  - REQ-FK-003
user_setup:
  - service: SMTP
    why: "Email delivery for Frist reminders (dual-channel: in-app + email)"
    env_vars:
      - name: SMTP_HOST
        source: "Your email provider (e.g. smtp.gmail.com, smtp.office365.com, or self-hosted)"
      - name: SMTP_PORT
        source: "Usually 587 (STARTTLS) or 465 (SSL)"
      - name: SMTP_USER
        source: "Email account username/address"
      - name: SMTP_PASS
        source: "Email account password or app-specific password"
      - name: SMTP_FROM
        source: "Sender address for outgoing reminder emails (e.g. noreply@kanzlei.de)"
    dashboard_config: []

must_haves:
  truths:
    - "processFristReminders() is registered as a BullMQ Worker in src/worker.ts for the frist-reminder queue"
    - "registerFristReminderJob() is called at worker startup, scheduling the repeatable cron job at 06:00 Europe/Berlin daily"
    - "The frist-reminder queue appears in ALL_QUEUES and is visible in the admin Bull Board monitor"
    - "initializeDefaults() is called at worker startup so fresh installs have default settings"
    - "A Frist with Vorfrist matching today triggers both an in-app notification AND an email to the Verantwortlicher"
    - "Weekend/holiday vorfrist dates are shifted to the preceding Friday for notification sending"
    - "Duplicate reminders for the same Vorfrist+KalenderEintrag on the same day are not sent twice"
    - "Catch-up scan sends reminders missed during downtime (up to 3 days old for email)"
    - "Scan time is configurable via SystemSettings fristen_scan_zeit"
  artifacts:
    - path: "src/lib/queue/queues.ts"
      provides: "Consolidated queue registry with ALL_QUEUES including frist-reminder"
      contains: "fristReminderQueue"
    - path: "src/lib/email/send.ts"
      provides: "Nodemailer SMTP transport wrapper"
      exports: ["sendEmail"]
    - path: "src/worker.ts"
      provides: "Worker entry point with frist-reminder processor registered"
      contains: "fristReminderWorker"
    - path: "src/workers/processors/frist-reminder.ts"
      provides: "Enhanced processor with deduplication, dual-channel delivery, weekend shift, catch-up"
      exports: ["processFristReminders"]
    - path: "src/lib/settings/defaults.ts"
      provides: "Default settings including fristen_scan_zeit"
      contains: "fristen_scan_zeit"
  key_links:
    - from: "src/worker.ts"
      to: "src/workers/processors/frist-reminder.ts"
      via: "BullMQ Worker registration importing processFristReminders"
      pattern: "import.*processFristReminders.*frist-reminder"
    - from: "src/worker.ts"
      to: "src/lib/queue/queues.ts"
      via: "Calls registerFristReminderJob() at startup"
      pattern: "registerFristReminderJob"
    - from: "src/worker.ts"
      to: "src/lib/settings/service.ts"
      via: "Calls initializeDefaults() at startup"
      pattern: "initializeDefaults"
    - from: "src/workers/processors/frist-reminder.ts"
      to: "src/lib/email/send.ts"
      via: "Sends reminder emails after in-app notification"
      pattern: "sendEmail"
    - from: "src/lib/queue/queues.ts"
      to: "admin Bull Board"
      via: "ALL_QUEUES array includes fristReminderQueue"
      pattern: "ALL_QUEUES.*fristReminderQueue"
---

<objective>
Wire the existing frist-reminder processor into the live BullMQ worker runtime with dual-channel delivery (in-app + email), deduplication, weekend/holiday shift, catch-up after downtime, and admin-configurable scan time. Consolidate the dual queue registry files into a single source of truth. Initialize default settings at worker startup.

Purpose: REQ-FK-003 (Vorfristen-Erinnerungen) is currently unsat because the processor code exists but is never called at runtime. This plan connects all existing pieces and adds the email channel + deduplication required by user decisions.

Output: Working frist-reminder pipeline â€” cron schedules daily scan, processor checks all Fristen, sends in-app + email notifications with deduplication, handles weekends/holidays, catches up after downtime, and is visible in admin monitoring.
</objective>

<execution_context>
@/Users/patrickbaumfalk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/patrickbaumfalk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02.1-wire-frist-reminder-pipeline/02.1-CONTEXT.md
@.planning/phases/02.1-wire-frist-reminder-pipeline/02.1-RESEARCH.md
@src/worker.ts
@src/lib/queue/queues.ts
@src/lib/queues.ts
@src/workers/processors/frist-reminder.ts
@src/lib/settings/service.ts
@src/lib/settings/defaults.ts
@src/lib/notifications/service.ts
@src/lib/queue/connection.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Consolidate queue registry, add email transport, add settings defaults</name>
  <files>
    src/lib/queue/queues.ts
    src/lib/queues.ts
    src/lib/email/send.ts
    src/lib/settings/defaults.ts
    .env.example
  </files>
  <action>
**1. Consolidate queue registry (src/lib/queue/queues.ts):**
- Add `fristReminderQueue` to `src/lib/queue/queues.ts` following the exact same pattern as `testQueue`: `new Queue("frist-reminder", { connection: getQueueConnection(), defaultJobOptions })`
- Add `fristReminderQueue` to the `ALL_QUEUES` array: `[testQueue, fristReminderQueue]`
- Move `registerFristReminderJob()` function from `src/lib/queues.ts` into `src/lib/queue/queues.ts`. Update it to:
  - Use `fristReminderQueue` directly (not lazy getter)
  - Accept an optional `cronPattern` parameter (default `"0 6 * * *"`) so the worker can pass the admin-configured time
  - Always include `tz: "Europe/Berlin"` in the scheduler options
  - Use `upsertJobScheduler` with id `"frist-reminder-daily"`, name `"check-fristen"`, opts `{ removeOnComplete: { count: 100 }, removeOnFail: { count: 50 } }`
- Export `registerFristReminderJob` from `src/lib/queue/queues.ts`

**2. Gut old queue file (src/lib/queues.ts):**
- Replace the entire contents with a re-export file that imports from the canonical location:
  ```
  // DEPRECATED: Use src/lib/queue/queues.ts instead
  // This file exists only for backward compatibility during migration
  export { fristReminderQueue as getFristReminderQueue, registerFristReminderJob } from "@/lib/queue/queues";
  ```
  Note: `getFristReminderQueue` was a function returning a Queue; now it's a direct Queue export. Since no runtime code currently imports from this file (only the unregistered processor used it), this re-export is sufficient.

**3. Create email transport (src/lib/email/send.ts):**
- Create `src/lib/email/` directory and `send.ts` file
- Use nodemailer to create a reusable SMTP transporter:
  - `SMTP_HOST` (default "localhost"), `SMTP_PORT` (default 587), `SMTP_SECURE` (default "false"), `SMTP_USER`, `SMTP_PASS`
  - If `SMTP_USER` is not set, skip auth entirely (for local dev with Mailhog/MailPit)
  - `SMTP_FROM` env var for sender address (default "noreply@kanzlei.local")
- Export `async function sendEmail(opts: { to: string; subject: string; text: string; html?: string }): Promise<boolean>`:
  - Returns `true` on success, `false` on failure (does NOT throw -- callers handle independently)
  - Logs success/failure via createLogger("email")
  - If `SMTP_HOST` is not configured (empty string or "localhost" and no SMTP_USER), log a warning and return false (email not configured)
- Export `function isEmailConfigured(): boolean` -- checks if SMTP_HOST and SMTP_USER are set

**4. Add fristen settings to defaults (src/lib/settings/defaults.ts):**
- Add a new "fristen" category to `DEFAULT_SETTINGS` array:
  - `fristen.scan_zeit`: value `"06:00"`, type `"string"`, category `"fristen"`, label `"Fristen-Scan Uhrzeit (HH:MM)"`
  - `fristen.email_enabled`: value `"true"`, type `"boolean"`, category `"fristen"`, label `"E-Mail-Erinnerungen aktiviert"`
  - `fristen.max_retry_age_days`: value `"3"`, type `"number"`, category `"fristen"`, label `"Max. E-Mail-Nachversand (Tage)"`, min 1, max 14
- Add `"fristen": "Fristen"` to `CATEGORY_LABELS`

**5. Update .env.example:**
- Add SMTP section with `SMTP_HOST`, `SMTP_PORT`, `SMTP_SECURE`, `SMTP_USER`, `SMTP_PASS`, `SMTP_FROM` with explanatory comments

**Install nodemailer:**
Run `npm install nodemailer && npm install -D @types/nodemailer` before writing any code that imports it.
  </action>
  <verify>
    <automated>cd /Users/patrickbaumfalk/Projekte/AI-Lawyer && npx tsc --noEmit --pretty 2>&1 | head -30</automated>
    <manual>Check that src/lib/queue/queues.ts exports fristReminderQueue, ALL_QUEUES contains it, and registerFristReminderJob accepts optional cronPattern</manual>
  </verify>
  <done>
- fristReminderQueue exists in ALL_QUEUES in src/lib/queue/queues.ts
- registerFristReminderJob() is in src/lib/queue/queues.ts with tz: "Europe/Berlin" and configurable cron pattern
- src/lib/queues.ts is a thin re-export (no duplicate Queue instances)
- src/lib/email/send.ts exports sendEmail() and isEmailConfigured()
- DEFAULT_SETTINGS includes fristen.scan_zeit, fristen.email_enabled, fristen.max_retry_age_days
- nodemailer is installed in package.json
  </done>
</task>

<task type="auto">
  <name>Task 2: Enhance frist-reminder processor with deduplication, dual-channel, weekend shift, and catch-up</name>
  <files>
    src/workers/processors/frist-reminder.ts
  </files>
  <action>
Enhance the existing `processFristReminders()` in `src/workers/processors/frist-reminder.ts` with the following changes. Preserve ALL existing logic (isUserOnVacation, deactivateExpiredVertretungen, sendVorfristNotification, sendOverdueEscalation) and enhance it.

**1. Deduplication (CRITICAL -- per user decision, never send the same reminder twice):**
- Before sending any vorfrist/halbfrist notification, check if a Notification with:
  - `type: "frist:vorfrist"` (or `"frist:ueberfaellig"` for overdue)
  - `data.kalenderEintragId` matching the current eintrag.id
  - `data.daysUntil` matching the current daysUntil (for vorfrist) OR same overdue date (for overdue)
  - `createdAt` within the current calendar day (>= startOfDay, < endOfDay using date-fns)
  already exists in the Notification table. If it does, skip sending.
- Add a helper function `async function isReminderAlreadySent(kalenderEintragId: string, type: string, daysUntil?: number): Promise<boolean>` that queries `prisma.notification.findFirst()` with the above conditions.

**2. Weekend/Holiday shift for reminder dates:**
- Import `isSaturday`, `isSunday`, `previousFriday`, `isToday`, `isFriday` from `date-fns`
- Import `istFeiertag` from the existing holiday wrapper (`@/lib/fristen/feiertage` or wherever it exists)
- Create helper `function shouldFireToday(reminderDate: Date): boolean`:
  - If reminderDate is today -> true
  - If today is Friday AND reminderDate is Saturday or Sunday -> true (fire on preceding Friday)
  - If reminderDate falls on a Feiertag and the preceding business day is today -> true
  - Otherwise -> false
- Replace all `vfDay === todayStr` checks in the main loop with calls to `shouldFireToday(vfDate)`

**3. Dual-channel delivery (in-app + email):**
- Import `sendEmail`, `isEmailConfigured` from `@/lib/email/send`
- Import `getSettingTyped` from `@/lib/settings/service` to read `fristen.email_enabled` and `fristen.max_retry_age_days`
- In `sendVorfristNotification()`:
  - FIRST send in-app notification (existing createNotification call -- keep as is, this is fast and local)
  - THEN attempt email if `isEmailConfigured()` AND `fristen.email_enabled` is true:
    - Fetch the user's email address from the notification target userId (include `email` in the select when loading verantwortlicher)
    - Build email: subject = notification title, text = notification message, html = simple `<p>` wrapped message with Akte link placeholder
    - Call `sendEmail({ to: user.email, subject, text, html })` -- this returns boolean, no throw
    - On email failure, log warning but do NOT fail the overall job
  - Per user decision: "both primary user AND deputy receive the reminder when primary is on vacation" -- the existing code already sends to both when vacation is active, so email goes to BOTH users' email addresses
- In `sendOverdueEscalation()`: same pattern -- send in-app first, then email to each escalation recipient

**4. Catch-up after downtime:**
- Enhance the main date comparison to not just check "is this vorfrist today" but also "is this vorfrist in the past AND not yet notified":
  - For each vorfristDate that is in the past (before today), check if it was already sent via deduplication check
  - If not sent, send it now (catch-up)
  - Respect the `fristen.max_retry_age_days` setting: skip vorfrist dates older than N days for email channel (in-app always sends)
- For overdue: already catches all overdue fristen, but add deduplication check to avoid re-sending daily overdue notifications for the same frist within the same day

**5. Include Akte reference in notification content (per user decision):**
- When loading fristen in the main query, add `akte: { select: { aktenzeichen: true, rubrum: true } }` to the include
- Update notification message format to: `"Frist in {N} Tagen: {titel} -- Akte {aktenzeichen} {rubrum}"` (matching the user's example format)
- Update email subject to include Akte reference

**6. Update the verantwortlich select to include email field:**
- In the `prisma.kalenderEintrag.findMany()` include, add `email: true` to the verantwortlich select
- Also add `email: true` to the vertreter select
  </action>
  <verify>
    <automated>cd /Users/patrickbaumfalk/Projekte/AI-Lawyer && npx tsc --noEmit --pretty 2>&1 | head -30</automated>
    <manual>Review frist-reminder.ts for: deduplication check before every send, shouldFireToday with weekend/holiday logic, email after in-app in both sendVorfristNotification and sendOverdueEscalation, catch-up for past vorfrist dates</manual>
  </verify>
  <done>
- Deduplication prevents sending the same vorfrist/overdue reminder twice on the same day
- shouldFireToday() handles Saturday/Sunday shift to preceding Friday and Feiertag shift
- Both sendVorfristNotification() and sendOverdueEscalation() send in-app first, then email
- Catch-up sends unsent past reminders (limited by max_retry_age_days for email)
- Notification messages include Akte aktenzeichen and rubrum
- User email addresses are loaded for both verantwortlicher and vertreter
  </done>
</task>

<task type="auto">
  <name>Task 3: Register frist-reminder worker in worker.ts, wire startup init, handle settings-changed reschedule</name>
  <files>
    src/worker.ts
  </files>
  <action>
Make minimal, focused changes to `src/worker.ts` per user decision ("minimal changes to worker.ts -- add import + registration only, no refactoring").

**1. Add imports at the top of worker.ts:**
```typescript
import { processFristReminders } from "@/workers/processors/frist-reminder";
import { registerFristReminderJob } from "@/lib/queue/queues";
import { initializeDefaults } from "@/lib/settings/service";
import { getSettingTyped } from "@/lib/settings/service";
```

**2. Add frist-reminder Worker registration after the testWorker block (before Graceful Shutdown section):**
- Follow the EXACT same pattern as testWorker:
```typescript
// --- Frist-Reminder Queue Worker ---
const fristReminderWorker = new Worker(
  "frist-reminder",
  async (job) => {
    return processFristReminders();
  },
  {
    connection,
    concurrency: 1, // Only one scan at a time -- prevents duplicate notifications
    settings: {
      backoffStrategy: (attemptsMade: number) => calculateBackoff(attemptsMade),
    },
  }
);
```
- Add completion handler: log info with jobId and return value (deactivated, vorfristenSent, overdueSent counts)
- Add failure handler: log error, and on final failure (attemptsMade >= attempts), emit Socket.IO admin notification with type "job:failed", German title "Fristen-Erinnerung fehlgeschlagen", and error message
- Add error handler: log worker error
- Push to workers array: `workers.push(fristReminderWorker);`

**3. Convert startup to async function:**
- Replace the synchronous startup log at the bottom of the file with:
```typescript
async function startup() {
  // Initialize default settings for fresh installs (silent if already exist)
  await initializeDefaults();

  // Read configurable scan time from settings (default 06:00)
  const scanZeit = await getSettingTyped<string>("fristen.scan_zeit", "06:00");
  const [hours, minutes] = scanZeit.split(":").map(Number);
  const cronPattern = `${minutes} ${hours} * * *`;

  // Register repeatable frist-reminder cron job
  await registerFristReminderJob(cronPattern);

  log.info(
    { concurrency, queues: ["test", "frist-reminder"], fristScanZeit: scanZeit },
    "Worker started"
  );
}

startup().catch((err) => {
  log.fatal({ err }, "Worker startup failed");
  process.exit(1);
});
```

**4. Handle settings:changed for cron reschedule:**
- In the existing `subscriber.on("message")` handler, add a case for `fristen.scan_zeit`:
```typescript
if (data.key === "fristen.scan_zeit" && data.value) {
  const [hours, minutes] = data.value.split(":").map(Number);
  const cronPattern = `${minutes} ${hours} * * *`;
  registerFristReminderJob(cronPattern).then(() => {
    log.info({ scanZeit: data.value, cronPattern }, "Frist reminder schedule updated");
  }).catch((err) => {
    log.error({ err }, "Failed to update frist reminder schedule");
  });
}
```

**5. Update queues list in existing startup log:**
- Remove the old synchronous `log.info({ concurrency, queues: ["test"] }, "Worker started")` since it is now inside the async startup function.
  </action>
  <verify>
    <automated>cd /Users/patrickbaumfalk/Projekte/AI-Lawyer && npx tsc --noEmit --pretty 2>&1 | head -30</automated>
    <manual>Verify worker.ts has: fristReminderWorker registration, async startup() calling initializeDefaults + registerFristReminderJob with configurable cron, settings:changed handler for fristen.scan_zeit reschedule</manual>
  </verify>
  <done>
- fristReminderWorker is registered with concurrency: 1 in worker.ts
- startup() calls initializeDefaults() then registerFristReminderJob() with admin-configured scan time
- Settings channel handler reschedules cron when fristen.scan_zeit changes
- Worker startup log includes both queues: ["test", "frist-reminder"]
- Graceful shutdown covers fristReminderWorker (via workers array push)
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. `npm run build` (or esbuild worker bundle) succeeds
3. `src/lib/queue/queues.ts` exports `fristReminderQueue` and `registerFristReminderJob`, and `ALL_QUEUES` contains both `testQueue` and `fristReminderQueue`
4. `src/lib/queues.ts` is a thin re-export file (no duplicate Queue instances)
5. `src/worker.ts` imports and registers `processFristReminders` as a BullMQ Worker for queue "frist-reminder"
6. `src/worker.ts` calls `initializeDefaults()` and `registerFristReminderJob()` in async startup
7. `src/workers/processors/frist-reminder.ts` checks deduplication before every notification send
8. `src/workers/processors/frist-reminder.ts` sends email after in-app notification (dual-channel)
9. `src/workers/processors/frist-reminder.ts` implements shouldFireToday() with weekend/holiday shift
10. `src/lib/email/send.ts` exports sendEmail() with graceful failure handling
11. `nodemailer` is in package.json dependencies
12. `src/lib/settings/defaults.ts` includes fristen.scan_zeit, fristen.email_enabled, fristen.max_retry_age_days
</verification>

<success_criteria>
- The frist-reminder BullMQ Worker processes jobs from the "frist-reminder" queue
- A repeatable cron job runs daily at 06:00 Europe/Berlin (configurable via SystemSettings)
- Fristen with Vorfristen matching today trigger in-app notifications + email
- Weekend Vorfristen fire on the preceding Friday
- Deduplication prevents duplicate reminders on the same day
- Catch-up sends missed reminders after downtime
- frist-reminder queue is visible in admin Bull Board
- initializeDefaults() seeds settings on fresh installs
- Admin can change scan time and it takes effect without restart
</success_criteria>

<output>
After completion, create `.planning/phases/02.1-wire-frist-reminder-pipeline/02.1-01-SUMMARY.md`
</output>
