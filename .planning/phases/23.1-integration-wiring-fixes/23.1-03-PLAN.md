---
phase: 23.1-integration-wiring-fixes
plan: 03
type: execute
wave: 2
depends_on: [23.1-02]
files_modified:
  - src/components/ki/chat-layout.tsx
  - src/components/ki/chat-messages.tsx
  - src/app/api/ki-chat/pending/route.ts
autonomous: true
requirements: [ORCH-04]

must_haves:
  truths:
    - "Rueckfrage responses from the Schriftsatz pipeline render as normal Helena chat bubbles with round counter (3/5) and collapsible Bisherige Angaben section"
    - "User can click Verwerfen button on a pending Rueckfrage reminder to silently dismiss it"
    - "When user opens an Akte with a pending Rueckfrage, a proactive reminder re-displays the pending question"
    - "Schriftsatz conflict warning shows when a new Schriftsatz request is made while one is pending"
    - "Pipeline complete/error responses display correctly in the chat UI"
  artifacts:
    - path: "src/components/ki/chat-layout.tsx"
      provides: "Non-streaming response handling for Schriftsatz pipeline JSON responses"
      contains: "schriftsatz_rueckfrage"
    - path: "src/components/ki/chat-messages.tsx"
      provides: "RueckfrageMessage component with round counter and Bisherige Angaben"
      contains: "RueckfrageMessage"
    - path: "src/app/api/ki-chat/pending/route.ts"
      provides: "GET endpoint to check for pending Rueckfrage (proactive reminder)"
      exports: ["GET"]
  key_links:
    - from: "src/components/ki/chat-layout.tsx"
      to: "src/app/api/ki-chat/route.ts"
      via: "onResponse handler detecting non-streaming JSON responses"
      pattern: "schriftsatz_rueckfrage"
    - from: "src/components/ki/chat-layout.tsx"
      to: "src/app/api/ki-chat/pending/route.ts"
      via: "fetch on Akte change for proactive reminder"
      pattern: "ki-chat/pending"
    - from: "src/components/ki/chat-messages.tsx"
      to: "RueckfrageMessage component"
      via: "conditional render for schriftsatz message types"
      pattern: "RueckfrageMessage"
---

<objective>
Build the frontend handling for multi-turn Schriftsatz Rueckfragen: detect non-streaming pipeline responses in chat-layout, render Rueckfragen with context and round counter, add Verwerfen button, and proactive reminder on Akte open.

Purpose: The backend (plan 02) returns JSON responses for pipeline interactions. This plan ensures the chat UI correctly displays these non-streaming responses, provides the collapsible "Bisherige Angaben" section, and handles the Verwerfen (dismiss) action.
Output: Modified chat-layout.tsx and chat-messages.tsx, new pending check API endpoint.
</objective>

<execution_context>
@/Users/patrickbaumfalk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/patrickbaumfalk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23.1-integration-wiring-fixes/23.1-CONTEXT.md
@.planning/phases/23.1-integration-wiring-fixes/23.1-02-SUMMARY.md

<interfaces>
<!-- JSON response types from ki-chat route (plan 02) -->

Pipeline response discriminated union:
```typescript
// Returned by ki-chat route when Schriftsatz pipeline handles the message
type SchriftsatzResponse =
  | {
      type: "schriftsatz_rueckfrage";
      rueckfrage: string;
      round: number;
      maxRounds: number;
      filledSlots: Record<string, unknown>;
    }
  | {
      type: "schriftsatz_complete";
      text: string;
      draftId: string | null;
      warnungen: Array<{ typ: string; schwere: string; text: string }>;
    }
  | {
      type: "schriftsatz_error";
      text: string;
      warnungen: Array<{ typ: string; schwere: string; text: string }>;
    }
  | {
      type: "schriftsatz_conflict";
      text: string;
      pendingRueckfrage: string;
      round: number;
      maxRounds: number;
    };
```

From src/components/ki/chat-layout.tsx:
```typescript
// useChat from @ai-sdk/react -- the hook that manages chat state
const { messages, append, status, stop, error, setMessages } = useChat({
  api: "/api/ki-chat",
  body: { akteId: selectedAkteId, conversationId: selectedConversationId, crossAkte },
  onResponse: (response) => { /* sources header parsing */ },
  onFinish: () => { setRefreshKey(k => k + 1); },
});
```

From src/components/ki/chat-messages.tsx:
```typescript
interface ChatMessagesProps {
  messages: UIMessage[];
  isLoading: boolean;
  error?: Error | undefined;
  sources: SourceData[];
  conversationId: string | null;
}
```

From src/lib/helena/schriftsatz/pending-pipeline.ts (plan 02):
```typescript
export async function loadPendingPipeline(userId: string, akteId: string): Promise<PendingPipelineState | null>;
export async function clearPendingPipeline(userId: string, akteId: string): Promise<void>;
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create pending check API endpoint and add Verwerfen endpoint</name>
  <files>src/app/api/ki-chat/pending/route.ts</files>
  <action>
  Create `src/app/api/ki-chat/pending/route.ts` with two endpoints:

  **GET `/api/ki-chat/pending?akteId=xxx`** -- Check if the current user has a pending Rueckfrage for an Akte. Used by the frontend for proactive reminders on Akte open.

  **DELETE `/api/ki-chat/pending?akteId=xxx`** -- Dismiss (Verwerfen) a pending Rueckfrage. Called when user clicks the Verwerfen button.

  ```typescript
  /**
   * GET/DELETE /api/ki-chat/pending
   *
   * GET: Check for pending Schriftsatz Rueckfrage for current user + Akte.
   * Returns the pending state if one exists (for proactive reminder).
   *
   * DELETE: Dismiss (Verwerfen) a pending Rueckfrage.
   * Silently clears the pending state.
   */

  import { NextRequest, NextResponse } from "next/server";
  import { auth } from "@/lib/auth";
  import {
    loadPendingPipeline,
    clearPendingPipeline,
  } from "@/lib/helena/schriftsatz/pending-pipeline";
  import { MAX_ROUNDS } from "@/lib/helena/schriftsatz/pending-pipeline";

  export async function GET(req: NextRequest) {
    const session = await auth();
    if (!session?.user?.id) {
      return NextResponse.json({ error: "Nicht authentifiziert" }, { status: 401 });
    }

    const akteId = req.nextUrl.searchParams.get("akteId");
    if (!akteId) {
      return NextResponse.json({ pending: null });
    }

    const pending = await loadPendingPipeline(session.user.id, akteId);

    if (!pending) {
      return NextResponse.json({ pending: null });
    }

    // Return state for frontend display
    const filledSlots = Object.entries(pending.slotState)
      .filter(([, v]) => v !== null && !(typeof v === "string" && String(v).startsWith("{{")))
      .reduce((acc, [k, v]) => ({ ...acc, [k]: v }), {} as Record<string, unknown>);

    return NextResponse.json({
      pending: {
        rueckfrage: pending.rueckfrage,
        round: pending.round,
        maxRounds: MAX_ROUNDS,
        filledSlots,
        expiresAt: pending.expiresAt.toISOString(),
      },
    });
  }

  export async function DELETE(req: NextRequest) {
    const session = await auth();
    if (!session?.user?.id) {
      return NextResponse.json({ error: "Nicht authentifiziert" }, { status: 401 });
    }

    const akteId = req.nextUrl.searchParams.get("akteId");
    if (!akteId) {
      return NextResponse.json({ ok: true });
    }

    await clearPendingPipeline(session.user.id, akteId);

    return NextResponse.json({ ok: true });
  }
  ```
  </action>
  <verify>
  Run: `npx tsc --noEmit src/app/api/ki-chat/pending/route.ts 2>&1 | head -10` -- no type errors
  </verify>
  <done>
  - GET /api/ki-chat/pending?akteId=xxx returns pending Rueckfrage state or null
  - DELETE /api/ki-chat/pending?akteId=xxx clears pending state (Verwerfen)
  - Both endpoints require authentication
  - Response includes filledSlots, round, maxRounds for frontend display
  </done>
</task>

<task type="auto">
  <name>Task 2: Handle non-streaming pipeline responses in chat-layout and render Rueckfragen in chat-messages</name>
  <files>
    src/components/ki/chat-layout.tsx
    src/components/ki/chat-messages.tsx
  </files>
  <action>
  **Part A: Modify `src/components/ki/chat-layout.tsx`**

  The challenge: `useChat` from AI SDK expects streaming responses. The Schriftsatz pipeline returns JSON. We need to detect the non-streaming JSON response in `onResponse`, parse it, and inject it into the messages array as a synthetic assistant message.

  1. Add state for pending Rueckfrage detection:
     ```typescript
     const [pendingReminder, setPendingReminder] = useState<{
       rueckfrage: string;
       round: number;
       maxRounds: number;
       filledSlots: Record<string, unknown>;
     } | null>(null);
     ```

  2. Modify the `useChat` `onResponse` handler to detect non-streaming JSON responses from the pipeline. The key: check the `Content-Type` header. If it's `application/json` (not `text/event-stream`), it's a pipeline response.

     In the `onResponse` callback:
     ```typescript
     onResponse: async (response) => {
       // Handle sources header (existing code)
       const h = response.headers.get("X-Sources");
       if (h) {
         try {
           setSources(JSON.parse(decodeURIComponent(h)));
         } catch {
           setSources([]);
         }
       }

       // Detect Schriftsatz pipeline JSON responses (non-streaming)
       const contentType = response.headers.get("Content-Type") ?? "";
       if (contentType.includes("application/json")) {
         try {
           const cloned = response.clone();
           const payload = await cloned.json();

           if (payload.type === "schriftsatz_rueckfrage") {
             // Inject Rueckfrage as assistant message with metadata
             const rueckfrageText = payload.rueckfrage;
             const roundInfo = `(${payload.round}/${payload.maxRounds})`;
             const slotsInfo = Object.entries(payload.filledSlots || {});
             let content = `${rueckfrageText} ${roundInfo}`;

             if (slotsInfo.length > 0) {
               content += `\n\n<bisherige-angaben>${JSON.stringify(payload.filledSlots)}</bisherige-angaben>`;
             }

             setMessages((prev) => [
               ...prev,
               {
                 id: `schriftsatz-${Date.now()}`,
                 role: "assistant" as const,
                 content,
                 parts: [{ type: "text", text: content }],
               },
             ]);
             return; // Don't let useChat process this response further
           }

           if (payload.type === "schriftsatz_complete") {
             setMessages((prev) => [
               ...prev,
               {
                 id: `schriftsatz-${Date.now()}`,
                 role: "assistant" as const,
                 content: payload.text,
                 parts: [{ type: "text", text: payload.text }],
               },
             ]);
             return;
           }

           if (payload.type === "schriftsatz_error") {
             setMessages((prev) => [
               ...prev,
               {
                 id: `schriftsatz-${Date.now()}`,
                 role: "assistant" as const,
                 content: payload.text,
                 parts: [{ type: "text", text: payload.text }],
               },
             ]);
             return;
           }

           if (payload.type === "schriftsatz_conflict") {
             setMessages((prev) => [
               ...prev,
               {
                 id: `schriftsatz-${Date.now()}`,
                 role: "assistant" as const,
                 content: payload.text,
                 parts: [{ type: "text", text: payload.text }],
               },
             ]);
             return;
           }
         } catch {
           // Not JSON or parse failed -- fall through to normal handling
         }
       }
     },
     ```

     NOTE: The `return` after setMessages is critical -- it prevents useChat from trying to parse the JSON response as a stream, which would cause errors. However, this may need adjustment depending on how `useChat` handles the onResponse return value. If `useChat` still processes the response body after onResponse, an alternative approach is needed:

     Alternative approach (more robust): Instead of relying on `onResponse` return behavior, intercept at the `fetch` level. Override the `fetch` option on `useChat`:

     ```typescript
     const { messages, append, status, stop, error, setMessages } = useChat({
       api: "/api/ki-chat",
       body: { akteId: selectedAkteId, conversationId: selectedConversationId, crossAkte },
       fetch: async (input, init) => {
         const response = await fetch(input, init);

         // Check if this is a non-streaming pipeline response
         const contentType = response.headers.get("Content-Type") ?? "";
         if (contentType.includes("application/json")) {
           const payload = await response.json();

           // Handle pipeline responses by injecting into messages
           if (payload.type?.startsWith("schriftsatz_")) {
             handleSchriftsatzResponse(payload);
             // Return a fake empty stream so useChat doesn't crash
             return new Response(new ReadableStream({
               start(controller) { controller.close(); }
             }), {
               status: 200,
               headers: { "Content-Type": "text/event-stream" },
             });
           }

           // Not a pipeline response -- reconstruct the JSON response
           return new Response(JSON.stringify(payload), {
             status: response.status,
             headers: response.headers,
           });
         }

         return response;
       },
       onResponse: (response) => { /* existing sources parsing */ },
       onFinish: () => { setRefreshKey((k) => k + 1); },
     });
     ```

     With `handleSchriftsatzResponse`:
     ```typescript
     const handleSchriftsatzResponse = useCallback((payload: any) => {
       if (payload.type === "schriftsatz_rueckfrage") {
         const content = payload.rueckfrage;
         const meta = JSON.stringify({
           _schriftsatz: true,
           round: payload.round,
           maxRounds: payload.maxRounds,
           filledSlots: payload.filledSlots,
         });
         setMessages((prev) => [
           ...prev,
           {
             id: `schriftsatz-${Date.now()}`,
             role: "assistant" as const,
             content: `${content}\n<!--schriftsatz:${meta}-->`,
             parts: [{ type: "text", text: `${content}\n<!--schriftsatz:${meta}-->` }],
           },
         ]);
       } else if (payload.type === "schriftsatz_complete" || payload.type === "schriftsatz_error") {
         setMessages((prev) => [
           ...prev,
           {
             id: `schriftsatz-${Date.now()}`,
             role: "assistant" as const,
             content: payload.text,
             parts: [{ type: "text", text: payload.text }],
           },
         ]);
       } else if (payload.type === "schriftsatz_conflict") {
         setMessages((prev) => [
           ...prev,
           {
             id: `schriftsatz-${Date.now()}`,
             role: "assistant" as const,
             content: `${payload.text}\n<!--schriftsatz:${JSON.stringify({ _conflict: true, pendingRueckfrage: payload.pendingRueckfrage })}-->`,
             parts: [{ type: "text", text: payload.text }],
           },
         ]);
       }
     }, [setMessages]);
     ```

     Use the custom `fetch` approach -- it's the most reliable way to intercept JSON responses before `useChat` tries to parse them as streams. The metadata is embedded in an HTML comment within the message content so `chat-messages.tsx` can detect and render it appropriately.

  3. Add proactive reminder check on Akte change:
     ```typescript
     // Proactive reminder: check for pending Rueckfrage when Akte changes
     useEffect(() => {
       if (!selectedAkteId) {
         setPendingReminder(null);
         return;
       }

       fetch(`/api/ki-chat/pending?akteId=${selectedAkteId}`)
         .then((r) => r.json())
         .then((data) => {
           if (data.pending) {
             setPendingReminder(data.pending);
           } else {
             setPendingReminder(null);
           }
         })
         .catch(() => setPendingReminder(null));
     }, [selectedAkteId]);
     ```

  4. Add Verwerfen handler:
     ```typescript
     const handleDismissPending = useCallback(async () => {
       if (!selectedAkteId) return;
       await fetch(`/api/ki-chat/pending?akteId=${selectedAkteId}`, {
         method: "DELETE",
       });
       setPendingReminder(null);
     }, [selectedAkteId]);
     ```

  5. Pass `pendingReminder` and `handleDismissPending` to `ChatMessages`:
     ```typescript
     <ChatMessages
       key={selectedConversationId ?? "new"}
       messages={messages}
       isLoading={isLoading}
       error={error}
       sources={sources}
       conversationId={selectedConversationId}
       pendingReminder={pendingReminder}
       onDismissPending={handleDismissPending}
     />
     ```

  **Part B: Modify `src/components/ki/chat-messages.tsx`**

  1. Update `ChatMessagesProps` interface:
     ```typescript
     interface ChatMessagesProps {
       messages: UIMessage[];
       isLoading: boolean;
       error?: Error | undefined;
       sources: SourceData[];
       conversationId: string | null;
       pendingReminder?: {
         rueckfrage: string;
         round: number;
         maxRounds: number;
         filledSlots: Record<string, unknown>;
       } | null;
       onDismissPending?: () => void;
     }
     ```

  2. Add a helper function to parse Schriftsatz metadata from message content:
     ```typescript
     function parseSchriftsatzMeta(content: string): {
       isSchriftsatz: boolean;
       meta: { round?: number; maxRounds?: number; filledSlots?: Record<string, unknown>; _conflict?: boolean; pendingRueckfrage?: string } | null;
       cleanContent: string;
     } {
       const match = content.match(/<!--schriftsatz:(.*?)-->/s);
       if (!match) return { isSchriftsatz: false, meta: null, cleanContent: content };
       try {
         const meta = JSON.parse(match[1]);
         const cleanContent = content.replace(/\n?<!--schriftsatz:.*?-->/s, "").trim();
         return { isSchriftsatz: true, meta, cleanContent };
       } catch {
         return { isSchriftsatz: false, meta: null, cleanContent: content };
       }
     }
     ```

  3. Add a `RueckfrageMessage` component (inside the same file, before the main export):
     ```typescript
     function RueckfrageMessage({ text, filledSlots, round, maxRounds }: {
       text: string;
       filledSlots: Record<string, unknown>;
       round: number;
       maxRounds: number;
     }) {
       const slotEntries = Object.entries(filledSlots).filter(([, v]) => v !== null);

       return (
         <div>
           <div className="prose prose-sm dark:prose-invert max-w-none">
             <ReactMarkdown remarkPlugins={[remarkGfm]}>{text}</ReactMarkdown>
           </div>
           <span className="text-xs text-muted-foreground ml-1">({round}/{maxRounds})</span>
           {slotEntries.length > 0 && (
             <details className="mt-2 text-sm text-muted-foreground">
               <summary className="cursor-pointer hover:text-foreground transition-colors">
                 Bisherige Angaben ({slotEntries.length})
               </summary>
               <ul className="mt-1.5 ml-4 list-disc space-y-0.5">
                 {slotEntries.map(([key, value]) => (
                   <li key={key}>
                     <span className="font-medium">{key}:</span>{" "}
                     {String(value)}
                   </li>
                 ))}
               </ul>
             </details>
           )}
         </div>
       );
     }
     ```

  4. Add a `PendingReminderBanner` component for the proactive reminder:
     ```typescript
     function PendingReminderBanner({ reminder, onDismiss }: {
       reminder: {
         rueckfrage: string;
         round: number;
         maxRounds: number;
         filledSlots: Record<string, unknown>;
       };
       onDismiss: () => void;
     }) {
       return (
         <div className="mx-4 mb-3 p-3 rounded-lg bg-amber-50/80 dark:bg-amber-950/30 border border-amber-200/50 dark:border-amber-800/30">
           <div className="flex items-start justify-between gap-3">
             <div className="flex-1">
               <p className="text-sm font-medium text-amber-800 dark:text-amber-200 mb-1">
                 Offene Rueckfrage ({reminder.round}/{reminder.maxRounds})
               </p>
               <p className="text-sm text-amber-700 dark:text-amber-300">
                 {reminder.rueckfrage}
               </p>
             </div>
             <button
               onClick={onDismiss}
               className="text-xs text-amber-600 dark:text-amber-400 hover:text-amber-800 dark:hover:text-amber-200 px-2 py-1 rounded hover:bg-amber-100 dark:hover:bg-amber-900/50 transition-colors whitespace-nowrap"
             >
               Verwerfen
             </button>
           </div>
         </div>
       );
     }
     ```

  5. Integrate both components into the `ChatMessages` render. Inside the message loop, for assistant messages, check for Schriftsatz metadata and use `RueckfrageMessage` instead of the default renderer when appropriate.

     In the message rendering section (where `isUser` is checked), for assistant messages:
     ```typescript
     // Inside the assistant message rendering (after thinking check)
     (() => {
       const { isSchriftsatz, meta, cleanContent } = parseSchriftsatzMeta(msg.content);

       if (isSchriftsatz && meta?._schriftsatz) {
         return (
           <RueckfrageMessage
             text={cleanContent}
             filledSlots={meta.filledSlots ?? {}}
             round={meta.round ?? 1}
             maxRounds={meta.maxRounds ?? 5}
           />
         );
       }

       // ... existing thinking + response rendering
     })()
     ```

  6. Add the `PendingReminderBanner` at the top of the messages list (before the first message):
     ```typescript
     {/* Proactive reminder for pending Rueckfrage */}
     {pendingReminder && onDismissPending && (
       <PendingReminderBanner
         reminder={pendingReminder}
         onDismiss={onDismissPending}
       />
     )}
     ```

  IMPORTANT implementation notes:
  - The `<!--schriftsatz:...-->` metadata approach encodes pipeline state in the message content so it survives through useChat's message state management. The `parseSchriftsatzMeta` function extracts it, and the clean content is displayed.
  - The Verwerfen button calls DELETE /api/ki-chat/pending which clears the DB state.
  - The proactive reminder banner is shown at the top of the messages area, NOT as a message bubble.
  - The `<details>` HTML element for "Bisherige Angaben" is the simplest approach per research recommendation (native HTML, no extra component needed, Chrome-only target).
  </action>
  <verify>
  Run: `npx tsc --noEmit 2>&1 | head -20` -- no type errors
  Run: `grep -n "RueckfrageMessage\|PendingReminderBanner\|parseSchriftsatzMeta" src/components/ki/chat-messages.tsx` -- all 3 present
  Run: `grep -n "schriftsatz_rueckfrage\|handleSchriftsatzResponse\|pendingReminder" src/components/ki/chat-layout.tsx` -- pipeline response handling present
  Run: `grep -n "ki-chat/pending" src/components/ki/chat-layout.tsx` -- proactive reminder fetch present
  </verify>
  <done>
  - chat-layout.tsx intercepts non-streaming JSON responses via custom fetch wrapper
  - Pipeline responses are injected as synthetic assistant messages with embedded metadata
  - chat-messages.tsx parses Schriftsatz metadata and renders RueckfrageMessage with round counter + collapsible Bisherige Angaben
  - PendingReminderBanner shows proactive reminder on Akte open with Verwerfen button
  - GET/DELETE /api/ki-chat/pending endpoints handle pending state check and dismissal
  - TypeScript compiles without errors
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` -- no type errors across entire project
2. Manual flow test: Open Akte with pending Rueckfrage -> PendingReminderBanner appears with Verwerfen button
3. Manual flow test: Click Verwerfen -> banner disappears, DELETE /api/ki-chat/pending called
4. Manual flow test: Send Schriftsatz request -> Rueckfrage appears as normal chat bubble with round counter (1/5) and Bisherige Angaben collapsible section
5. Manual flow test: Answer the Rueckfrage -> pipeline resumes, new Rueckfrage or completion
6. Manual flow test: Send unrelated message during pending pipeline -> pending state cleared, normal RAG response
</verification>

<success_criteria>
- Pipeline JSON responses (schriftsatz_rueckfrage, schriftsatz_complete, schriftsatz_error, schriftsatz_conflict) are detected and rendered correctly in the chat UI
- RueckfrageMessage shows round counter "(N/5)" and collapsible "Bisherige Angaben" section
- PendingReminderBanner appears on Akte open when a pending Rueckfrage exists
- Verwerfen button clears pending state silently (no acknowledgment message per user decision)
- Custom fetch wrapper prevents useChat from crashing on non-streaming responses
- No type errors
</success_criteria>

<output>
After completion, create `.planning/phases/23.1-integration-wiring-fixes/23.1-03-SUMMARY.md`
</output>
