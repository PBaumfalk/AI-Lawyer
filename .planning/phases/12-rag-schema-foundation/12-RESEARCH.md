# Phase 12: RAG Schema Foundation - Research

**Researched:** 2026-02-27
**Domain:** Prisma ORM schema migration + pgvector HNSW index strategy for parent-child RAG chunking
**Confidence:** HIGH

<phase_requirements>
## Phase Requirements

| ID | Description | Research Support |
|----|-------------|-----------------|
| RAGQ-02 | Parent-Child Chunking — Dokumente werden in 500-Token Kind-Chunks (Embedding/Retrieval) und 2.000-Token Parent-Chunks (LLM-Prompt-Kontext) aufgeteilt; bestehende document_chunks erhalten chunkType-Enum (STANDALONE/PARENT/CHILD) | Schema changes to DocumentChunk (chunkType enum + parentChunkId self-relation), new LawChunk/UrteilChunk/Muster/MusterChunk/AkteNorm models, HNSW indexes via raw SQL migration — all patterns verified against existing codebase conventions |
</phase_requirements>

---

## Summary

Phase 12 is a pure database schema phase. It adds five new Prisma models (LawChunk, UrteilChunk, Muster, MusterChunk, AkteNorm) and extends the existing DocumentChunk model with a `chunkType` enum (STANDALONE/PARENT/CHILD) plus a nullable `parentChunkId` self-relation. No application logic is written in this phase — only schema and index DDL. Every subsequent phase (13-18) depends on these tables existing before it can write data.

The critical constraint is the project's established pattern for pgvector: Prisma uses `Unsupported("vector(1024)")` for the embedding column type, and HNSW indexes are created via a separate raw SQL file (not generated by Prisma). This pattern already exists in the codebase at `prisma/migrations/manual_pgvector_index.sql` and must be replicated for all three new chunk tables. Omitting the HNSW indexes at creation time causes full sequential scans as soon as data volume grows past ~1000 rows.

The migration must be additive-only and non-destructive to existing data. Existing `document_chunks` rows must receive `chunkType = STANDALONE` (not NULL) as part of the migration via a `UPDATE` statement in the migration SQL — NULL chunkType would silently break retrieval JOINs in Phase 13. The schema foundation for AkteNorm also requires the Akte model to expose a `normen` relation, which means a single line addition to `model Akte` in `prisma/schema.prisma`.

**Primary recommendation:** Write all schema changes as one Prisma migration (additive DDL only) + one accompanying raw SQL file for HNSW indexes, following the exact pattern of `manual_pgvector_index.sql`. Run `prisma generate` after migration to verify TypeScript client includes all new models.

---

## Standard Stack

### Core (already in project — no new installs)

| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| Prisma ORM | (existing) | Schema definition + migration generation | Already the project ORM; `prisma migrate dev` / `prisma migrate deploy` workflow is established |
| pgvector PostgreSQL extension | (existing) | Vector storage + cosine similarity | Already installed via `CREATE EXTENSION IF NOT EXISTS vector` in `manual_pgvector_index.sql`; enabled in schema via `extensions = [vector]` |
| `@prisma/client` | (existing) | TypeScript-typed DB access | Generated from schema; running `prisma generate` after migration updates all types |

### No New Libraries Required

This phase installs zero new npm packages. All work is:
1. Edits to `prisma/schema.prisma`
2. A Prisma-generated migration SQL file
3. A raw SQL file for HNSW indexes (appended to or alongside the migration)

**Installation:**
```bash
# No new packages — only Prisma schema + migration work
npx prisma migrate dev --name add_rag_schema_foundation
npx prisma generate
```

---

## Architecture Patterns

### Recommended File Changes

```
prisma/
├── schema.prisma                          # MODIFY: add ChunkType enum + 5 new models + DocumentChunk extensions
└── migrations/
    ├── YYYYMMDDHHMMSS_add_rag_schema_foundation/
    │   └── migration.sql                  # AUTO-GENERATED by prisma migrate dev (additive DDL)
    └── manual_rag_hnsw_indexes.sql        # NEW: HNSW indexes for law_chunks, urteil_chunks, muster_chunks
```

### Pattern 1: ChunkType Enum + DocumentChunk Extension

**What:** Add a `ChunkType` enum with three values (STANDALONE, PARENT, CHILD) to `prisma/schema.prisma`. Extend the existing `DocumentChunk` model with `chunkType`, `parentChunkId`, and a self-referential relation `parentChunk` / `childChunks`.

**When to use:** Any model that participates in parent-child chunking. In this phase, only `DocumentChunk` is extended — new tables (LawChunk etc.) store parentContent inline as a text field instead of via FK, to avoid JOIN round-trips at query time.

**Why self-relation on DocumentChunk but inline text on new tables:** The existing `DocumentChunk` model is embedded-per-document and read heavily at query time. Keeping parent-child as a FK relation allows the retrieval layer (Phase 13) to fetch `parentContent` in a single JOIN. New tables (LawChunk, UrteilChunk, MusterChunk) store `parentContent String? @db.Text` inline on each child row — simpler and avoids a second query. Both approaches are valid; the project research explicitly recommends inline storage for new tables.

**Prisma schema additions:**

```prisma
// Add to enum section (after existing enums, before models)
enum ChunkType {
  STANDALONE
  PARENT
  CHILD
}

// Modify existing DocumentChunk model
model DocumentChunk {
  id           String      @id @default(cuid())
  dokumentId   String
  dokument     Dokument    @relation(fields: [dokumentId], references: [id], onDelete: Cascade)
  chunkIndex   Int
  content      String      @db.Text
  embedding    Unsupported("vector(1024)")?
  modelVersion String
  createdAt    DateTime    @default(now())
  // Phase 12: Parent-child chunking additions
  chunkType    ChunkType   @default(STANDALONE)
  parentChunkId String?
  parentChunk  DocumentChunk?  @relation("DocumentChunkParent", fields: [parentChunkId], references: [id], onDelete: SetNull)
  childChunks  DocumentChunk[] @relation("DocumentChunkParent")

  @@unique([dokumentId, chunkIndex])
  @@index([dokumentId])
  @@index([parentChunkId])    // Phase 12: new index for parent lookup
  @@map("document_chunks")
}
```

**Critical:** The generated migration SQL will add `chunkType` with a DEFAULT of `'STANDALONE'` and `parentChunkId` as nullable. Verify the generated migration includes:
```sql
ALTER TABLE "document_chunks" ADD COLUMN "chunkType" "ChunkType" NOT NULL DEFAULT 'STANDALONE';
ALTER TABLE "document_chunks" ADD COLUMN "parentChunkId" TEXT;
```
If Prisma generates `DEFAULT 'CHILD'` or no default, manually correct the migration SQL before running `migrate deploy`.

### Pattern 2: New Chunk Tables with Inline parentContent

**What:** Three new Prisma models for the three RAG knowledge sources. Each follows an identical pattern: child `content` (embedded, retrieved), optional `parentContent` (stored inline for LLM prompt context), `embedding Unsupported("vector(1024)")?`, and source-specific metadata fields.

**LawChunk** (Gesetze-RAG, used by Phase 14):

```prisma
model LawChunk {
  id            String    @id @default(cuid())
  gesetzKuerzel String    // e.g. "BGB", "ZPO", "ArbGG"
  paragraphNr   String    // e.g. "§ 823", "§ 1 Abs. 2"
  titel         String
  content       String    @db.Text  // child chunk (~500 tokens) — embedded
  parentContent String?   @db.Text  // parent chunk (~2000 tokens) — LLM context, not embedded
  embedding     Unsupported("vector(1024)")?
  modelVersion  String
  syncedAt      DateTime  @default(now())
  sourceUrl     String?   // gesetze-im-internet.de canonical URL

  @@index([gesetzKuerzel])
  @@index([paragraphNr])
  @@map("law_chunks")
}
```

**UrteilChunk** (Urteile-RAG, used by Phase 17):

```prisma
model UrteilChunk {
  id            String    @id @default(cuid())
  aktenzeichen  String    // e.g. "8 AZR 123/24"
  gericht       String    // "BAG", "BGH", "BVerfG" etc.
  datum         DateTime
  rechtsgebiet  String?
  content       String    @db.Text  // PII-filtered child chunk
  parentContent String?   @db.Text  // PII-filtered parent chunk
  embedding     Unsupported("vector(1024)")?
  modelVersion  String
  sourceUrl     String    @unique   // prevents duplicate ingestion
  piiFiltered   Boolean   @default(false)
  ingestedAt    DateTime  @default(now())

  @@index([gericht])
  @@index([datum])
  @@index([rechtsgebiet])
  @@map("urteil_chunks")
}
```

**Muster + MusterChunk** (Arbeitswissen-RAG, used by Phase 18):

```prisma
// Master record for uploaded template file
model Muster {
  id           String        @id @default(cuid())
  name         String
  kategorie    String        // e.g. "Schriftsatz", "Formular"
  beschreibung String?       @db.Text
  minioKey     String        // path in MinIO bucket "muster-uploads/"
  mimeType     String
  nerStatus    MusterNerStatus @default(PENDING_NER)
  uploadedById String
  uploadedBy   User          @relation("MusterUploads", fields: [uploadedById], references: [id])
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  chunks       MusterChunk[]

  @@index([nerStatus])
  @@map("muster")
}

enum MusterNerStatus {
  PENDING_NER
  NER_RUNNING
  INDEXED
  REJECTED_PII_DETECTED
}

// Individual chunk records for a Muster file
model MusterChunk {
  id            String    @id @default(cuid())
  musterId      String
  muster        Muster    @relation(fields: [musterId], references: [id], onDelete: Cascade)
  chunkIndex    Int
  content       String    @db.Text  // PII-anonymized child chunk
  parentContent String?   @db.Text  // PII-anonymized parent chunk
  embedding     Unsupported("vector(1024)")?
  modelVersion  String
  createdAt     DateTime  @default(now())

  @@unique([musterId, chunkIndex])
  @@index([musterId])
  @@map("muster_chunks")
}
```

### Pattern 3: AkteNorm Link Table

**What:** Joins an Akte to a specific paragraph in `law_chunks` via denormalized `gesetzKuerzel` + `paragraphNr` fields (not a FK to `LawChunk.id` — avoids breaking AkteNorm records if law_chunks are re-indexed). Requires adding a `normen` relation on the `Akte` model.

**Prisma schema:**

```prisma
model AkteNorm {
  id           String    @id @default(cuid())
  akteId       String
  akte         Akte      @relation(fields: [akteId], references: [id], onDelete: Cascade)
  gesetzKuerzel String   // e.g. "BGB"
  paragraphNr  String    // e.g. "§ 242"
  anmerkung    String?   @db.Text
  addedById    String
  addedBy      User      @relation("AkteNormUser", fields: [addedById], references: [id])
  createdAt    DateTime  @default(now())

  @@unique([akteId, gesetzKuerzel, paragraphNr])  // prevent duplicates
  @@index([akteId])
  @@map("akte_normen")
}
```

Also add to `model Akte`:
```prisma
  normen  AkteNorm[]
```

Also add to `model User`:
```prisma
  akteNormen  AkteNorm[]  @relation("AkteNormUser")
```

Also add to `model User` for Muster uploads:
```prisma
  musterUploads  Muster[]  @relation("MusterUploads")
```

### Pattern 4: HNSW Index via Raw SQL (Project Convention)

**What:** HNSW indexes on `embedding` columns for all three new chunk tables. Mirrors the exact approach in `prisma/migrations/manual_pgvector_index.sql` which already handles `document_chunks`.

**Why raw SQL:** Prisma cannot generate HNSW indexes from schema directives. The `@@index` decorator creates a B-tree index, not an HNSW index. The project already established the convention of keeping HNSW DDL in a separate SQL file.

**Content of new `prisma/migrations/manual_rag_hnsw_indexes.sql`:**

```sql
-- ============================================================================
-- HNSW Indexes for RAG Schema Foundation (Phase 12)
-- ============================================================================
-- Run after prisma migrate deploy to create vector similarity indexes.
-- Prisma cannot generate HNSW indexes — these are applied manually.
--
-- Apply via: psql -U <user> -d <db> -f prisma/migrations/manual_rag_hnsw_indexes.sql
-- Parameters: m=16 (connections per layer), ef_construction=64 (build accuracy)
-- Matches existing document_chunks_embedding_idx parameters.
-- ============================================================================

-- Gesetze chunks (law_chunks table)
CREATE INDEX IF NOT EXISTS law_chunks_embedding_hnsw
  ON law_chunks
  USING hnsw (embedding vector_cosine_ops)
  WITH (m = 16, ef_construction = 64);

-- Urteil chunks (urteil_chunks table)
CREATE INDEX IF NOT EXISTS urteil_chunks_embedding_hnsw
  ON urteil_chunks
  USING hnsw (embedding vector_cosine_ops)
  WITH (m = 16, ef_construction = 64);

-- Muster chunks (muster_chunks table)
CREATE INDEX IF NOT EXISTS muster_chunks_embedding_hnsw
  ON muster_chunks
  USING hnsw (embedding vector_cosine_ops)
  WITH (m = 16, ef_construction = 64);
```

**Verification command after running:**
```sql
EXPLAIN ANALYZE SELECT * FROM law_chunks
  ORDER BY embedding <=> '[0.1, 0.2, ...]'::vector
  LIMIT 10;
-- Expected: "Index Scan using law_chunks_embedding_hnsw" — NOT "Seq Scan"
```

### Pattern 5: Existing Data Migration (chunkType backfill)

**What:** Existing `document_chunks` rows must have `chunkType = 'STANDALONE'` after migration — not NULL. Prisma's `@default(STANDALONE)` only applies to NEW rows, not existing ones.

**How Prisma handles this:** When Prisma generates the migration SQL for adding `chunkType` with `@default(STANDALONE)`, it will write:
```sql
ALTER TABLE "document_chunks" ADD COLUMN "chunkType" "ChunkType" NOT NULL DEFAULT 'STANDALONE';
```
PostgreSQL applies the default to all existing rows when adding a NOT NULL column with a DEFAULT — this is atomic and safe. No manual UPDATE is needed. However, verify the generated migration file contains `NOT NULL DEFAULT 'STANDALONE'` before running — if Prisma omits the NOT NULL or uses a different default, add it manually.

### Anti-Patterns to Avoid

- **Using `@@index` for vector columns in Prisma schema:** This generates a standard B-tree index, not an HNSW index. HNSW must be in raw SQL. The `@@index([embedding])` directive should NOT appear in the new models.
- **Adding HNSW indexes in the same migration transaction as table creation:** `CREATE INDEX ... USING hnsw` can be slow on large tables and may cause lock issues. For new empty tables it is fine. For the future when tables have data, use `CREATE INDEX CONCURRENTLY` — but that cannot run inside a transaction, so it must be a separate psql session.
- **Putting `sourceUrl @unique` on LawChunk:** Law chunks have no natural unique URL per child chunk (the URL is per-Gesetz, not per-chunk). Only `UrteilChunk.sourceUrl` is unique (one URL per court decision). LawChunk deduplication is by `(gesetzKuerzel, paragraphNr)` composite — handle in application code, not via DB constraint.
- **FK from AkteNorm to LawChunk.id:** If law_chunks are re-indexed (DELETE + re-INSERT), all AkteNorm records would cascade-delete. Use denormalized `gesetzKuerzel + paragraphNr` strings instead — they survive re-ingestion.
- **Nullable chunkType on DocumentChunk:** The field must be `NOT NULL DEFAULT STANDALONE`. Nullable chunkType causes `WHERE chunkType = 'CHILD'` to miss rows and breaks parent-child retrieval in Phase 13.

---

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| HNSW index creation | Custom index DDL patterns | Copy exactly from `prisma/migrations/manual_pgvector_index.sql` | Same parameters (m=16, ef_construction=64) already validated for this stack |
| Enum-to-SQL mapping | Manual type casting | Prisma enum — Prisma generates correct `CREATE TYPE "ChunkType" AS ENUM (...)` DDL | Prisma handles PostgreSQL enum creation + column binding automatically |
| Existing row backfill | Manual UPDATE script | `NOT NULL DEFAULT 'STANDALONE'` on the ALTER TABLE statement | PostgreSQL applies DEFAULT to existing rows atomically when adding NOT NULL column with DEFAULT |
| Migration naming | Custom timestamp | `npx prisma migrate dev --name add_rag_schema_foundation` | Prisma generates the timestamp prefix `YYYYMMDDHHMMSS_` automatically |

**Key insight:** This phase is purely mechanical schema work. The patterns are 100% established by the existing codebase (`manual_pgvector_index.sql`, `add_user_settings` migration style). Do not invent new patterns.

---

## Common Pitfalls

### Pitfall 1: HNSW Index Missing on New Tables

**What goes wrong:** The planner creates new `LawChunk`, `UrteilChunk`, `MusterChunk` tables via Prisma migration but forgets to add the raw SQL HNSW indexes. Phase 14 ingests 50k+ law chunks. Phase 13 hybrid search runs `ORDER BY embedding <=> $1 LIMIT 50` — this becomes a 30-second sequential scan. Production chat grinds to a halt.

**Why it happens:** Prisma `@@index` generates B-tree, not HNSW. Easy to miss the separate raw SQL step if following only Prisma docs.

**How to avoid:** Add `manual_rag_hnsw_indexes.sql` as a required task in the phase plan. Add a verification step: `EXPLAIN ANALYZE` on a vector ORDER BY query must show `Index Scan`, not `Seq Scan`.

**Warning signs:** First `EXPLAIN ANALYZE` after migration shows `Seq Scan on law_chunks (cost=0.00.....)`.

### Pitfall 2: chunkType Column Defaulting to NULL or 'CHILD'

**What goes wrong:** Prisma generates the migration with wrong default, or the migration runs but existing rows stay NULL. Phase 13 retrieval filters `WHERE chunk_type != 'PARENT'` — existing document chunks return zero results. Helena stops working for all pre-migration documents.

**Why it happens:** Prisma enum default translation can be tricky, especially for new enum types.

**How to avoid:** After `prisma migrate dev` generates the migration file, manually inspect `migration.sql` before running `migrate deploy`. Confirm it contains:
```sql
ALTER TABLE "document_chunks" ADD COLUMN "chunkType" "ChunkType" NOT NULL DEFAULT 'STANDALONE';
```
If it says `DEFAULT 'CHILD'` or is nullable, edit the file.

**Warning signs:** `SELECT COUNT(*) FROM document_chunks WHERE "chunkType" IS NULL` returns > 0 after migration.

### Pitfall 3: Prisma Relation Naming Conflicts on Self-Referential DocumentChunk

**What goes wrong:** Prisma requires explicit relation names when a model has more than one relation to the same model (or a self-relation). Using the same relation name on `parentChunk` and `childChunks` causes `prisma validate` to fail with "A self-relation must be disambiguated."

**Why it happens:** Self-referential relations in Prisma require a `name` argument in both `@relation` directives.

**How to avoid:** Both sides of the self-relation must use the same relation name string:
```prisma
parentChunk  DocumentChunk?  @relation("DocumentChunkParent", fields: [parentChunkId], references: [id], onDelete: SetNull)
childChunks  DocumentChunk[] @relation("DocumentChunkParent")
```
Run `npx prisma validate` before `migrate dev` to catch schema errors.

**Warning signs:** `prisma validate` outputs `Error: A self-relation must be disambiguated`.

### Pitfall 4: Missing User Relation Declarations

**What goes wrong:** `Muster.uploadedBy User @relation(...)` and `AkteNorm.addedBy User @relation(...)` are added to the new models, but the corresponding back-relations on `model User` are not added. `prisma validate` fails with "The relation ... is missing the required `@relation` attribute on the other side."

**Why it happens:** Prisma requires both sides of every relation to be declared.

**How to avoid:** For every new relation pointing to `User` or `Akte`, add the back-relation array field to `model User` / `model Akte`. Required additions:
- `model User`: `akteNormen AkteNorm[] @relation("AkteNormUser")`
- `model User`: `musterUploads Muster[] @relation("MusterUploads")`
- `model Akte`: `normen AkteNorm[]`

**Warning signs:** `npx prisma validate` error about missing relation on `User` model.

### Pitfall 5: Running `prisma migrate deploy` Instead of `prisma migrate dev` in Development

**What goes wrong:** `prisma migrate deploy` applies pending migrations without creating a new one. Running it without first running `prisma migrate dev` means the schema changes exist in `schema.prisma` but no migration file is generated — the DB stays at the old schema.

**How to avoid:** In development, always run `prisma migrate dev --name <name>` to generate + apply. `migrate deploy` is for production/CI only.

---

## Code Examples

Verified patterns from existing codebase and official Prisma docs:

### Adding a Self-Referential Relation (Prisma Schema)

```prisma
// Source: Prisma official docs + existing schema.prisma conventions
model DocumentChunk {
  id            String      @id @default(cuid())
  dokumentId    String
  dokument      Dokument    @relation(fields: [dokumentId], references: [id], onDelete: Cascade)
  chunkIndex    Int
  content       String      @db.Text
  embedding     Unsupported("vector(1024)")?
  modelVersion  String
  createdAt     DateTime    @default(now())
  // Phase 12: Parent-child chunking
  chunkType     ChunkType   @default(STANDALONE)
  parentChunkId String?
  parentChunk   DocumentChunk?  @relation("DocumentChunkParent", fields: [parentChunkId], references: [id], onDelete: SetNull)
  childChunks   DocumentChunk[] @relation("DocumentChunkParent")

  @@unique([dokumentId, chunkIndex])
  @@index([dokumentId])
  @@index([parentChunkId])
  @@map("document_chunks")
}
```

### Migration Style (matches existing `add_user_settings` migration)

```sql
-- migration.sql (auto-generated by prisma migrate dev)
-- CreateEnum
CREATE TYPE "ChunkType" AS ENUM ('STANDALONE', 'PARENT', 'CHILD');

-- CreateEnum
CREATE TYPE "MusterNerStatus" AS ENUM ('PENDING_NER', 'NER_RUNNING', 'INDEXED', 'REJECTED_PII_DETECTED');

-- AlterTable: extend existing document_chunks (safe — additive only)
ALTER TABLE "document_chunks" ADD COLUMN "chunkType" "ChunkType" NOT NULL DEFAULT 'STANDALONE';
ALTER TABLE "document_chunks" ADD COLUMN "parentChunkId" TEXT;

-- CreateIndex
CREATE INDEX "document_chunks_parentChunkId_idx" ON "document_chunks"("parentChunkId");

-- CreateTable
CREATE TABLE "law_chunks" (
    "id" TEXT NOT NULL,
    "gesetzKuerzel" TEXT NOT NULL,
    "paragraphNr" TEXT NOT NULL,
    "titel" TEXT NOT NULL,
    "content" TEXT NOT NULL,
    "parentContent" TEXT,
    "modelVersion" TEXT NOT NULL,
    "syncedAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "sourceUrl" TEXT,
    CONSTRAINT "law_chunks_pkey" PRIMARY KEY ("id")
);

-- (UrteilChunk, Muster, MusterChunk, AkteNorm tables follow same pattern)

-- AddForeignKey (after all tables exist)
ALTER TABLE "document_chunks" ADD CONSTRAINT "document_chunks_parentChunkId_fkey"
  FOREIGN KEY ("parentChunkId") REFERENCES "document_chunks"("id")
  ON DELETE SET NULL ON UPDATE CASCADE;
```

### HNSW Index Verification Query

```sql
-- Source: pgvector official docs — verify HNSW index is used, not Seq Scan
EXPLAIN ANALYZE
SELECT id, content, 1 - (embedding <=> '[0.1, 0.2, 0.3]'::vector) AS similarity
FROM law_chunks
ORDER BY embedding <=> '[0.1, 0.2, 0.3]'::vector
LIMIT 10;

-- Expected output includes:
-- "Index Scan using law_chunks_embedding_hnsw on law_chunks"
-- NOT "Seq Scan on law_chunks"
```

### Prisma Client Usage After Migration

```typescript
// Source: project conventions (matches existing vector-store.ts patterns)
// After prisma generate, all new models are available:

import { prisma } from '@/lib/prisma';
import { ChunkType } from '@prisma/client';

// Insert a PARENT chunk
const parent = await prisma.documentChunk.create({
  data: {
    dokumentId: 'some-id',
    chunkIndex: 0,
    content: 'Full paragraph text...',
    modelVersion: 'multilingual-e5-large-instruct',
    chunkType: ChunkType.PARENT,
  },
});

// Insert a CHILD chunk referencing the parent
const child = await prisma.documentChunk.create({
  data: {
    dokumentId: 'some-id',
    chunkIndex: 1,
    content: 'Sub-section text...',
    modelVersion: 'multilingual-e5-large-instruct',
    chunkType: ChunkType.CHILD,
    parentChunkId: parent.id,
  },
});

// Query for existing (pre-migration) standalone chunks — these have chunkType = STANDALONE
const standalone = await prisma.documentChunk.findMany({
  where: { chunkType: ChunkType.STANDALONE },
});
```

---

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Single flat chunk table with no parent-child | Separate PARENT/CHILD enum + self-relation or inline parentContent | 2024-2025 mainstream adoption | Retrieval precision up (child embeds) + LLM quality up (parent context) |
| IVFFlat pgvector index (requires training data) | HNSW index (works on empty table, no training) | pgvector 0.5.0 (2023) | HNSW is now the default; works immediately on new tables; consistent performance as data grows |
| Embedding full paragraphs (>512 tokens) | Child chunks (~500 tokens) for embedding, parent for context | 2023-2024 | Avoids embedding quality degradation from exceeding multilingual-e5 practical token limit |
| Storing pgvector embedding type via Prisma native | `Unsupported("vector(1024)")` in Prisma schema | Ongoing (Prisma still lacks native vector type) | Requires raw SQL for vector operations + HNSW indexes; project already uses this correctly |

**Deprecated/outdated:**
- `IVFFlat` index type: requires `VACUUM ANALYZE` + explicit `SET ivfflat.probes` per query; HNSW is strictly superior for kanzlei-scale data
- Mammoth's Markdown output API: officially deprecated per mammoth.js README (not relevant to this phase, but noted for later phases)

---

## Open Questions

1. **Whether `embedding` column should be nullable on new tables**
   - What we know: Existing `DocumentChunk.embedding` is `Unsupported("vector(1024)")?` (nullable). This allows insert-then-embed async workflows.
   - What's unclear: Should LawChunk/UrteilChunk/MusterChunk follow the same nullable pattern? Or require non-null (all inserts must embed synchronously)?
   - Recommendation: Use nullable (`?`) on all new chunk tables, matching the existing pattern. BullMQ processors can insert the row first (embedding = null), then update with the embedding after Ollama returns. This allows tracking "ingested but not yet embedded" state.

2. **Migration ordering — should HNSW indexes be in the same file or a separate file?**
   - What we know: The project uses a separate file (`manual_pgvector_index.sql`) for the existing HNSW index. This is applied manually or via Docker entrypoint, not via `prisma migrate deploy`.
   - What's unclear: Should the new HNSW indexes be added to the existing `manual_pgvector_index.sql` or a new file?
   - Recommendation: Create a new file `manual_rag_hnsw_indexes.sql` to keep the original file stable. Update `docker-compose.yml` or the DB init script to also apply this new file on startup.

3. **Whether `MusterNerStatus` enum needs to live in schema.prisma or can be a string field**
   - What we know: The status machine `PENDING_NER → NER_RUNNING → INDEXED | REJECTED_PII_DETECTED` is critical for BRAO §43a compliance (per project research).
   - What's unclear: Whether Prisma enum vs TypeScript-level enum + DB string column is preferred.
   - Recommendation: Use a Prisma enum (`MusterNerStatus`). This enforces valid values at the DB level and gives TypeScript type safety via the generated client. The project uses Prisma enums extensively (UserRole, AkteStatus, OcrStatus etc.).

---

## Sources

### Primary (HIGH confidence)

- `prisma/migrations/manual_pgvector_index.sql` — exact HNSW index parameters and SQL pattern established for this project (direct file inspection)
- `prisma/migrations/20260226000001_add_user_settings/migration.sql` — exact migration SQL style for this project (direct file inspection)
- `prisma/schema.prisma` lines 919-932 — existing DocumentChunk model structure; confirmed no `chunkType` or `parentChunkId` fields exist yet (direct file inspection)
- `.planning/research/ARCHITECTURE.md` — complete new Prisma schema designs for LawChunk, UrteilChunk, Muster, MusterChunk, AkteNorm (project research, HIGH confidence)
- `.planning/research/STACK.md` — explicit ChunkType enum design with STANDALONE/PARENT/CHILD values; migration strategy for existing rows (project research, HIGH confidence)
- `.planning/research/SUMMARY.md` — confirmed pitfalls: missing HNSW indexes = seq scan at 10k+ rows; nullable chunkType breaks retrieval JOINs; AkteNorm FK-vs-denormalized decision (project research, HIGH confidence)
- pgvector HNSW documentation — m=16, ef_construction=64 as recommended defaults for <1M rows: https://github.com/pgvector/pgvector

### Secondary (MEDIUM confidence)

- Prisma self-referential relations documentation — `@relation` naming requirement for self-relations: https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/self-relations

---

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH — no new libraries; all work uses established Prisma + pgvector patterns already validated in this codebase
- Architecture: HIGH — schema designs fully specified in prior project research; cross-checked against existing schema.prisma conventions (cuid IDs, @@map snake_case, @db.Text for long strings)
- Pitfalls: HIGH — directly derived from project research (ARCHITECTURE.md, SUMMARY.md) and existing codebase inspection

**Research date:** 2026-02-27
**Valid until:** 2026-05-27 (Prisma + pgvector are stable; patterns do not change frequently)
