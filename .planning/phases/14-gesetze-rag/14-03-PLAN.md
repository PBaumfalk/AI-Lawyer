---
phase: 14-gesetze-rag
plan: "03"
type: execute
wave: 2
depends_on: ["14-01"]
files_modified:
  - src/app/api/ki-chat/route.ts
autonomous: true
requirements: [GESETZ-03]

must_haves:
  truths:
    - "Helena retrieves top-5 law_chunks in parallel with existing hybridSearch (not sequentially)"
    - "Law chunks with score < 0.6 are filtered out — non-legal queries receive no law context"
    - "When law chunks are included, every norm in the system prompt carries 'nicht amtlich — Stand: [syncedAt date]' and Quellenlink"
    - "queryEmbedding is generated ONCE and shared between hybridSearch and searchLawChunks — no double Ollama round-trip"
    - "Law chunk retrieval failure is non-fatal — Helena still responds from hybridSearch results"
  artifacts:
    - path: "src/app/api/ki-chat/route.ts"
      provides: "Chain D (law_chunks parallel retrieval) added alongside Chains A/B/C"
      contains: "searchLawChunks"
  key_links:
    - from: "src/app/api/ki-chat/route.ts Chain D"
      to: "src/lib/gesetze/ingestion.ts searchLawChunks()"
      via: "shared queryEmbedding from Chain B embedding step"
      pattern: "searchLawChunks"
    - from: "system prompt GESETZE-QUELLEN block"
      to: "law_chunks.syncedAt"
      via: "syncedAt.toLocaleDateString('de-DE') for Stand date"
      pattern: "nicht amtlich"
---

<objective>
Extend ki-chat/route.ts with Chain D — parallel law_chunks retrieval that injects top-5 Normen into Helena's system prompt with "nicht amtlich" disclaimers and Quellenlinks.

Purpose: GESETZ-03 requires Helena to automatically retrieve relevant Bundesgesetz paragraphs for legal queries. The queryEmbedding from Chain B must be refactored to be shared — generating it twice would double Ollama latency.

Output:
- src/app/api/ki-chat/route.ts — Chain D added, queryEmbedding extracted to shared variable, law_chunks system prompt block injected
</objective>

<execution_context>
@/Users/patrickbaumfalk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/patrickbaumfalk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/14-gesetze-rag/14-RESEARCH.md
@.planning/phases/14-gesetze-rag/14-01-SUMMARY.md

<interfaces>
<!-- Key contracts the executor needs. Verified from codebase inspection. -->

Current ki-chat/route.ts structure (Phase 13 result — must preserve ALL existing logic):

Chain B currently (to be refactored):
```typescript
// Chain B: RAG retrieval (hybrid search: BM25 + vector + RRF + reranking)
const ragPromise = (async (): Promise<{
  sources: HybridSearchResult[];
  confidenceFlag: "none" | "low" | "ok";
}> => {
  try {
    const queryEmbedding = await generateQueryEmbedding(queryText);  // <-- move this OUT
    const results = await hybridSearch(queryText, queryEmbedding, { ... });
    ...
  } catch (err) { ... }
})();

const [aktenKontextBlock, ragResult, [model, modelName, providerName]] =
  await Promise.all([akteContextPromise, ragPromise, modelConfigPromise]);
```

After refactor — queryEmbedding extracted to shared step, Chain D added:
```typescript
// Shared embedding (used by both Chain B and Chain D)
const queryEmbeddingPromise = generateQueryEmbedding(queryText).catch((err) => {
  console.error("[ki-chat] Query embedding failed:", err);
  return null;  // null = both Chain B and Chain D degrade gracefully
});

// Chain B: hybridSearch with shared embedding
const ragPromise = (async () => {
  const queryEmbedding = await queryEmbeddingPromise;
  if (!queryEmbedding) return { sources: [], confidenceFlag: "none" as const };
  const results = await hybridSearch(queryText, queryEmbedding, { ... });
  ...
})();

// Chain D: law_chunks search with shared embedding
const lawChunksPromise = (async () => {
  try {
    const queryEmbedding = await queryEmbeddingPromise;
    if (!queryEmbedding) return [];
    return await searchLawChunks(queryEmbedding, { limit: 5, minScore: 0.6 });
  } catch (err) {
    console.error("[ki-chat] Law chunks search failed:", err);
    return [];
  }
})();

// Await all four chains in parallel
const [aktenKontextBlock, ragResult, [model, modelName, providerName], lawChunks] =
  await Promise.all([akteContextPromise, ragPromise, modelConfigPromise, lawChunksPromise]);
```

From src/lib/gesetze/ingestion.ts (created in Plan 01):
```typescript
export interface LawChunkResult {
  id: string;
  gesetzKuerzel: string;
  paragraphNr: string;
  titel: string;
  content: string;
  syncedAt: Date;
  sourceUrl: string | null;
  score: number;
}
export async function searchLawChunks(
  queryEmbedding: number[],
  opts: { limit?: number; minScore?: number }
): Promise<LawChunkResult[]>;
```

System prompt injection format (after existing --- QUELLEN --- block):
```typescript
// After the existing sources block (if sources.length > 0 ... systemPrompt += "--- ENDE QUELLEN ---"):
if (lawChunks.length > 0) {
  systemPrompt += "\n\n--- GESETZE-QUELLEN (nicht amtlich) ---\n";
  lawChunks.forEach((norm, i) => {
    const standDate = new Date(norm.syncedAt).toLocaleDateString("de-DE", {
      day: "2-digit",
      month: "2-digit",
      year: "numeric",
    });
    systemPrompt += `\n[G${i + 1}] ${norm.gesetzKuerzel} ${norm.paragraphNr}: ${norm.titel}\n`;
    systemPrompt += `${norm.content}\n`;
    systemPrompt += `HINWEIS: nicht amtlich — Stand: ${standDate} | Quelle: ${norm.sourceUrl ?? "https://www.gesetze-im-internet.de/"}\n`;
  });
  systemPrompt += "\n--- ENDE GESETZE-QUELLEN ---";
  systemPrompt += "\n\nWenn du Normen zitierst, füge immer den 'nicht amtlich'-Hinweis und den Quellenlink hinzu.";
}
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Chain D — law_chunks parallel retrieval to ki-chat</name>
  <files>
    src/app/api/ki-chat/route.ts
  </files>
  <action>
Modify `src/app/api/ki-chat/route.ts`. This is a surgical edit — preserve ALL existing logic exactly, only:
1. Add import for searchLawChunks
2. Extract queryEmbedding from inside Chain B to a shared Promise variable
3. Add Chain D (lawChunksPromise)
4. Update Promise.all to include lawChunksPromise
5. Add law_chunks system prompt block after existing QUELLEN block

ADD to imports at top of file (after existing imports):
```typescript
import { searchLawChunks } from "@/lib/gesetze/ingestion";
```

REPLACE the Chain B section. The current Chain B internally calls `generateQueryEmbedding`. Extract it to a shared Promise BEFORE Chain B:

```typescript
  // Shared query embedding — generated once, used by Chain B (hybridSearch) and Chain D (law_chunks).
  // If embedding fails, both chains degrade gracefully (Chain B returns no sources, Chain D returns []).
  const queryEmbeddingPromise = generateQueryEmbedding(queryText).catch((err) => {
    console.error("[ki-chat] Query embedding generation failed:", err);
    return null as null;
  });

  // Chain B: RAG retrieval (hybrid search: BM25 + vector + RRF + reranking)
  const ragPromise = (async (): Promise<{
    sources: HybridSearchResult[];
    confidenceFlag: "none" | "low" | "ok";
  }> => {
    try {
      const queryEmbedding = await queryEmbeddingPromise;
      if (!queryEmbedding) return { sources: [], confidenceFlag: "none" };
      const results = await hybridSearch(queryText, queryEmbedding, {
        akteId: akteId ?? undefined,
        crossAkte,
        userId,
        bm25Limit: 50,
        vectorLimit: 50,
        finalLimit: 10,
      });

      if (results.length === 0) {
        return { sources: results, confidenceFlag: "none" };
      }
      return {
        sources: results,
        confidenceFlag: "ok",
      };
    } catch (err) {
      console.error("[ki-chat] RAG retrieval failed:", err);
      return { sources: [], confidenceFlag: "none" };
    }
  })();

  // Chain C: Model configuration (settings reads — now cached via TTL)
  const modelConfigPromise = Promise.all([
    getModel(),
    getModelName(),
    getProviderName(),
  ]);

  // Chain D: law_chunks retrieval (Gesetze-RAG)
  // Runs in parallel with hybridSearch — shares queryEmbedding to avoid double Ollama round-trip.
  // Score threshold 0.6: filters out law chunks for non-legal queries (vector similarity = relevance signal).
  const lawChunksPromise = (async (): Promise<Awaited<ReturnType<typeof searchLawChunks>>> => {
    try {
      const queryEmbedding = await queryEmbeddingPromise;
      if (!queryEmbedding) return [];
      return await searchLawChunks(queryEmbedding, { limit: 5, minScore: 0.6 });
    } catch (err) {
      console.error("[ki-chat] Law chunks search failed:", err);
      return [];
    }
  })();

  // Await all chains in parallel
  const [aktenKontextBlock, ragResult, [model, modelName, providerName], lawChunks] =
    await Promise.all([akteContextPromise, ragPromise, modelConfigPromise, lawChunksPromise]);
```

Then ADD the law_chunks system prompt block immediately after the existing QUELLEN block:

Find the line:
```typescript
    systemPrompt += "\n--- ENDE QUELLEN ---";
```

After it, add:
```typescript
  // Inject Gesetze-Quellen block (Chain D results) — only when law_chunks found with score >= 0.6
  if (lawChunks.length > 0) {
    systemPrompt += "\n\n--- GESETZE-QUELLEN (nicht amtlich) ---\n";
    lawChunks.forEach((norm, i) => {
      const standDate = new Date(norm.syncedAt).toLocaleDateString("de-DE", {
        day: "2-digit",
        month: "2-digit",
        year: "numeric",
      });
      systemPrompt += `\n[G${i + 1}] ${norm.gesetzKuerzel} ${norm.paragraphNr}: ${norm.titel}\n`;
      systemPrompt += `${norm.content}\n`;
      systemPrompt += `HINWEIS: nicht amtlich — Stand: ${standDate} | Quelle: ${norm.sourceUrl ?? "https://www.gesetze-im-internet.de/"}\n`;
    });
    systemPrompt += "\n--- ENDE GESETZE-QUELLEN ---";
    systemPrompt += "\n\nWenn du Normen zitierst, füge immer den 'nicht amtlich'-Hinweis und den Quellenlink hinzu.";
  }
```

CRITICAL: Preserve ALL other existing code exactly:
- SYSTEM_PROMPT_BASE constant (lines 27-99) — unchanged
- NO_SOURCES_INSTRUCTION, LOW_CONFIDENCE_INSTRUCTION constants — unchanged
- Chain A (akteContextPromise) — unchanged
- Token tracking + conversation save in onFinish — unchanged
- streamText call — unchanged
- toDataStreamResponse with X-Sources header — unchanged
  </action>
  <verify>npx tsc --noEmit 2>&1 | grep "ki-chat" | head -20; echo "TypeScript check done"</verify>
  <done>ki-chat/route.ts compiles without errors. queryEmbedding is generated once before Chain B and shared with Chain D via queryEmbeddingPromise. Promise.all awaits 4 chains (A, B, C, D). lawChunks.length > 0 guard prevents empty GESETZE-QUELLEN blocks. Every law chunk in the prompt carries 'nicht amtlich — Stand: [date] | Quelle: [url]'.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit 2>&1 | grep "ki-chat"` — zero TypeScript errors
- `grep -n "searchLawChunks\|lawChunksPromise\|GESETZE-QUELLEN\|nicht amtlich" src/app/api/ki-chat/route.ts` — all four terms present
- `grep -n "queryEmbeddingPromise" src/app/api/ki-chat/route.ts` — shared embedding Promise appears before Chain B and is awaited in Chain D
- `grep -c "generateQueryEmbedding" src/app/api/ki-chat/route.ts` — returns 1 (called exactly once)
</verification>

<success_criteria>
ki-chat generates queryEmbedding once and passes it to both hybridSearch and searchLawChunks in parallel. Legal queries (score >= 0.6 cosine similarity to law_chunks) receive a GESETZE-QUELLEN block in Helena's system prompt with "nicht amtlich — Stand: [date]" and canonical gesetze-im-internet.de Quellenlinks. Non-legal queries receive no law context (empty lawChunks array, block not injected). Chain D failure is silent — Helena still responds from hybridSearch results.
</success_criteria>

<output>
After completion, create `.planning/phases/14-gesetze-rag/14-03-SUMMARY.md` following the summary template.
</output>
