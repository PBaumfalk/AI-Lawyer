---
phase: 23.1-integration-wiring-fixes
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - prisma/schema.prisma
  - src/lib/helena/schriftsatz/pending-pipeline.ts
  - src/lib/helena/schriftsatz/answer-parser.ts
  - src/lib/helena/schriftsatz/index.ts
  - src/app/api/ki-chat/route.ts
autonomous: true
requirements: [ORCH-04]

must_haves:
  truths:
    - "Schriftsatz pipeline state (intentState, slotState, rueckfrage, round) persists in the database per-user-per-Akte with 7-day TTL"
    - "When a user sends a message in ki-chat and a pending Schriftsatz exists for that user+Akte, the message is classified as answer/correction/cancel/unrelated before routing"
    - "If the message is an answer, slot values are extracted via LLM, merged with existing state, and the pipeline resumes with updated userSlotValues"
    - "If the message is unrelated or cancel, the pending state is cleared and the message routes to normal RAG chat"
    - "Initial Schriftsatz requests from the chat UI are detected via isSchriftsatzIntent and routed to runSchriftsatzPipeline (not just RAG)"
    - "Rueckfrage responses include round counter and filled slot context for frontend display"
    - "Maximum 5 Rueckfrage rounds before fallback draft with PLATZHALTERs"
  artifacts:
    - path: "prisma/schema.prisma"
      provides: "PendingSchriftsatz model with @@unique([userId, akteId])"
      contains: "model PendingSchriftsatz"
    - path: "src/lib/helena/schriftsatz/pending-pipeline.ts"
      provides: "CRUD service for PendingSchriftsatz (save, load with TTL check, clear)"
      exports: ["savePendingPipeline", "loadPendingPipeline", "clearPendingPipeline"]
    - path: "src/lib/helena/schriftsatz/answer-parser.ts"
      provides: "LLM-based intent classification and slot extraction for pipeline answers"
      exports: ["classifyAnswerIntent", "extractSlotValues"]
    - path: "src/app/api/ki-chat/route.ts"
      provides: "Pending state check and Schriftsatz pipeline routing before RAG"
      contains: "loadPendingPipeline"
  key_links:
    - from: "src/app/api/ki-chat/route.ts"
      to: "src/lib/helena/schriftsatz/pending-pipeline.ts"
      via: "import { loadPendingPipeline, savePendingPipeline, clearPendingPipeline }"
      pattern: "loadPendingPipeline"
    - from: "src/app/api/ki-chat/route.ts"
      to: "src/lib/helena/schriftsatz/index.ts"
      via: "import { runSchriftsatzPipeline, isSchriftsatzIntent }"
      pattern: "runSchriftsatzPipeline"
    - from: "src/app/api/ki-chat/route.ts"
      to: "src/lib/helena/schriftsatz/answer-parser.ts"
      via: "import { classifyAnswerIntent, extractSlotValues }"
      pattern: "classifyAnswerIntent"
---

<objective>
Build the backend infrastructure for multi-turn Schriftsatz Rueckfragen: database model for pipeline state persistence, CRUD service, LLM answer parser, and ki-chat route integration.

Purpose: Enables the Schriftsatz pipeline to span multiple user messages. Currently, when the pipeline returns `needs_input`, the state is discarded. This plan persists the state and routes follow-up messages back into the pipeline.
Output: PendingSchriftsatz Prisma model + migration, pending-pipeline service, answer-parser module, and modified ki-chat route with Schriftsatz routing.
</objective>

<execution_context>
@/Users/patrickbaumfalk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/patrickbaumfalk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23.1-integration-wiring-fixes/23.1-CONTEXT.md
@.planning/phases/23.1-integration-wiring-fixes/23.1-RESEARCH.md

<interfaces>
<!-- Types from the Schriftsatz pipeline that the new modules must consume -->

From src/lib/helena/schriftsatz/schemas.ts:
```typescript
export interface IntentResult {
  klageart: string;
  stadium: string;
  gerichtszweig: string;
  rolle: "KLAEGER" | "BEKLAGTER";
  confidence: number;
  rechtsgebiet: string; // maps to Prisma Sachgebiet enum
}
```

From src/lib/helena/schriftsatz/slot-filler.ts:
```typescript
export type SlotValues = Record<string, string | number | boolean | null>;

export interface SlotFillResult {
  slots: SlotValues;
  missingRequired: SlotDefinition[];
  rueckfrage: string | null;
  vollstaendig: boolean;
}
```

From src/lib/helena/schriftsatz/index.ts:
```typescript
export interface SchriftsatzPipelineOptions {
  prisma: ExtendedPrismaClient;
  userId: string;
  userRole: UserRole;
  userName: string;
  akteId: string;
  message: string;
  userSlotValues?: Partial<SlotValues>;
  abortSignal?: AbortSignal;
  onStepUpdate?: (step: { stage: string; detail: string }) => void;
}

export interface SchriftsatzPipelineResult {
  status: "complete" | "needs_input" | "error";
  schriftsatz?: Schriftsatz;
  rueckfrage?: string;
  slotState?: SlotValues;
  intentState?: IntentResult;
  draftId?: string;
  warnungen: ErvWarnung[];
  retrieval_belege: RetrievalBeleg[];
  totalTokens: { prompt: number; completion: number };
}

export function isSchriftsatzIntent(message: string): boolean;
export function runSchriftsatzPipeline(options: SchriftsatzPipelineOptions): Promise<SchriftsatzPipelineResult>;
```

From src/lib/helena/draft-notification.ts:
```typescript
export async function notifyDraftCreated(draft: {
  id: string; akteId: string; userId: string; typ: string; titel: string;
}, akteAnwaltId: string | null): Promise<void>;
```

From src/lib/ai/provider.ts:
```typescript
export function getModel(): Promise<LanguageModel>;
```

From src/lib/db.ts:
```typescript
export type ExtendedPrismaClient = /* Prisma $extends client */;
export const prisma: ExtendedPrismaClient;
```

Current ki-chat/route.ts structure (key sections):
- Lines 174-196: POST handler, auth check, body parsing (messages, akteId, conversationId, crossAkte)
- Lines 204-215: Extract last user message as queryText
- Lines 222-228: shouldSkipRag check
- Lines 240-532: Parallel RAG chains (A through F)
- Lines 542-612: System prompt construction with sources
- Lines 641-729: streamText call with onFinish conversation save
- Lines 731-735: Return streaming response
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add PendingSchriftsatz model and run migration</name>
  <files>prisma/schema.prisma</files>
  <action>
  1. Add the `PendingSchriftsatz` model to `prisma/schema.prisma` AFTER the `HelenaMemory` model (around line 1995). Place it before the closing relations of the file.

  ```prisma
  /// Persists in-flight Schriftsatz pipeline state for multi-turn Rueckfragen.
  /// One pending pipeline per user per Akte. Expires after 7 days.
  model PendingSchriftsatz {
    id          String   @id @default(cuid())
    userId      String
    user        User     @relation(fields: [userId], references: [id])
    akteId      String
    akte        Akte     @relation(fields: [akteId], references: [id], onDelete: Cascade)

    // Pipeline state
    intentState Json     // Serialized IntentResult
    slotState   Json     // Serialized SlotValues (merged so far)
    rueckfrage  String   @db.Text  // Current question text for display
    round       Int      @default(1)  // Current round (1-5)
    message     String   @db.Text  // Original user message that triggered the pipeline

    // TTL
    expiresAt   DateTime
    createdAt   DateTime @default(now())
    updatedAt   DateTime @updatedAt

    @@unique([userId, akteId])
    @@index([userId])
    @@index([expiresAt])
    @@map("pending_schriftsaetze")
  }
  ```

  2. Add the reverse relation on the `User` model. Find `User` model and add:
     ```prisma
     pendingSchriftsaetze PendingSchriftsatz[]
     ```

  3. Add the reverse relation on the `Akte` model. Find `Akte` model and add:
     ```prisma
     pendingSchriftsaetze PendingSchriftsatz[]
     ```

  4. Run migration:
     ```bash
     npx prisma migrate dev --name add-pending-schriftsatz
     ```

  IMPORTANT: The `@@unique([userId, akteId])` constraint enforces one pending pipeline per user per Akte (user decision). The `onDelete: Cascade` on akteId ensures DSGVO compliance when an Akte is deleted.
  </action>
  <verify>
  Run: `npx prisma migrate dev --name add-pending-schriftsatz`
  Run: `npx prisma generate`
  Verify: `npx tsc --noEmit 2>&1 | head -5` shows no errors related to PendingSchriftsatz.
  Verify: `npx prisma db pull` and check `pending_schriftsaetze` table exists.
  </verify>
  <done>
  - PendingSchriftsatz model exists in schema.prisma with @@unique([userId, akteId])
  - Reverse relations on User and Akte models
  - Migration applied successfully
  - Prisma Client regenerated with PendingSchriftsatz type
  </done>
</task>

<task type="auto">
  <name>Task 2: Create pending-pipeline CRUD service + answer-parser + wire ki-chat route</name>
  <files>
    src/lib/helena/schriftsatz/pending-pipeline.ts
    src/lib/helena/schriftsatz/answer-parser.ts
    src/lib/helena/schriftsatz/index.ts
    src/app/api/ki-chat/route.ts
  </files>
  <action>
  **Part A: Create `src/lib/helena/schriftsatz/pending-pipeline.ts`**

  CRUD service for PendingSchriftsatz records. Three functions:

  ```typescript
  /**
   * PendingSchriftsatz CRUD service.
   *
   * Manages in-flight Schriftsatz pipeline state for multi-turn Rueckfragen.
   * State is per-user-per-Akte, database-persisted, with 7-day TTL.
   */

  import { prisma } from "@/lib/db";
  import type { IntentResult } from "./schemas";
  import type { SlotValues } from "./slot-filler";

  const TTL_DAYS = 7;
  const MAX_ROUNDS = 5;

  export { MAX_ROUNDS };

  export interface PendingPipelineState {
    id: string;
    userId: string;
    akteId: string;
    intentState: IntentResult;
    slotState: SlotValues;
    rueckfrage: string;
    round: number;
    message: string;
    expiresAt: Date;
  }

  /**
   * Save or update pending pipeline state (upsert).
   * Sets expiresAt to now + 7 days on every save.
   */
  export async function savePendingPipeline(params: {
    userId: string;
    akteId: string;
    intentState: IntentResult;
    slotState: SlotValues;
    rueckfrage: string;
    round: number;
    message: string;
  }): Promise<PendingPipelineState> {
    const expiresAt = new Date(Date.now() + TTL_DAYS * 24 * 60 * 60 * 1000);

    const record = await prisma.pendingSchriftsatz.upsert({
      where: {
        userId_akteId: {
          userId: params.userId,
          akteId: params.akteId,
        },
      },
      create: {
        userId: params.userId,
        akteId: params.akteId,
        intentState: params.intentState as any,
        slotState: params.slotState as any,
        rueckfrage: params.rueckfrage,
        round: params.round,
        message: params.message,
        expiresAt,
      },
      update: {
        intentState: params.intentState as any,
        slotState: params.slotState as any,
        rueckfrage: params.rueckfrage,
        round: params.round,
        expiresAt,
      },
    });

    return {
      id: record.id,
      userId: record.userId,
      akteId: record.akteId,
      intentState: record.intentState as unknown as IntentResult,
      slotState: record.slotState as unknown as SlotValues,
      rueckfrage: record.rueckfrage,
      round: record.round,
      message: record.message,
      expiresAt: record.expiresAt,
    };
  }

  /**
   * Load pending pipeline state for a user+Akte combination.
   * Returns null if no state exists or if expired (auto-deletes expired records).
   */
  export async function loadPendingPipeline(
    userId: string,
    akteId: string,
  ): Promise<PendingPipelineState | null> {
    const record = await prisma.pendingSchriftsatz.findUnique({
      where: { userId_akteId: { userId, akteId } },
    });

    if (!record) return null;

    // Lazy TTL check -- delete expired records on read
    if (record.expiresAt < new Date()) {
      await prisma.pendingSchriftsatz.delete({
        where: { id: record.id },
      }).catch(() => {}); // Swallow race condition
      return null;
    }

    return {
      id: record.id,
      userId: record.userId,
      akteId: record.akteId,
      intentState: record.intentState as unknown as IntentResult,
      slotState: record.slotState as unknown as SlotValues,
      rueckfrage: record.rueckfrage,
      round: record.round,
      message: record.message,
      expiresAt: record.expiresAt,
    };
  }

  /**
   * Clear (delete) pending pipeline state for a user+Akte.
   * Used on: cancel, unrelated message, pipeline completion.
   */
  export async function clearPendingPipeline(
    userId: string,
    akteId: string,
  ): Promise<void> {
    await prisma.pendingSchriftsatz.deleteMany({
      where: { userId, akteId },
    });
  }
  ```

  **Part B: Create `src/lib/helena/schriftsatz/answer-parser.ts`**

  LLM-based intent classification and slot extraction using AI SDK `generateObject`:

  ```typescript
  /**
   * Answer Parser -- LLM-based intent classification and slot extraction
   * for multi-turn Schriftsatz Rueckfragen.
   *
   * Two functions:
   * 1. classifyAnswerIntent -- is user message an answer, correction, cancel, or unrelated?
   * 2. extractSlotValues -- parse free-text answer into typed slot values
   */

  import { generateObject } from "ai";
  import { z } from "zod";
  import { getModel } from "@/lib/ai/provider";

  // ---------------------------------------------------------------------------
  // Intent Classification
  // ---------------------------------------------------------------------------

  const IntentClassificationSchema = z.object({
    type: z.enum(["answer", "correction", "cancel", "unrelated"]),
    correctedSlotKey: z.string().optional().describe(
      "For corrections: the UPPER_SNAKE_CASE slot key being corrected"
    ),
  });

  export type AnswerIntent = z.infer<typeof IntentClassificationSchema>;

  /**
   * Classify a user message in the context of a pending Rueckfrage.
   *
   * - "answer": User provides the requested information
   * - "correction": User corrects a previously given value
   * - "cancel": User wants to stop (e.g. "abbrechen", "stop", "vergiss es")
   * - "unrelated": Message has nothing to do with the Schriftsatz pipeline
   */
  export async function classifyAnswerIntent(
    userMessage: string,
    pendingRueckfrage: string,
    currentSlots: Record<string, unknown>,
  ): Promise<AnswerIntent> {
    // Fast keyword check for cancellation -- no LLM needed
    const lower = userMessage.toLowerCase().trim();
    if (
      lower === "abbrechen" ||
      lower === "stop" ||
      lower === "vergiss es" ||
      lower === "cancel" ||
      lower === "nein danke"
    ) {
      return { type: "cancel" };
    }

    const model = await getModel();

    const { object } = await generateObject({
      model,
      schema: IntentClassificationSchema,
      prompt: `Du bist ein Intent-Classifier fuer einen Schriftsatz-Workflow. Der Nutzer hat eine offene Rueckfrage:

Aktuelle Rueckfrage: "${pendingRueckfrage}"

Bisherige Angaben: ${JSON.stringify(currentSlots, null, 2)}

Nachricht des Nutzers: "${userMessage}"

Klassifiziere die Nachricht:
- "answer": Der Nutzer beantwortet die Rueckfrage oder liefert die angefragten Informationen
- "correction": Der Nutzer korrigiert eine fruehere Angabe (nenne den Slot-Key in correctedSlotKey, z.B. KLAEGER_NAME)
- "cancel": Der Nutzer moechte abbrechen (z.B. "abbrechen", "stop", "vergiss es", "lass mal")
- "unrelated": Der Nutzer stellt eine komplett andere Frage die nichts mit dem Schriftsatz zu tun hat`,
    });

    return object;
  }

  // ---------------------------------------------------------------------------
  // Slot Value Extraction
  // ---------------------------------------------------------------------------

  const SlotExtractionSchema = z.object({
    extractedValues: z.record(z.string()).describe(
      "Map of UPPER_SNAKE_CASE slot keys to extracted string values from the user message"
    ),
  });

  /**
   * Extract slot values from a free-text user answer.
   *
   * Given the pending Rueckfrage context and the user's response, use LLM
   * to extract structured slot values. Handles natural language dates
   * ("letzten Freitag"), names, amounts ("dreitausend"), etc.
   *
   * @param userMessage - The user's free-text answer
   * @param pendingRueckfrage - The question that was asked
   * @param expectedSlotKeys - The UPPER_SNAKE_CASE keys we expect values for
   * @param existingSlots - Already-known slot values (for correction detection)
   * @returns Record of extracted slot key -> value pairs
   */
  export async function extractSlotValues(
    userMessage: string,
    pendingRueckfrage: string,
    expectedSlotKeys: string[],
    existingSlots: Record<string, unknown>,
  ): Promise<Record<string, string>> {
    const model = await getModel();

    const { object } = await generateObject({
      model,
      schema: SlotExtractionSchema,
      prompt: `Du bist ein Slot-Extractor fuer einen juristischen Schriftsatz-Workflow.

Gestellte Frage: "${pendingRueckfrage}"

Erwartete Slot-Keys (UPPER_SNAKE_CASE): ${expectedSlotKeys.join(", ")}

Bisherige Angaben: ${JSON.stringify(existingSlots, null, 2)}

Antwort des Nutzers: "${userMessage}"

Extrahiere die Werte aus der Antwort und mappe sie auf die erwarteten Slot-Keys.
- Datumsangaben im Format TT.MM.JJJJ (z.B. "letzten Freitag" -> berechne das Datum)
- Geldbetraege als Zahl (z.B. "dreitausend" -> "3000")
- Wenn der Nutzer "weiss ich noch nicht" oder aehnliches sagt, setze den Wert auf "{{SLOT_KEY}}"
- Nur Keys aus der erwarteten Liste verwenden
- Wenn der Nutzer eine fruehere Angabe korrigiert, auch den korrigierten Slot-Key einbeziehen`,
    });

    return object.extractedValues;
  }
  ```

  **Part C: Add re-exports in `src/lib/helena/schriftsatz/index.ts`**

  At the bottom of the file, add these re-exports after the existing re-exports (after line 477):

  ```typescript
  // Multi-turn Rueckfragen
  export {
    savePendingPipeline,
    loadPendingPipeline,
    clearPendingPipeline,
    MAX_ROUNDS,
    type PendingPipelineState,
  } from "./pending-pipeline";
  export {
    classifyAnswerIntent,
    extractSlotValues,
    type AnswerIntent,
  } from "./answer-parser";
  ```

  **Part D: Modify `src/app/api/ki-chat/route.ts` to add Schriftsatz pipeline routing**

  This is the critical integration point. Add the pending state check + Schriftsatz routing AFTER body parsing and BEFORE the RAG pipeline chains.

  1. Add imports at the top of the file (after existing imports, around line 30):
     ```typescript
     import {
       isSchriftsatzIntent,
       runSchriftsatzPipeline,
       loadPendingPipeline,
       savePendingPipeline,
       clearPendingPipeline,
       MAX_ROUNDS,
     } from "@/lib/helena/schriftsatz";
     import {
       classifyAnswerIntent,
       extractSlotValues,
     } from "@/lib/helena/schriftsatz/answer-parser";
     ```

  2. After extracting `queryText` (around line 215) and BEFORE the `shouldSkipRag` check (line 222), insert a new section that handles the Schriftsatz pipeline routing. This section must be an early return -- if the pipeline handles the message, we return immediately without running the RAG chains.

     The logic flow (wrapped in a helper function inside the POST handler for clean early returns):

     ```typescript
     // ---------------------------------------------------------------------------
     // Schriftsatz Pipeline Routing (ORCH-04 multi-turn Rueckfragen)
     // Check BEFORE RAG pipeline: pending state takes priority
     // ---------------------------------------------------------------------------

     if (akteId) {
       // Check for pending Schriftsatz pipeline
       const pending = await loadPendingPipeline(userId, akteId);

       if (pending) {
         // Classify: is this message an answer, correction, cancel, or unrelated?
         const intent = await classifyAnswerIntent(
           queryText,
           pending.rueckfrage,
           pending.slotState,
         );

         if (intent.type === "cancel") {
           await clearPendingPipeline(userId, akteId);
           // Fall through to normal RAG chat -- do NOT return here
         } else if (intent.type === "unrelated") {
           await clearPendingPipeline(userId, akteId);
           // Fall through to normal RAG chat
         } else {
           // "answer" or "correction" -- extract slot values and resume pipeline
           console.log(`[ki-chat] Resuming Schriftsatz pipeline (round ${pending.round + 1}/${MAX_ROUNDS})`);

           // Determine expected slot keys from existing state
           const missingKeys = Object.entries(pending.slotState)
             .filter(([, v]) => v === null)
             .map(([k]) => k);

           // If correction, include the corrected slot key
           const expectedKeys = intent.type === "correction" && intent.correctedSlotKey
             ? [...new Set([...missingKeys, intent.correctedSlotKey])]
             : missingKeys;

           const extracted = await extractSlotValues(
             queryText,
             pending.rueckfrage,
             expectedKeys,
             pending.slotState,
           );

           // Merge extracted values into existing slot state
           const mergedSlotValues: Record<string, string | number | boolean | null> = {
             ...pending.slotState,
           };
           for (const [key, value] of Object.entries(extracted)) {
             if (value !== undefined && value !== null && value !== "") {
               mergedSlotValues[key] = value;
             }
           }

           const newRound = pending.round + 1;

           // Re-run the full pipeline with merged userSlotValues
           const session2 = await auth();
           const userRole = (session2?.user as any)?.role ?? "SACHBEARBEITER";
           const userName = session2?.user?.name ?? "Nutzer";

           const pipelineResult = await runSchriftsatzPipeline({
             prisma,
             userId,
             userRole,
             userName,
             akteId,
             message: pending.message, // Original message that started the pipeline
             userSlotValues: mergedSlotValues,
           });

           if (pipelineResult.status === "needs_input" && newRound < MAX_ROUNDS) {
             // Save updated state and return Rueckfrage
             await savePendingPipeline({
               userId,
               akteId,
               intentState: pipelineResult.intentState!,
               slotState: pipelineResult.slotState!,
               rueckfrage: pipelineResult.rueckfrage!,
               round: newRound,
               message: pending.message,
             });

             // Build response with round counter and slot context
             const filledSlots = Object.entries(pipelineResult.slotState ?? {})
               .filter(([, v]) => v !== null && !(typeof v === "string" && v.startsWith("{{")))
               .reduce((acc, [k, v]) => ({ ...acc, [k]: v }), {} as Record<string, unknown>);

             const responsePayload = {
               type: "schriftsatz_rueckfrage" as const,
               rueckfrage: pipelineResult.rueckfrage!,
               round: newRound,
               maxRounds: MAX_ROUNDS,
               filledSlots,
             };

             return new Response(JSON.stringify(responsePayload), {
               status: 200,
               headers: { "Content-Type": "application/json" },
             });
           }

           if (pipelineResult.status === "needs_input" && newRound >= MAX_ROUNDS) {
             // Round cap reached -- create draft with PLATZHALTERs
             // Clear pending state, then run pipeline one more time forcing completion
             await clearPendingPipeline(userId, akteId);

             // Build list of unresolved PLATZHALTERs
             const unresolved = Object.entries(pipelineResult.slotState ?? {})
               .filter(([, v]) => v === null || (typeof v === "string" && v.startsWith("{{")))
               .map(([k]) => k);

             const fallbackMessage = `Ich erstelle den Entwurf mit Platzhaltern fuer: ${unresolved.join(", ")}. Diese kannst du spaeter ergaenzen.`;

             // Force-complete the pipeline by filling missing slots with PLATZHALTERs
             const forcedSlotValues = { ...mergedSlotValues };
             for (const key of unresolved) {
               forcedSlotValues[key] = `{{${key}}}`;
             }

             const forcedResult = await runSchriftsatzPipeline({
               prisma,
               userId,
               userRole,
               userName,
               akteId,
               message: pending.message,
               userSlotValues: forcedSlotValues,
             });

             const responsePayload = {
               type: "schriftsatz_complete" as const,
               text: fallbackMessage,
               draftId: forcedResult.draftId ?? null,
               warnungen: forcedResult.warnungen,
             };

             return new Response(JSON.stringify(responsePayload), {
               status: 200,
               headers: { "Content-Type": "application/json" },
             });
           }

           // Pipeline complete or error -- clear pending state
           await clearPendingPipeline(userId, akteId);

           if (pipelineResult.status === "complete") {
             const responsePayload = {
               type: "schriftsatz_complete" as const,
               text: `Schriftsatz erstellt. Der Entwurf liegt zur Pruefung bereit.`,
               draftId: pipelineResult.draftId ?? null,
               warnungen: pipelineResult.warnungen,
             };

             return new Response(JSON.stringify(responsePayload), {
               status: 200,
               headers: { "Content-Type": "application/json" },
             });
           }

           // Error case
           const errorPayload = {
             type: "schriftsatz_error" as const,
             text: "Beim Erstellen des Schriftsatzes ist ein Fehler aufgetreten. Bitte versuche es erneut.",
             warnungen: pipelineResult.warnungen,
           };

           return new Response(JSON.stringify(errorPayload), {
             status: 200,
             headers: { "Content-Type": "application/json" },
           });
         }
       }

       // No pending state -- check for new Schriftsatz intent
       if (!pending && isSchriftsatzIntent(queryText)) {
         console.log(`[ki-chat] New Schriftsatz intent detected -- routing to pipeline`);

         const session2 = await auth();
         const userRole = (session2?.user as any)?.role ?? "SACHBEARBEITER";
         const userName = session2?.user?.name ?? "Nutzer";

         const pipelineResult = await runSchriftsatzPipeline({
           prisma,
           userId,
           userRole,
           userName,
           akteId,
           message: queryText,
         });

         if (pipelineResult.status === "needs_input") {
           // Save state for multi-turn
           await savePendingPipeline({
             userId,
             akteId,
             intentState: pipelineResult.intentState!,
             slotState: pipelineResult.slotState!,
             rueckfrage: pipelineResult.rueckfrage!,
             round: 1,
             message: queryText,
           });

           const filledSlots = Object.entries(pipelineResult.slotState ?? {})
             .filter(([, v]) => v !== null && !(typeof v === "string" && v.startsWith("{{")))
             .reduce((acc, [k, v]) => ({ ...acc, [k]: v }), {} as Record<string, unknown>);

           const responsePayload = {
             type: "schriftsatz_rueckfrage" as const,
             rueckfrage: pipelineResult.rueckfrage!,
             round: 1,
             maxRounds: MAX_ROUNDS,
             filledSlots,
           };

           return new Response(JSON.stringify(responsePayload), {
             status: 200,
             headers: { "Content-Type": "application/json" },
           });
         }

         if (pipelineResult.status === "complete") {
           const responsePayload = {
             type: "schriftsatz_complete" as const,
             text: `Schriftsatz erstellt. Der Entwurf liegt zur Pruefung bereit.`,
             draftId: pipelineResult.draftId ?? null,
             warnungen: pipelineResult.warnungen,
           };

           return new Response(JSON.stringify(responsePayload), {
             status: 200,
             headers: { "Content-Type": "application/json" },
           });
         }

         // Error -- fall through to normal RAG
         console.error("[ki-chat] Schriftsatz pipeline error, falling back to RAG");
       }
     }
     // If no Schriftsatz routing matched, continue to normal RAG pipeline below
     ```

  CRITICAL implementation notes:
  - The pending check + Schriftsatz routing MUST be an early-return section BEFORE the RAG chains. If the pipeline handles the message, return a JSON response (NOT a streaming response).
  - `auth()` is already called at line 177. Re-use `userId` from that. For `userRole` and `userName`, extract from the session or use fallback values.
  - The `type` field in JSON responses (`schriftsatz_rueckfrage`, `schriftsatz_complete`, `schriftsatz_error`) allows the frontend to distinguish pipeline responses from normal streamed chat responses.
  - When the user's message is classified as "cancel" or "unrelated", clear the pending state and fall through to the normal RAG pipeline (do NOT return early).
  - The `pending` variable should also handle the case where `isSchriftsatzIntent` detects a new request while a pending pipeline exists. Per user decision: warn "Du hast noch einen offenen Entwurf fuer X. Verwerfen und neu starten?" This check should be: if pending exists AND isSchriftsatzIntent(queryText), return a warning response with `type: "schriftsatz_conflict"`.

  Add this conflict detection inside the `if (pending)` block, before the classifyAnswerIntent call:
  ```typescript
  // Check for new Schriftsatz request while one is pending
  if (isSchriftsatzIntent(queryText)) {
    const responsePayload = {
      type: "schriftsatz_conflict" as const,
      text: `Du hast noch einen offenen Entwurf fuer einen Schriftsatz. Verwerfen und neu starten?`,
      pendingRueckfrage: pending.rueckfrage,
      round: pending.round,
      maxRounds: MAX_ROUNDS,
    };
    return new Response(JSON.stringify(responsePayload), {
      status: 200,
      headers: { "Content-Type": "application/json" },
    });
  }
  ```
  </action>
  <verify>
  Run: `npx tsc --noEmit 2>&1 | head -30` -- no type errors
  Run: `grep -n "loadPendingPipeline\|savePendingPipeline\|clearPendingPipeline" src/app/api/ki-chat/route.ts` -- verify all 3 functions used
  Run: `grep -n "isSchriftsatzIntent\|runSchriftsatzPipeline" src/app/api/ki-chat/route.ts` -- verify pipeline routing present
  Run: `grep -n "classifyAnswerIntent\|extractSlotValues" src/app/api/ki-chat/route.ts` -- verify answer parsing present
  </verify>
  <done>
  - `pending-pipeline.ts` exports savePendingPipeline, loadPendingPipeline, clearPendingPipeline with TTL check
  - `answer-parser.ts` exports classifyAnswerIntent (with fast keyword check for cancel) and extractSlotValues
  - `schriftsatz/index.ts` re-exports all new symbols
  - `ki-chat/route.ts` checks for pending pipeline state before RAG chains
  - `ki-chat/route.ts` routes new Schriftsatz intents to runSchriftsatzPipeline
  - `ki-chat/route.ts` handles answer/correction/cancel/unrelated/conflict flows
  - Pipeline JSON responses use `type` discriminator for frontend handling
  - Round cap at MAX_ROUNDS=5 creates fallback draft with PLATZHALTERs
  - TypeScript compiles without errors
  </done>
</task>

</tasks>

<verification>
1. `npx prisma migrate status` -- all migrations applied
2. `npx tsc --noEmit` -- no type errors across entire project
3. `grep -rn "PendingSchriftsatz" prisma/schema.prisma` -- model exists with @@unique([userId, akteId])
4. `grep -rn "pending-pipeline\|answer-parser" src/lib/helena/schriftsatz/index.ts` -- re-exports present
5. Manual trace through ki-chat route: user sends Schriftsatz request -> isSchriftsatzIntent detects -> runSchriftsatzPipeline called -> needs_input -> savePendingPipeline -> JSON response with type "schriftsatz_rueckfrage"
6. Manual trace: user sends answer -> loadPendingPipeline returns state -> classifyAnswerIntent returns "answer" -> extractSlotValues parses -> runSchriftsatzPipeline resumes with merged slots
</verification>

<success_criteria>
- PendingSchriftsatz model migrated and generating Prisma types
- pending-pipeline.ts provides save/load/clear with lazy TTL cleanup
- answer-parser.ts provides LLM-based intent classification and slot extraction
- ki-chat route has Schriftsatz pipeline routing as an early-return before RAG chains
- JSON response format uses `type` discriminator (schriftsatz_rueckfrage, schriftsatz_complete, schriftsatz_error, schriftsatz_conflict)
- Round cap at 5 creates fallback draft with PLATZHALTERs
- Cancel and unrelated messages clear pending state and fall through to normal RAG
- No type errors
</success_criteria>

<output>
After completion, create `.planning/phases/23.1-integration-wiring-fixes/23.1-02-SUMMARY.md`
</output>
