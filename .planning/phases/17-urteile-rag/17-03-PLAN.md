---
phase: 17-urteile-rag
plan: "03"
type: execute
wave: 2
depends_on: ["17-01"]
files_modified:
  - src/app/api/ki-chat/route.ts
autonomous: true
requirements: [URTEIL-04]

must_haves:
  truths:
    - "Helena's responses include Urteil citations with Gericht + Aktenzeichen + Datum + Quellenlink — all fields sourced from urteil_chunks, never LLM-generated"
    - "Chain E runs in parallel with Chain D (law_chunks) — both resolved in the same Promise.all() call"
    - "When urteil_chunks returns 0 results, no URTEILE-QUELLEN block appears in the system prompt — Helena responds without Urteile gracefully"
    - "Chain E failure (exception) returns [] and does NOT crash ki-chat — non-fatal by design"
    - "The system prompt contains explicit instruction: 'Wenn kein Aktenzeichen in den URTEILE-QUELLEN steht, zitiere das Urteil NICHT und erfinde kein AZ'"
  artifacts:
    - path: "src/app/api/ki-chat/route.ts"
      provides: "Chain E parallel Urteil retrieval + URTEILE-QUELLEN system prompt injection"
      contains: "searchUrteilChunks"
  key_links:
    - from: "src/app/api/ki-chat/route.ts"
      to: "src/lib/urteile/ingestion.ts"
      via: "searchUrteilChunks() imported and called in Chain E"
      pattern: "searchUrteilChunks"
    - from: "Chain E urteilChunksPromise"
      to: "Promise.all([...lawChunksPromise])"
      via: "added to existing Promise.all() alongside Chain D"
      pattern: "urteilChunksPromise"
    - from: "URTEILE-QUELLEN block"
      to: "urteil_chunks.aktenzeichen + gericht + datum + sourceUrl"
      via: "all citation fields read from DB result, never composed by LLM"
      pattern: "URTEILE-QUELLEN"
---

<objective>
Add ki-chat Chain E: parallel Urteil retrieval from urteil_chunks and structured citation injection into the system prompt.

Purpose: This is the user-facing delivery of URTEIL-04 — Helena cites real German court decisions with verified metadata (Gericht + AZ + Datum + Quellenlink) from the database, eliminating hallucinated case numbers.

Output: A single modified route.ts file. Chain E runs alongside Chain D in the existing Promise.all(), injects a URTEILE-QUELLEN block after GESETZE-QUELLEN, and instructs Helena to never fabricate AZ values.
</objective>

<execution_context>
@/Users/patrickbaumfalk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/patrickbaumfalk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/17-urteile-rag/17-RESEARCH.md
@.planning/phases/17-urteile-rag/17-01-SUMMARY.md

<interfaces>
<!-- Key types and contracts the executor needs — extracted from codebase. -->

From src/lib/urteile/ingestion.ts (created in Plan 01):
```typescript
export interface UrteilChunkResult {
  id: string;
  aktenzeichen: string;
  gericht: string;
  datum: Date;
  rechtsgebiet: string | null;
  content: string;
  sourceUrl: string;
  score: number;
}
export async function searchUrteilChunks(
  queryEmbedding: number[],
  opts?: { limit?: number; minScore?: number }
): Promise<UrteilChunkResult[]>
// Already filters out empty aktenzeichen — URTEIL-04 safe
```

From src/app/api/ki-chat/route.ts — CURRENT structure (key lines verified):
```typescript
// Line 28: import { searchLawChunks } from "@/lib/gesetze/ingestion";
// Line 233: Chain D comment: "//   Chain D: Law chunks (pgvector) — only if !skipRag"
// Lines 474-488: Chain D lawChunksPromise definition (skipRag guard + async IIFE)
// Lines 491-492: Promise.all resolves all chains:
//   const [{ aktenKontextBlock, pinnedNormenBlock }, ragResult, [model, modelName, providerName], lawChunks] =
//     await Promise.all([akteContextPromise, ragPromise, modelConfigPromise, lawChunksPromise]);
// Lines 525-540: GESETZE-QUELLEN block injection — Chain E's block goes AFTER this
```

Existing Chain D structure (mirror exactly for Chain E):
```typescript
const lawChunksPromise = skipRag
  ? Promise.resolve([] as Awaited<ReturnType<typeof searchLawChunks>>)
  : (async (): Promise<Awaited<ReturnType<typeof searchLawChunks>>> => {
      const tD = Date.now();
      try {
        const queryEmbedding = await queryEmbeddingPromise;
        if (!queryEmbedding) return [];
        const results = await searchLawChunks(queryEmbedding, { limit: 5, minScore: 0.6 });
        console.log(`[ki-chat] Chain D (law_chunks) took ${Date.now() - tD}ms, ${results.length} results`);
        return results;
      } catch (err) {
        console.error("[ki-chat] Law chunks search failed:", err);
        return [];
      }
    })();
```

Existing GESETZE-QUELLEN injection (lines 525-540) — Chain E injection goes AFTER line 540:
```typescript
if (lawChunks.length > 0) {
  systemPrompt += "\n\n--- GESETZE-QUELLEN (nicht amtlich) ---\n";
  // ... norm formatting ...
  systemPrompt += "\n--- ENDE GESETZE-QUELLEN ---";
  systemPrompt += "\n\nWenn du Normen zitierst, füge immer den 'nicht amtlich'-Hinweis und den Quellenlink hinzu.";
}
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Chain E and URTEILE-QUELLEN injection to ki-chat route</name>
  <files>src/app/api/ki-chat/route.ts</files>
  <action>
Read `src/app/api/ki-chat/route.ts` in full before making any changes. Make 4 targeted insertions — do NOT modify any existing logic.

**Insertion 1 — Import (at top of file, alongside searchLawChunks import):**
```typescript
import { searchUrteilChunks, type UrteilChunkResult } from "@/lib/urteile/ingestion";
```

**Insertion 2 — Chain E comment update (add to existing chain comment block, around line 233-234):**
Add to the comment list:
```
//   Chain E: Urteil chunks (pgvector) — only if !skipRag
```

**Insertion 3 — Chain E promise definition (add IMMEDIATELY after the lawChunksPromise block, before the Promise.all call):**
```typescript
// Chain E: urteil_chunks retrieval (Urteile-RAG)
// Non-fatal — error returns [] and Helena responds without Urteile.
const urteilChunksPromise = skipRag
  ? Promise.resolve([] as UrteilChunkResult[])
  : (async (): Promise<UrteilChunkResult[]> => {
      const tE = Date.now();
      try {
        const queryEmbedding = await queryEmbeddingPromise;
        if (!queryEmbedding) return [];
        const results = await searchUrteilChunks(queryEmbedding, { limit: 5, minScore: 0.6 });
        console.log(`[ki-chat] Chain E (urteil_chunks) took ${Date.now() - tE}ms, ${results.length} results`);
        return results;
      } catch (err) {
        console.error("[ki-chat] Urteil chunks search failed:", err);
        return [];
      }
    })();
```

**Insertion 4 — Update Promise.all to include Chain E:**

The current Promise.all (lines 491-492) resolves 4 promises:
```typescript
const [{ aktenKontextBlock, pinnedNormenBlock }, ragResult, [model, modelName, providerName], lawChunks] =
  await Promise.all([akteContextPromise, ragPromise, modelConfigPromise, lawChunksPromise]);
```

Replace with (add urteilChunksPromise as 5th element):
```typescript
const [{ aktenKontextBlock, pinnedNormenBlock }, ragResult, [model, modelName, providerName], lawChunks, urteilChunks] =
  await Promise.all([akteContextPromise, ragPromise, modelConfigPromise, lawChunksPromise, urteilChunksPromise]);
```

**Insertion 5 — URTEILE-QUELLEN system prompt injection (add AFTER the GESETZE-QUELLEN block, before the "Stream the AI response" comment):**

```typescript
// Inject Urteile-Quellen block (Chain E results) — only when urteil_chunks found with score >= 0.6
// URTEIL-04: All citation fields (gericht, aktenzeichen, datum, sourceUrl) come from DB — never LLM-generated.
if (urteilChunks.length > 0) {
  systemPrompt += "\n\n--- URTEILE-QUELLEN ---\n";
  urteilChunks.forEach((u, i) => {
    const datumStr = new Date(u.datum).toLocaleDateString("de-DE", {
      day: "2-digit",
      month: "2-digit",
      year: "numeric",
    });
    systemPrompt += `\n[U${i + 1}] ${u.gericht} ${u.aktenzeichen} vom ${datumStr}\n`;
    systemPrompt += `${u.content}\n`;
    systemPrompt += `Quelle: ${u.sourceUrl}\n`;
  });
  systemPrompt += "\n--- ENDE URTEILE-QUELLEN ---";
  systemPrompt += "\n\nWenn du Urteile zitierst: immer Gericht + Aktenzeichen + Datum + Quellenlink angeben.";
  systemPrompt += " Wenn kein Aktenzeichen in den URTEILE-QUELLEN steht, zitiere das Urteil NICHT und erfinde kein AZ.";
}
```

**Positioning rules:**
- Chain E promise: after lawChunksPromise block, before Promise.all
- URTEILE-QUELLEN block: after GESETZE-QUELLEN block, before "// Stream the AI response" comment section
- Import: top of file, with other lib imports

**Do NOT modify** any existing Promise.all arguments — only ADD urteilChunksPromise at the end and add urteilChunks to destructuring. Do NOT change ragPromise, lawChunksPromise, akteContextPromise, or modelConfigPromise.
  </action>
  <verify>
    <automated>cd /Users/patrickbaumfalk/Projekte/AI-Lawyer && npx tsc --noEmit 2>&1 | head -20</automated>
  </verify>
  <done>
    - `grep "searchUrteilChunks" src/app/api/ki-chat/route.ts` shows import AND usage
    - `grep "urteilChunks" src/app/api/ki-chat/route.ts` shows Chain E promise + Promise.all + injection block
    - `grep "URTEILE-QUELLEN" src/app/api/ki-chat/route.ts` shows both the block header and the instruction text
    - `grep "erfinde kein AZ" src/app/api/ki-chat/route.ts` confirms URTEIL-04 anti-hallucination instruction
    - `npx tsc --noEmit` exits 0 — zero errors
  </done>
</task>

</tasks>

<verification>
After the task:
1. `npx tsc --noEmit` exits 0
2. `grep -n "urteilChunks\|URTEILE\|searchUrteilChunks" src/app/api/ki-chat/route.ts` shows:
   - Import line at top
   - Chain E promise definition
   - 5th element in Promise.all (both call and destructure)
   - URTEILE-QUELLEN injection block
   - Anti-hallucination AZ instruction
3. `grep -n "Promise.all" src/app/api/ki-chat/route.ts` shows urteilChunksPromise as 5th argument
4. Existing chains (A, B, C, D) are unchanged — verify by checking ragResult and lawChunks still destructure in positions 2 and 4
</verification>

<success_criteria>
- Chain E fetches top-5 urteil_chunks (minScore 0.6) in parallel with Chain D
- Helena's system prompt gains a URTEILE-QUELLEN block with Gericht + AZ + Datum + Quellenlink per Urteil
- System prompt contains explicit instruction never to fabricate AZ values
- Zero TypeScript errors — ki-chat route compiles clean
- Chain E failure is non-fatal — returns [] without crashing the request
</success_criteria>

<output>
After completion, create `.planning/phases/17-urteile-rag/17-03-SUMMARY.md`
</output>
