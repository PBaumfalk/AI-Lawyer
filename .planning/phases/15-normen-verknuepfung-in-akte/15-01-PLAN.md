---
phase: 15-normen-verknuepfung-in-akte
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/api/akten/[id]/normen/route.ts
  - src/app/api/akten/[id]/normen/search/route.ts
  - src/app/api/akten/[id]/normen/[normId]/route.ts
autonomous: true
requirements:
  - GESETZ-04

must_haves:
  truths:
    - "GET /api/akten/[id]/normen returns list of pinned normen (newest first)"
    - "POST /api/akten/[id]/normen adds a norm, returns 201 with created AkteNorm; returns 409 if already pinned"
    - "DELETE /api/akten/[id]/normen/[normId] removes a norm, returns 204"
    - "GET /api/akten/[id]/normen/search?q=... returns up to 20 law_chunks matching ILIKE on gesetzKuerzel, paragraphNr, or titel"
    - "All routes enforce requireAkteAccess RBAC — unauthenticated returns 401/403"
    - "Mutations are logged via logAuditEvent"
  artifacts:
    - path: "src/app/api/akten/[id]/normen/route.ts"
      provides: "GET (list) + POST (add) for AkteNorm"
      exports: ["GET", "POST"]
    - path: "src/app/api/akten/[id]/normen/search/route.ts"
      provides: "ILIKE text search on law_chunks for the search modal"
      exports: ["GET"]
    - path: "src/app/api/akten/[id]/normen/[normId]/route.ts"
      provides: "DELETE for removing a pinned norm"
      exports: ["DELETE"]
  key_links:
    - from: "src/app/api/akten/[id]/normen/route.ts"
      to: "prisma.akteNorm"
      via: "findMany / create"
      pattern: "prisma\\.akteNorm\\.(findMany|create)"
    - from: "src/app/api/akten/[id]/normen/search/route.ts"
      to: "law_chunks"
      via: "prisma.$queryRaw ILIKE"
      pattern: "queryRaw"
    - from: "src/app/api/akten/[id]/normen/[normId]/route.ts"
      to: "prisma.akteNorm"
      via: "delete"
      pattern: "prisma\\.akteNorm\\.delete"
---

<objective>
Create the three API route handlers that power the AkteNorm feature: list/add pinned normen, text-search law_chunks for the modal, and remove a pinned norm.

Purpose: The UI components in Plan 03 call these endpoints. The ki-chat extension in Plan 02 reads from the same DB table directly. All routes enforce existing RBAC middleware and audit logging — zero new security surface area.
Output: Three Next.js route files with full CRUD for AkteNorm.
</objective>

<execution_context>
@/Users/patrickbaumfalk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/patrickbaumfalk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md

<interfaces>
<!-- Key types and contracts. Extracted directly from codebase. -->

From prisma/schema.prisma (AkteNorm model — confirmed from Phase 12 migration):
```prisma
model AkteNorm {
  id             String   @id @default(cuid())
  akteId         String
  gesetzKuerzel  String
  paragraphNr    String
  anmerkung      String?
  addedById      String
  createdAt      DateTime @default(now())

  akte           Akte     @relation(fields: [akteId], references: [id], onDelete: Cascade)
  addedBy        User     @relation(fields: [addedById], references: [id])

  @@unique([akteId, gesetzKuerzel, paragraphNr])
  @@index([akteId])
  @@map("akte_normen")
}
```

From prisma/schema.prisma (LawChunk model — confirmed):
```prisma
model LawChunk {
  id             String               @id @default(cuid())
  gesetzKuerzel  String
  paragraphNr    String
  titel          String
  content        String
  parentContent  String?
  embedding      Unsupported("vector(1024)")
  modelVersion   String
  syncedAt       DateTime
  sourceUrl      String?
  // @@index([gesetzKuerzel]), @@index([paragraphNr])
}
```

From src/lib/rbac.ts (requireAkteAccess signature):
```typescript
export async function requireAkteAccess(
  akteId: string,
  opts?: { requireEdit?: boolean }
): Promise<{ error: Response } | { session: Session; akte: Akte }>
```

From src/lib/audit.ts (logAuditEvent signature):
```typescript
export async function logAuditEvent({
  userId,
  akteId,
  aktion,
  details,
}: {
  userId: string;
  akteId?: string;
  aktion: string;
  details?: Record<string, unknown>;
}): Promise<void>
```

Pattern reference: src/app/api/akten/[id]/beteiligte/route.ts
- POST returns 201, DELETE returns 204
- requireAkteAccess for GET (read) and requireAkteAccess({ requireEdit: true }) for mutations
- logAuditEvent after every mutation
- Zod validation on POST body
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: AkteNorm list + add route (GET + POST)</name>
  <files>src/app/api/akten/[id]/normen/route.ts</files>
  <action>
Create a Next.js route handler at `src/app/api/akten/[id]/normen/route.ts` with GET and POST handlers.

**GET /api/akten/[id]/normen:**
- Call `requireAkteAccess(akteId)` — return error if unauthorized
- `prisma.akteNorm.findMany({ where: { akteId }, include: { addedBy: { select: { name: true } } }, orderBy: { createdAt: "desc" } })`
- Return `NextResponse.json(normen)` with 200

**POST /api/akten/[id]/normen:**
- Call `requireAkteAccess(akteId, { requireEdit: true })`
- Zod schema: `{ gesetzKuerzel: z.string().min(1), paragraphNr: z.string().min(1), anmerkung: z.string().optional() }`
- Verify the law_chunk exists: `prisma.lawChunk.findFirst({ where: { gesetzKuerzel, paragraphNr } })` — return 404 if not found
- Check for duplicate: `prisma.akteNorm.findUnique({ where: { akteId_gesetzKuerzel_paragraphNr: { akteId, gesetzKuerzel, paragraphNr } } })` — return 409 with `{ error: "Diese Norm ist bereits an die Akte verknüpft" }` if found
- Create: `prisma.akteNorm.create({ data: { akteId, gesetzKuerzel, paragraphNr, anmerkung: anmerkung ?? null, addedById: session.user.id }, include: { addedBy: { select: { name: true } } } })`
- `logAuditEvent({ userId: session.user.id, akteId, aktion: "NORM_VERKNUEPFT", details: { gesetzKuerzel, paragraphNr } })`
- Return `NextResponse.json(norm, { status: 201 })`

**Imports to use:**
```typescript
import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/db";
import { requireAkteAccess } from "@/lib/rbac";
import { logAuditEvent } from "@/lib/audit";
import { z } from "zod";
```
  </action>
  <verify>curl -s -o /dev/null -w "%{http_code}" http://localhost:3000/api/akten/nonexistent/normen returns 401 or 404 (not 500)</verify>
  <done>GET returns array, POST returns 201 on valid input, 409 on duplicate, 404 if law_chunk not found, all with proper RBAC enforcement</done>
</task>

<task type="auto">
  <name>Task 2: Norm search route + norm delete route</name>
  <files>
    src/app/api/akten/[id]/normen/search/route.ts
    src/app/api/akten/[id]/normen/[normId]/route.ts
  </files>
  <action>
**Search route** — `src/app/api/akten/[id]/normen/search/route.ts`:

Create GET handler for live search in the add-norm modal.

- Call `requireAkteAccess(akteId)` — return error if unauthorized
- Read `q` from `request.nextUrl.searchParams.get("q")?.trim() ?? ""`
- If `q.length < 2` return `NextResponse.json([])`
- Use `prisma.$queryRaw` for ILIKE search on law_chunks (CRITICAL: safe parameter binding):
```typescript
const results = await prisma.$queryRaw<Array<{
  id: string;
  gesetzKuerzel: string;
  paragraphNr: string;
  titel: string;
  content: string;
  sourceUrl: string | null;
  syncedAt: Date;
}>>`
  SELECT id, "gesetzKuerzel", "paragraphNr", titel,
         LEFT(content, 300) AS content,
         "sourceUrl", "syncedAt"
  FROM law_chunks
  WHERE
    "gesetzKuerzel" ILIKE ${'%' + q + '%'}
    OR "paragraphNr" ILIKE ${'%' + q + '%'}
    OR titel ILIKE ${'%' + q + '%'}
  ORDER BY "gesetzKuerzel" ASC, "paragraphNr" ASC
  LIMIT 20
`;
```
Note: `LEFT(content, 300)` limits payload size. Full content only needed in chip detail view.
Return `NextResponse.json(results)`.

**Delete route** — `src/app/api/akten/[id]/normen/[normId]/route.ts`:

Create DELETE handler.

- `const { id: akteId, normId } = await params`
- Call `requireAkteAccess(akteId, { requireEdit: true })`
- `prisma.akteNorm.findUnique({ where: { id: normId } })` — return 404 if not found or `norm.akteId !== akteId`
- `prisma.akteNorm.delete({ where: { id: normId } })`
- `logAuditEvent({ userId: session.user.id, akteId, aktion: "NORM_ENTFERNT", details: { gesetzKuerzel: norm.gesetzKuerzel, paragraphNr: norm.paragraphNr } })`
- Return `new NextResponse(null, { status: 204 })`
  </action>
  <verify>TypeScript compiles without errors: `npx tsc --noEmit 2>&1 | grep -E "normen" | head -20`</verify>
  <done>Search returns up to 20 law_chunk rows matching ILIKE query. Delete returns 204. Both enforce RBAC. TypeScript errors: 0.</done>
</task>

</tasks>

<verification>
```bash
# TypeScript check on new route files
npx tsc --noEmit 2>&1 | grep -E "normen" | head -20

# Verify route files exist
ls src/app/api/akten/*/normen/route.ts
ls src/app/api/akten/*/normen/search/route.ts
ls "src/app/api/akten/*/normen/[normId]/route.ts"
```
</verification>

<success_criteria>
- 3 route files created, TypeScript error count: 0
- GET /normen returns 200 with array
- POST /normen returns 201, 404, or 409 depending on input
- GET /normen/search?q=BGB returns array of matching law_chunks
- DELETE /normen/[normId] returns 204
- All routes return 401/403 for unauthenticated requests
</success_criteria>

<output>
After completion, create `.planning/phases/15-normen-verknuepfung-in-akte/15-01-SUMMARY.md`
</output>
