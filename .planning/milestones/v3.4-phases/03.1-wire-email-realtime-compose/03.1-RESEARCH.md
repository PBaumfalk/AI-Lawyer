# Phase 3.1: Wire Email Real-Time + Compose Integration - Research

**Researched:** 2026-02-24
**Domain:** Socket.IO room wiring, Next.js API routes, React context providers
**Confidence:** HIGH

## Summary

Phase 3.1 is a pure wiring phase that closes three integration gaps (INT-001, INT-002, INT-003) identified in the v3.4 milestone audit. All the building blocks already exist in the codebase -- IMAP connection-manager emits `email:folder-update` via Socket.IO Redis emitter, `signature.ts` has a `getSignatureForUser()` function, and `compose-manager.tsx` defines a complete `ComposeManager` provider with `useComposeManager()` hook. The problem is that these pieces are not connected to each other: the Socket.IO room `mailbox:{kontoId}` is never joined by any client, the `/api/email-signature` API route does not exist (404s silently), and `ComposeManager` is defined but never mounted in any layout.

No new libraries are needed. No schema changes are needed. Every fix touches 1-2 files and involves adding small amounts of glue code between existing modules.

**Primary recommendation:** Wire existing code -- add `join:mailbox` handling in `rooms.ts`, bridge socket events to `folder-tree.tsx`, create a thin API route for email signatures, and mount `ComposeManager` in the email layout.

<phase_requirements>
## Phase Requirements

| ID | Description | Research Support |
|----|-------------|-----------------|
| REQ-IF-003 | Custom server.ts + Socket.IO WebSocket on same port | Socket.IO server/rooms infrastructure exists (Phase 1). Gap: `mailbox:{kontoId}` room join handler missing in `rooms.ts`. Fix: add `join:mailbox` / `leave:mailbox` event handlers. |
| REQ-EM-001 | IMAP-Sync with Real-Time (IMAP IDLE) for incoming emails | IMAP IDLE + sync works correctly (`connection-manager.ts`). Socket.IO emit to `mailbox:{kontoId}` works server-side. Gap: browser clients never join that room. Fix: client emits `join:mailbox` when viewing email. |
| REQ-EM-003 | Inbox page (List, Pagination, Filter) | Inbox UI fully built (`inbox-layout.tsx`, `email-list.tsx`, `folder-tree.tsx`). Gap: `folder-tree.tsx` listens on `window` CustomEvent that nobody dispatches. Fix: bridge socket `email:folder-update` event to folder-tree state update. |
| REQ-EM-006 | Compose-View (An, CC, BCC, Betreff, Rich-Text, Akte, Attachments from DMS) | Compose UI complete (`compose-popup.tsx`, `compose-editor.tsx`). Two gaps: (1) `/api/email-signature` route missing, compose fetches it but gets 404; (2) `ComposeManager` provider never mounted so `useComposeManager()` returns default no-ops. |
</phase_requirements>

## Standard Stack

### Core

No new libraries needed. All existing:

| Library | Version | Purpose | Already Installed |
|---------|---------|---------|-------------------|
| socket.io | 4.x | Server-side WebSocket rooms | YES |
| socket.io-client | 4.x | Client-side socket connection | YES |
| @socket.io/redis-emitter | 5.x | Worker-to-browser emit via Redis pub/sub | YES |
| @socket.io/redis-adapter | 8.x | Cross-process Socket.IO adapter | YES |
| next | 14+ | API route for email-signature | YES |
| prisma | 5.x | DB queries for signature template + user | YES |

### Supporting

No supporting libraries needed.

### Alternatives Considered

None -- this is pure wiring of existing code.

**Installation:**
```bash
# No installation needed -- all dependencies already present
```

## Architecture Patterns

### Recommended Project Structure

No new directories. All changes go into existing files:

```
src/
├── lib/socket/rooms.ts              # ADD: join:mailbox / leave:mailbox handlers
├── components/socket-provider.tsx    # EXISTING: provides useSocket() hook
├── components/email/
│   ├── folder-tree.tsx              # MODIFY: subscribe to socket email:folder-update
│   ├── inbox-layout.tsx             # MODIFY: emit join:mailbox on mount with kontoId
│   ├── compose-manager.tsx          # EXISTING: no changes needed
│   └── compose-popup.tsx            # EXISTING: already fetches /api/email-signature
├── app/
│   ├── (dashboard)/email/layout.tsx # MODIFY: wrap children with <ComposeManager>
│   └── api/email-signature/route.ts # CREATE: thin GET handler calling getSignatureForUser()
└── lib/email/signature.ts           # EXISTING: getSignatureForUser() ready to use
```

### Pattern 1: Socket.IO Room Join/Leave Lifecycle

**What:** Clients emit `join:mailbox` when viewing an email mailbox and `leave:mailbox` when navigating away. Server-side `rooms.ts` handles these events identically to the existing `join:akte`/`leave:akte` pattern.

**When to use:** Any time the browser needs real-time updates scoped to a specific resource.

**Example (server-side `rooms.ts`):**
```typescript
// Follows exact pattern of existing join:akte / leave:akte
socket.on("join:mailbox", (kontoId: string) => {
  if (!kontoId || typeof kontoId !== "string") return;
  const mailboxRoom = `mailbox:${kontoId}`;
  socket.join(mailboxRoom);
  log.debug({ userId, kontoId }, "Joined mailbox room");
});

socket.on("leave:mailbox", (kontoId: string) => {
  if (!kontoId || typeof kontoId !== "string") return;
  const mailboxRoom = `mailbox:${kontoId}`;
  socket.leave(mailboxRoom);
  log.debug({ userId, kontoId }, "Left mailbox room");
});
```

### Pattern 2: Socket Event Bridge to Component State

**What:** The `folder-tree.tsx` currently listens on `window` CustomEvent `"email:folder-update"` (which nobody dispatches). The correct pattern is to use the `useSocket()` hook to listen on the actual Socket.IO event and update React state directly -- or dispatch the CustomEvent that folder-tree already expects.

**When to use:** When a component needs to react to real-time server-side events.

**Example (bridge approach -- simpler, fewer changes):**
```typescript
// In inbox-layout.tsx or a dedicated hook
const { socket } = useSocket();

useEffect(() => {
  if (!socket) return;

  const handleFolderUpdate = (data: { kontoId: string; ordnerId: string; ungeleseneAnzahl: number }) => {
    // Dispatch the CustomEvent that folder-tree already listens for
    window.dispatchEvent(
      new CustomEvent("email:folder-update", { detail: data })
    );
  };

  socket.on("email:folder-update", handleFolderUpdate);
  return () => { socket.off("email:folder-update", handleFolderUpdate); };
}, [socket]);
```

**Alternative (direct approach -- cleaner but more changes):**
Replace the `window` CustomEvent listener in `folder-tree.tsx` with direct `useSocket()` subscription. This is cleaner but requires modifying the component's props or passing socket context. The bridge approach is recommended for this phase because it minimizes changes.

### Pattern 3: Thin API Route Delegating to Service

**What:** Create `src/app/api/email-signature/route.ts` as a thin GET endpoint that validates auth, extracts `kontoId` from query params, calls `getSignatureForUser()`, and returns JSON.

**When to use:** Standard pattern throughout this codebase for all API routes.

**Example:**
```typescript
import { NextRequest, NextResponse } from "next/server";
import { auth } from "@/lib/auth";
import { getSignatureForUser } from "@/lib/email/signature";

export async function GET(req: NextRequest) {
  const session = await auth();
  if (!session?.user?.id) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  const kontoId = req.nextUrl.searchParams.get("kontoId");
  if (!kontoId) {
    return NextResponse.json({ error: "kontoId required" }, { status: 400 });
  }

  const signature = await getSignatureForUser(session.user.id, kontoId);
  return NextResponse.json({ signature });
}
```

### Pattern 4: Context Provider in Layout

**What:** Mount `<ComposeManager>` in the email layout so all email pages can use `useComposeManager()`.

**When to use:** When a provider needs to be available to all pages in a route group.

**Example:**
```typescript
// src/app/(dashboard)/email/layout.tsx
import { ComposeManager } from "@/components/email/compose-manager";

export default function EmailLayout({ children }: { children: React.ReactNode }) {
  return (
    <ComposeManager>
      <div className="h-[calc(100vh-4rem)] -m-6 overflow-hidden">
        {children}
      </div>
    </ComposeManager>
  );
}
```

### Anti-Patterns to Avoid

- **Polling instead of socket events:** Do NOT add a setInterval to poll for folder changes. The Socket.IO infrastructure already exists; just wire it.
- **Duplicating signature rendering logic:** The send-processor has its own inline `renderSignature()` function. The API route MUST use the shared `getSignatureForUser()` from `lib/email/signature.ts` -- do not create a third copy.
- **Mounting ComposeManager at dashboard level:** The ComposeManager renders popup overlays that are email-specific. Mounting it at the dashboard layout level would cause it to render even on non-email pages. Mount it in the email layout only.
- **Forgetting leave:mailbox on kontoId change:** If the user switches mailboxes, the old room must be left before joining the new one. Use a cleanup function in `useEffect`.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Signature rendering | Inline template replacement in API route | `getSignatureForUser()` from `lib/email/signature.ts` | Already handles DB lookup, user profile loading, placeholder substitution |
| Socket.IO room management | Manual room tracking in component state | Socket.IO built-in `socket.join()`/`socket.leave()` via `rooms.ts` | Automatic cleanup on disconnect, Redis adapter handles cross-process |
| Real-time event plumbing | New WebSocket connection or SSE | Existing `SocketProvider` + `useSocket()` hook | Already connected, authenticated, with reconnect handling |

**Key insight:** Every piece of this phase already exists as working code. The task is purely connecting wires, not building new capabilities.

## Common Pitfalls

### Pitfall 1: Socket Room Never Left on Navigation

**What goes wrong:** Client joins `mailbox:{kontoId}` room but never leaves when navigating away from email pages. Over time, the user accumulates room memberships for all mailboxes they ever viewed.
**Why it happens:** Missing cleanup in the `useEffect` that emits `join:mailbox`.
**How to avoid:** Always pair `join:mailbox` with `leave:mailbox` in a useEffect cleanup function. When `selectedKontoId` changes, leave the old room before joining the new one.
**Warning signs:** Socket.IO admin UI shows users in dozens of rooms; folder-tree updates fire for wrong mailboxes.

### Pitfall 2: Race Condition Between Socket Connect and Room Join

**What goes wrong:** Component tries to emit `join:mailbox` before socket is connected.
**Why it happens:** `useSocket()` returns `socket` that may not yet be connected.
**How to avoid:** Check `isConnected` before emitting, or listen for the `connect` event.
**Warning signs:** `join:mailbox` emitted but server never receives it; no room membership created.

### Pitfall 3: Signature API Returns Stale/Empty Without Error

**What goes wrong:** `/api/email-signature` returns `{ signature: "" }` instead of actual HTML.
**Why it happens:** `signaturVorlage` is null on the EmailKonto (admin hasn't configured it), or user profile fields are empty.
**How to avoid:** Return empty string gracefully (this is correct behavior). The compose-popup already handles empty signature by not inserting anything.
**Warning signs:** None -- this is expected behavior when no signature is configured.

### Pitfall 4: ComposeManager as Server Component

**What goes wrong:** Next.js error when importing `ComposeManager` (a `"use client"` component) into the email layout (currently a server component).
**Why it happens:** `ComposeManager` uses `useState`/`useContext` which require `"use client"`.
**How to avoid:** Either add `"use client"` to the email layout, or create a wrapper client component. The email layout is currently a server component with no server-only code, so adding `"use client"` is safe.
**Warning signs:** Build error: "You're importing a component that needs useState..."

### Pitfall 5: Duplicate CustomEvent Dispatch

**What goes wrong:** If multiple components bridge the socket `email:folder-update` event to `window` CustomEvent, the folder-tree handler fires multiple times per update.
**Why it happens:** Bridge logic placed in both inbox-layout and folder-tree.
**How to avoid:** Bridge in exactly ONE place. Recommendation: in `inbox-layout.tsx` which is the parent of `folder-tree.tsx`.
**Warning signs:** Unread count jumps erratically; console shows multiple CustomEvent dispatches.

## Code Examples

### Complete rooms.ts Addition (verified against existing pattern)

```typescript
// Source: src/lib/socket/rooms.ts (existing join:akte pattern)
// ADD these handlers inside the io.on("connection") callback:

// Dynamic Mailbox room join (for email real-time updates)
socket.on("join:mailbox", (kontoId: string) => {
  if (!kontoId || typeof kontoId !== "string") return;
  const mailboxRoom = `mailbox:${kontoId}`;
  socket.join(mailboxRoom);
  log.debug({ userId, kontoId }, "Joined mailbox room");
});

// Dynamic Mailbox room leave
socket.on("leave:mailbox", (kontoId: string) => {
  if (!kontoId || typeof kontoId !== "string") return;
  const mailboxRoom = `mailbox:${kontoId}`;
  socket.leave(mailboxRoom);
  log.debug({ userId, kontoId }, "Left mailbox room");
});
```

### Socket Bridge in inbox-layout.tsx

```typescript
// Source: Pattern from notification-provider.tsx (socket.on listener)
import { useSocket } from "@/components/socket-provider";

// Inside InboxLayout component:
const { socket, isConnected } = useSocket();

// Join/leave mailbox room for real-time updates
useEffect(() => {
  if (!socket || !isConnected || !emailStore.selectedKontoId) return;

  const kontoId = emailStore.selectedKontoId;
  socket.emit("join:mailbox", kontoId);

  return () => {
    socket.emit("leave:mailbox", kontoId);
  };
}, [socket, isConnected, emailStore.selectedKontoId]);

// Bridge socket event to CustomEvent for folder-tree
useEffect(() => {
  if (!socket) return;

  const handleFolderUpdate = (data: {
    kontoId: string;
    ordnerId: string;
    ungeleseneAnzahl: number;
  }) => {
    window.dispatchEvent(
      new CustomEvent("email:folder-update", { detail: data })
    );
  };

  socket.on("email:folder-update", handleFolderUpdate);
  return () => {
    socket.off("email:folder-update", handleFolderUpdate);
  };
}, [socket]);
```

### Email Signature API Route

```typescript
// Source: Pattern from existing src/app/api/email-konten/route.ts
import { NextRequest, NextResponse } from "next/server";
import { auth } from "@/lib/auth";
import { getSignatureForUser } from "@/lib/email/signature";

export async function GET(req: NextRequest) {
  const session = await auth();
  if (!session?.user?.id) {
    return NextResponse.json({ error: "Nicht autorisiert" }, { status: 401 });
  }

  const kontoId = req.nextUrl.searchParams.get("kontoId");
  if (!kontoId) {
    return NextResponse.json(
      { error: "kontoId Parameter fehlt" },
      { status: 400 }
    );
  }

  try {
    const signature = await getSignatureForUser(session.user.id, kontoId);
    return NextResponse.json({ signature });
  } catch (err) {
    return NextResponse.json(
      { error: "Fehler beim Laden der Signatur" },
      { status: 500 }
    );
  }
}
```

### Email Layout with ComposeManager

```typescript
// Source: Existing email layout + ComposeManager component
"use client";

import { ComposeManager } from "@/components/email/compose-manager";

export default function EmailLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <ComposeManager>
      <div className="h-[calc(100vh-4rem)] -m-6 overflow-hidden">
        {children}
      </div>
    </ComposeManager>
  );
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Window CustomEvent for cross-component communication | Direct Socket.IO event subscription via React context | Phase 1 (Socket.IO setup) | folder-tree.tsx uses the old approach; bridging preserves backward compatibility |

**Deprecated/outdated:**
- The `window.addEventListener("email:folder-update")` pattern in `folder-tree.tsx` is a temporary bridge. In a future refactor, it should be replaced with direct `useSocket()` subscription. For this phase, the bridge approach minimizes changes while delivering functionality.

## Open Questions

1. **Should ComposeManager be mounted at dashboard level or email level?**
   - What we know: ComposeManager renders compose popups. Currently only used in email context.
   - What's unclear: Future phases may want "compose from anywhere" (e.g., from Akte detail page).
   - Recommendation: Mount at email layout level for now. If compose-from-anywhere is needed later, move to dashboard layout in that phase. This keeps the scope minimal.

2. **Should the send-processor's inline renderSignature be consolidated with lib/email/signature.ts?**
   - What we know: `send-processor.ts` has its own `renderSignature()` (lines 167+). `lib/email/signature.ts` has `getSignatureForUser()` which does the same thing.
   - What's unclear: Whether they are exactly identical or have subtle differences.
   - Recommendation: Out of scope for this phase. The API route uses `lib/email/signature.ts` which is the canonical source. Consolidating the send-processor is tech debt for a future cleanup.

3. **Multiple kontoIds visible simultaneously in folder-tree**
   - What we know: The folder-tree shows ALL active mailboxes. The current `selectedKontoId` tracks one.
   - What's unclear: Should the client join rooms for ALL visible kontoIds or just the selected one?
   - Recommendation: Join room for the selected kontoId only. Updates for other mailboxes will be picked up on next folder fetch or when the user selects that mailbox. This keeps room membership minimal.

## Sources

### Primary (HIGH confidence)
- `src/lib/socket/rooms.ts` -- existing room join/leave pattern for akte rooms
- `src/lib/email/imap/connection-manager.ts` -- emitter already sends to `mailbox:{kontoId}` room (line 127-131)
- `src/components/email/folder-tree.tsx` -- window CustomEvent listener (lines 136-160)
- `src/components/email/compose-manager.tsx` -- ComposeManager provider definition
- `src/components/email/compose-popup.tsx` -- signature fetch on line 122-140
- `src/lib/email/signature.ts` -- `getSignatureForUser()` ready to use
- `src/app/(dashboard)/email/layout.tsx` -- current email layout without ComposeManager
- `src/components/socket-provider.tsx` -- `useSocket()` hook
- `src/components/notifications/notification-provider.tsx` -- pattern for socket event listening
- `.planning/v3.4-MILESTONE-AUDIT.md` -- INT-001, INT-002, INT-003 gap definitions

### Secondary (MEDIUM confidence)
- None needed -- all evidence is from codebase inspection.

### Tertiary (LOW confidence)
- None.

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH -- no new libraries, everything exists in codebase
- Architecture: HIGH -- follows existing patterns (join:akte, notification-provider socket listening, API route conventions)
- Pitfalls: HIGH -- gaps precisely identified in audit with exact file/line references

**Research date:** 2026-02-24
**Valid until:** 2026-03-24 (stable -- no external dependencies that could change)
