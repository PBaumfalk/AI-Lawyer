---
phase: 20-agent-tools-react-loop
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/helena/tools/types.ts
  - src/lib/helena/tools/index.ts
  - src/lib/helena/tools/_read/read-akte.ts
  - src/lib/helena/tools/_read/read-akte-detail.ts
  - src/lib/helena/tools/_read/read-dokumente.ts
  - src/lib/helena/tools/_read/read-dokumente-detail.ts
  - src/lib/helena/tools/_read/read-fristen.ts
  - src/lib/helena/tools/_read/read-zeiterfassung.ts
  - src/lib/helena/tools/_read/search-gesetze.ts
  - src/lib/helena/tools/_read/search-urteile.ts
  - src/lib/helena/tools/_read/search-muster.ts
  - src/lib/helena/tools/_read/get-kosten-rules.ts
  - src/lib/helena/tools/_read/search-alle-akten.ts
  - src/lib/helena/tools/_read/search-web.ts
  - src/lib/helena/tools/_write/create-draft-dokument.ts
  - src/lib/helena/tools/_write/create-draft-frist.ts
  - src/lib/helena/tools/_write/create-notiz.ts
  - src/lib/helena/tools/_write/create-alert.ts
  - src/lib/helena/tools/_write/update-akte-rag.ts
  - src/lib/helena/tools/_write/create-draft-zeiterfassung.ts
  - src/lib/helena/role-filter.ts
  - src/lib/helena/tool-cache.ts
  - src/lib/helena/audit-logger.ts
  - src/lib/helena/system-prompt.ts
autonomous: true
requirements: [AGNT-02, AGNT-03]

must_haves:
  truths:
    - "createHelenaTools() returns a Record<string,Tool> with all 18+ tool definitions keyed by snake_case name"
    - "Every read tool enforces RBAC via akteAccessFilter from ToolContext"
    - "Every write tool creates HelenaDraft records with status PENDING, never final records"
    - "Search tools (gesetze/urteile/muster) call generateQueryEmbedding internally and return source metadata"
    - "Role filter restricts tools by UserRole (ADMIN/ANWALT=all, SACHBEARBEITER=read+limited write, SEKRETARIAT=read+create_notiz)"
    - "Tool cache deduplicates identical calls within one agent run"
  artifacts:
    - path: "src/lib/helena/tools/types.ts"
      provides: "ToolContext, ToolResult, SourceAttribution interfaces"
      exports: ["ToolContext", "ToolResult", "SourceAttribution", "HelenaTool"]
    - path: "src/lib/helena/tools/index.ts"
      provides: "createHelenaTools factory function"
      exports: ["createHelenaTools", "CreateHelenaToolsOptions"]
    - path: "src/lib/helena/role-filter.ts"
      provides: "Role-based tool filtering"
      exports: ["filterToolsByRole"]
    - path: "src/lib/helena/tool-cache.ts"
      provides: "In-run tool result caching"
      exports: ["createToolCache", "ToolCache"]
    - path: "src/lib/helena/audit-logger.ts"
      provides: "Tool call audit trail logging"
      exports: ["logToolCall"]
    - path: "src/lib/helena/system-prompt.ts"
      provides: "Helena persona system prompt builder"
      exports: ["buildSystemPrompt"]
  key_links:
    - from: "src/lib/helena/tools/index.ts"
      to: "src/lib/helena/tools/_read/*.ts"
      via: "directory auto-discovery"
      pattern: "readdirSync.*_read"
    - from: "src/lib/helena/tools/_read/search-gesetze.ts"
      to: "src/lib/gesetze/ingestion.ts"
      via: "searchLawChunks import"
      pattern: "searchLawChunks"
    - from: "src/lib/helena/tools/_write/create-draft-dokument.ts"
      to: "prisma.helenaDraft.create"
      via: "Prisma draft creation"
      pattern: "helenaDraft\\.create"
---

<objective>
Create the shared Helena tool library: 18+ tool factory functions (12 read + 6 write) with auto-discovery, shared ToolContext, role-based filtering, in-run caching, audit logging, and the Helena system prompt.

Purpose: This is the tool foundation that the ReAct orchestrator (Plan 02) and all downstream phases (21-26) consume. Every agent capability starts with a tool.

Output: Complete `src/lib/helena/` directory with working tool modules, factory function, and supporting infrastructure.
</objective>

<execution_context>
@/Users/patrickbaumfalk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/patrickbaumfalk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-schema-foundation/19-01-SUMMARY.md
@.planning/phases/20-agent-tools-react-loop/20-RESEARCH.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From src/lib/rbac.ts:
```typescript
export function buildAkteAccessFilter(userId: string, role: UserRole): Record<string, any>;
// ADMIN = {} (all), others = OR: [anwaltId, sachbearbeiterId, dezernate membership]
```

From src/lib/ai/provider.ts:
```typescript
export async function getModel(): Promise<LanguageModel>;
export async function getHelenaUserId(): Promise<string | null>;
```

From src/lib/ai/token-tracker.ts:
```typescript
export async function trackTokenUsage(input: TrackTokenUsageInput): Promise<void>;
export type AiFunktion = "CHAT" | "SCAN" | "ENTWURF" | "BRIEFING";
```

From src/lib/gesetze/ingestion.ts:
```typescript
export async function searchLawChunks(queryEmbedding: number[], opts?: { limit?: number; minScore?: number }): Promise<LawChunkResult[]>;
// Returns: id, gesetzKuerzel, paragraphNr, titel, content, syncedAt, sourceUrl, score
```

From src/lib/urteile/ingestion.ts:
```typescript
export async function searchUrteilChunks(queryEmbedding: number[], opts?: { limit?: number; minScore?: number }): Promise<UrteilChunkResult[]>;
// Returns: id, aktenzeichen, gericht, datum, rechtsgebiet, content, sourceUrl, score
```

From src/lib/muster/ingestion.ts:
```typescript
export async function searchMusterChunks(queryEmbedding: number[], opts?: { limit?: number; minScore?: number }): Promise<MusterChunkResult[]>;
// Returns: id, musterId, content, parentContent, musterName, kategorie, kanzleiEigen, rawScore
```

From src/lib/embedding/embedder.ts:
```typescript
export async function generateQueryEmbedding(query: string): Promise<number[]>;
```

From src/lib/finance/rvg/calculator.ts:
```typescript
export function computeRvgFee(streitwert: number, rate: number, table?: FeeTableVersion): number;
export function buildCalculation(streitwert: number, positions: Array<{ nr: string; options?: PositionOptions }>, options?: { ... }): CalculationResult;
```

Prisma Enums (from Phase 19):
```typescript
enum HelenaDraftTyp { DOKUMENT, FRIST, NOTIZ, ALERT }
enum HelenaDraftStatus { PENDING, ACCEPTED, REJECTED, EDITED }
enum HelenaAlertTyp { FRIST_KRITISCH, AKTE_INAKTIV, BETEILIGTE_FEHLEN, DOKUMENT_FEHLT, WIDERSPRUCH, NEUES_URTEIL }
enum HelenaTaskStatus { PENDING, RUNNING, DONE, FAILED, WAITING_APPROVAL, ABGEBROCHEN }
enum AktenActivityTyp { DOKUMENT, FRIST, EMAIL, HELENA_DRAFT, HELENA_ALERT, NOTIZ, BETEILIGTE, STATUS_CHANGE }
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create types, supporting infrastructure, and tool factory</name>
  <files>
    src/lib/helena/tools/types.ts
    src/lib/helena/tools/index.ts
    src/lib/helena/role-filter.ts
    src/lib/helena/tool-cache.ts
    src/lib/helena/audit-logger.ts
    src/lib/helena/system-prompt.ts
  </files>
  <action>
Create `src/lib/helena/` directory tree: `tools/`, `tools/_read/`, `tools/_write/`.

**src/lib/helena/tools/types.ts** -- Shared types for all tools:
```typescript
export interface ToolContext {
  prisma: PrismaClient;
  userId: string;
  userRole: UserRole;
  akteId: string | null;
  akteAccessFilter: Record<string, any>;  // From buildAkteAccessFilter()
  helenaUserId: string;
  cache: ToolCache;       // In-run cache instance
  abortSignal?: AbortSignal; // For cooperative cancellation
}

export interface ToolResult<T = unknown> {
  data?: T;
  error?: string;
  source?: SourceAttribution;
}

export interface SourceAttribution {
  table: string;
  id?: string;
  query?: string;
  chunkIds?: string[];
}

// Re-export tool type from AI SDK for convenience
export type { CoreTool as HelenaTool } from "ai";
```

**src/lib/helena/tool-cache.ts** -- Map-based in-run cache:
- `createToolCache()` returns a `ToolCache` with `get(key)`, `set(key, value)`, `has(key)` methods
- Key format: `${toolName}:${JSON.stringify(sortedParams)}` using sorted keys for deterministic hashing
- No TTL needed (cache lives only for one agent run)
- Export `createCacheKey(toolName: string, params: Record<string, unknown>): string` utility

**src/lib/helena/audit-logger.ts** -- Tool call audit trail:
- `logToolCall({ toolName, params, resultSummary, userId, akteId, durationMs })` -- logs via `createLogger("helena-audit")` from `src/lib/logger`
- Structured JSON log entry with all fields
- NEVER log full tool results (could contain PII) -- only summary (truncated to 200 chars)
- Export the function for use in tool wrappers

**src/lib/helena/role-filter.ts** -- Role-based tool filtering:
- `filterToolsByRole(tools: Record<string, any>, role: UserRole): Record<string, any>`
- ADMIN/ANWALT: all tools
- SACHBEARBEITER: all read + create_draft_dokument, create_draft_frist, create_notiz, create_alert, create_draft_zeiterfassung (NOT update_akte_rag)
- SEKRETARIAT: all read + create_notiz only
- Note: PRAKTIKANT does not exist in current schema -- use SEKRETARIAT as the most restricted tier

**src/lib/helena/system-prompt.ts** -- Helena persona:
- `buildSystemPrompt({ tools, akteId, userName, helenaMemory? }): string`
- German language always, Du-Form, friendly professional tone
- Include available tool list with when-to-use guidance
- Include HARD LIMITS from provider.ts comments (Helena may NEVER: send emails, set FREIGEGEBEN, delete data, etc.)
- Include first-contact intro: "Hi, ich bin Helena! Ich kann Akten durchsuchen, Gesetze nachschlagen und Entwuerfe erstellen. Was kann ich fuer dich tun?"
- HelenaMemory content included if provided (akteId-specific context)

**src/lib/helena/tools/index.ts** -- Factory with auto-discovery:
- `createHelenaTools(options: CreateHelenaToolsOptions): Record<string, CoreTool>`
- Build ToolContext from options using `buildAkteAccessFilter(options.userId, options.userRole)`
- Auto-discover tool files from `_read/` and `_write/` subdirectories
- Each tool file exports a `create*Tool(ctx: ToolContext)` function (convention: single export starting with "create")
- Tool name derived from filename: `read-akte.ts` -> `read_akte`
- Wrap each tool's execute with: cache check, audit logging, error handling (catch all exceptions, return ToolResult with error)
- Apply `filterToolsByRole` before returning
- Options interface:
```typescript
export interface CreateHelenaToolsOptions {
  prisma: PrismaClient;
  userId: string;
  userRole: UserRole;
  akteId: string | null;
  helenaUserId: string;
}
```

IMPORTANT: Use require()-based auto-discovery for the tool directory (the project already uses esbuild bundling -- dynamic require works). If dynamic require is problematic, fall back to explicit static imports of all tool files with a registry map.
  </action>
  <verify>
    <automated>cd /Users/patrickbaumfalk/Projekte/AI-Lawyer/.claude/worktrees/dynamic-sleeping-dream && npx tsc --noEmit --pretty 2>&1 | head -50</automated>
  </verify>
  <done>
    - types.ts exports ToolContext, ToolResult, SourceAttribution
    - tool-cache.ts exports createToolCache, createCacheKey
    - audit-logger.ts exports logToolCall
    - role-filter.ts exports filterToolsByRole with 4-role matrix
    - system-prompt.ts exports buildSystemPrompt with German persona
    - index.ts exports createHelenaTools factory that auto-discovers and wraps tools
    - All files compile without TypeScript errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Create all 18+ tool modules (12 read + 6 write)</name>
  <files>
    src/lib/helena/tools/_read/read-akte.ts
    src/lib/helena/tools/_read/read-akte-detail.ts
    src/lib/helena/tools/_read/read-dokumente.ts
    src/lib/helena/tools/_read/read-dokumente-detail.ts
    src/lib/helena/tools/_read/read-fristen.ts
    src/lib/helena/tools/_read/read-zeiterfassung.ts
    src/lib/helena/tools/_read/search-gesetze.ts
    src/lib/helena/tools/_read/search-urteile.ts
    src/lib/helena/tools/_read/search-muster.ts
    src/lib/helena/tools/_read/get-kosten-rules.ts
    src/lib/helena/tools/_read/search-alle-akten.ts
    src/lib/helena/tools/_read/search-web.ts
    src/lib/helena/tools/_write/create-draft-dokument.ts
    src/lib/helena/tools/_write/create-draft-frist.ts
    src/lib/helena/tools/_write/create-notiz.ts
    src/lib/helena/tools/_write/create-alert.ts
    src/lib/helena/tools/_write/update-akte-rag.ts
    src/lib/helena/tools/_write/create-draft-zeiterfassung.ts
  </files>
  <action>
Create all tool modules following the plugin pattern from RESEARCH.md. Every tool file exports one `create*Tool(ctx: ToolContext)` function that returns `tool({ description, parameters, execute })`.

**Common patterns for ALL tools:**
- English descriptions for LLM comprehension. German domain terms (Akte, Frist, Rechtsgebiet) kept as-is.
- Zod schemas for parameter validation with `.describe()` on each field
- Return `ToolResult<T>` shape: `{ data, error?, source? }` -- NEVER throw
- Check `ctx.abortSignal?.aborted` at start of execute (return error if aborted)
- akteId defaults to `ctx.akteId` when optional and not provided
- All Prisma queries include `ctx.akteAccessFilter` in WHERE clause for RBAC
- Select only needed fields (no `include: { ... }` that waste tokens)

**READ TOOLS (12):**

1. **read-akte.ts** -- Summary: aktenzeichen, kurzrubrum, sachgebiet, status, gegenstandswert, anwalt name, sachbearbeiter name, counts (dokumente, fristen, beteiligte). Uses `ctx.prisma.akte.findFirst` with `_count` select.

2. **read-akte-detail.ts** -- Full record: everything from summary + beteiligte list, rechtsgebiet, tags, gegenseite info, notizen, referenzAkteId. Uses `ctx.prisma.akte.findFirst` with full select + limited includes.

3. **read-dokumente.ts** -- Summary list for an Akte: id, titel, kategorie, status, dateiname, createdAt, fileSize. Parameters: `akteId`, optional `kategorie` filter, optional `limit` (default 20). Uses `ctx.prisma.dokument.findMany` ordered by createdAt desc.

4. **read-dokumente-detail.ts** -- Single document full info: all summary fields + inhaltOcr (OCR text), beschreibung, metadaten. Parameter: `dokumentId` required. Uses `ctx.prisma.dokument.findUnique`.

5. **read-fristen.ts** -- Deadlines for Akte: id, titel, datum, typ (FRIST/TERMIN/WIEDERVORLAGE), status, beschreibung. Parameter: `akteId`, optional `status` filter (active/past/all, default "active" = datum >= today). Uses `ctx.prisma.kalenderEintrag.findMany`.

6. **read-zeiterfassung.ts** -- Time entries for Akte: id, beschreibung, dauer (minutes), datum, user name, abrechnungsart. Parameter: `akteId`, optional `limit` (default 20). Uses `ctx.prisma.zeiterfassung.findMany`.

7. **search-gesetze.ts** -- Semantic law search. Parameter: `query` string, optional `limit` (default 5). Internally calls `generateQueryEmbedding(query)` then `searchLawChunks(embedding, { limit })`. Returns formatted citations: `{ paragraphNr, gesetzKuerzel, titel, content, score, sourceUrl }`. Source: `{ table: "gesetze_chunks", chunkIds, query }`.

8. **search-urteile.ts** -- Semantic case law search. Parameter: `query` string, optional `limit` (default 5). Internally calls `generateQueryEmbedding(query)` then `searchUrteilChunks(embedding, { limit })`. Returns: `{ aktenzeichen, gericht, datum, rechtsgebiet, content, score, sourceUrl }`. Source: `{ table: "urteil_chunks", chunkIds, query }`.

9. **search-muster.ts** -- Semantic template search. Parameter: `query` string, optional `limit` (default 5). Internally calls `generateQueryEmbedding(query)` then `searchMusterChunks(embedding, { limit })`. Returns: `{ musterName, kategorie, content, kanzleiEigen, score }`. Source: `{ table: "muster_chunks", chunkIds, query }`.

10. **get-kosten-rules.ts** -- RVG fee lookup. Parameters: `streitwert` (number), optional `positionen` (array of VV position numbers like "3100", "3104"). Calls `computeRvgFee` for single fee or `buildCalculation` for full calculation. Returns structured fee result. Source: `{ table: "rvg_vv_katalog" }`.

11. **search-alle-akten.ts** -- Cross-case search. Parameters: `query` string (searches kurzrubrum, aktenzeichen), optional `status` filter, optional `rechtsgebiet` filter, optional `limit` (default 10). Uses `ctx.prisma.akte.findMany` with text search on kurzrubrum (contains, mode: insensitive) + `ctx.akteAccessFilter`. Returns: id, aktenzeichen, kurzrubrum, status, sachgebiet, anwalt name.

12. **search-web.ts** -- STUB: Returns `{ error: "Web-Suche ist noch nicht konfiguriert. Nutze search_gesetze und search_urteile fuer rechtliche Recherche." }`. Per RESEARCH.md open question #1, implement as placeholder.

**WRITE TOOLS (6):**

All write tools create `HelenaDraft` records via `ctx.prisma.helenaDraft.create()`. NEVER create final Dokument/Frist/etc. records directly.

1. **create-draft-dokument.ts** -- Parameters: `titel` (string), `inhalt` (string, markdown content), optional `akteId`, optional `meta` (JSON). Creates HelenaDraft with typ=DOKUMENT, status=PENDING. Returns: `{ draftId, typ, titel, status }`.

2. **create-draft-frist.ts** -- Parameters: `titel` (string), `datum` (string, ISO date), `typ` ("FRIST"|"TERMIN"|"WIEDERVORLAGE"), optional `beschreibung`, optional `akteId`. Creates HelenaDraft with typ=FRIST, meta containing the frist data. Returns: `{ draftId, typ, titel, datum, status }`.

3. **create-notiz.ts** -- Parameters: `inhalt` (string), optional `akteId` (notes can be Akte-unbound per CONTEXT.md). If no akteId and no ctx.akteId, create a general note. Creates HelenaDraft with typ=NOTIZ. Returns: `{ draftId, typ, status }`.

4. **create-alert.ts** -- Parameters: `typ` (HelenaAlertTyp enum value), `titel` (string), optional `inhalt` (string), `severity` (1-10, default 5), optional `akteId`. Creates HelenaAlert directly (alerts don't go through draft approval -- they ARE the output). Returns: `{ alertId, typ, titel, severity }`. Source: `{ table: "helena_alerts" }`.

5. **update-akte-rag.ts** -- Parameters: `akteId`, `updates` object with optional fields: `sachgebiet`, `tags`, `rechtsgebiet`, `summary`. Creates HelenaDraft with typ=DOKUMENT, meta containing the proposed field updates. Returns: `{ draftId, typ, proposedUpdates }`. NOTE: Does NOT update the Akte directly -- stores proposal as draft for approval.

6. **create-draft-zeiterfassung.ts** -- Parameters: `beschreibung` (string), `dauer` (number, minutes), optional `datum` (ISO date, default today), optional `akteId`. Creates HelenaDraft with typ=NOTIZ (no ZEITERFASSUNG in HelenaDraftTyp enum -- use NOTIZ with meta.subtype="zeiterfassung"). Returns: `{ draftId, typ, beschreibung, dauer, status }`.

**For all search tools (gesetze/urteile/muster):** Wrap `generateQueryEmbedding()` in try-catch. If embedding fails, return `{ error: "Embedding-Dienst nicht verfuegbar. Versuche es spaeter erneut." }`.

**For all tools:** Truncate large text fields in results to prevent token bloat. Content fields max 2000 chars, descriptions max 500 chars.
  </action>
  <verify>
    <automated>cd /Users/patrickbaumfalk/Projekte/AI-Lawyer/.claude/worktrees/dynamic-sleeping-dream && npx tsc --noEmit --pretty 2>&1 | head -50</automated>
  </verify>
  <done>
    - 12 read tool files exist in src/lib/helena/tools/_read/ and export create*Tool functions
    - 6 write tool files exist in src/lib/helena/tools/_write/ and export create*Tool functions
    - All read tools use ctx.akteAccessFilter for RBAC
    - All write tools (except create-alert) create HelenaDraft records with status PENDING
    - Search tools call generateQueryEmbedding internally with error handling
    - search-web returns stub error message
    - All files compile without TypeScript errors
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. All 18+ files exist in the expected directory structure
3. `createHelenaTools` can be imported and called (type-checks)
4. No direct Dokument/Frist/etc creation in write tools (only HelenaDraft)
5. Every tool file follows the plugin pattern: single `create*Tool(ctx)` export returning `tool()`
</verification>

<success_criteria>
- createHelenaTools({ prisma, userId, userRole, akteId, helenaUserId }) returns 18+ tools
- filterToolsByRole correctly restricts tools for all 4 roles
- All tool modules follow the same pattern and compile
- Search tools use existing search infrastructure (searchLawChunks, etc.)
- Write tools always create drafts, never final records
- System prompt is in German with Helena persona
</success_criteria>

<output>
After completion, create `.planning/phases/20-agent-tools-react-loop/20-01-SUMMARY.md`
</output>
