---
phase: 20-agent-tools-react-loop
plan: 03
type: execute
wave: 3
depends_on: ["20-01", "20-02"]
files_modified:
  - src/lib/helena/response-guard.ts
  - src/lib/helena/complexity-classifier.ts
  - src/lib/helena/index.ts
autonomous: true
requirements: [AGNT-04, AGNT-05]

must_haves:
  truths:
    - "ollamaResponseGuard detects and repairs broken JSON tool calls from Ollama models"
    - "contentScanGuard detects tool-call-shaped JSON in text content and re-parses it"
    - "Complexity classifier determines inline vs background mode AND model tier from user query"
    - "runHelenaAgent() provides a single entry point combining tools, orchestrator, guard, and classifier"
    - "Inline mode offers background continuation when 5-step cap is hit"
    - "All Ollama model responses are scanned by the guard (not just specific models)"
  artifacts:
    - path: "src/lib/helena/response-guard.ts"
      provides: "Ollama tool-call response repair hooks"
      exports: ["ollamaResponseGuard", "contentScanGuard"]
    - path: "src/lib/helena/complexity-classifier.ts"
      provides: "Query complexity classification for mode and tier selection"
      exports: ["classifyComplexity", "ComplexityResult"]
    - path: "src/lib/helena/index.ts"
      provides: "Public API: unified entry point for Helena agent"
      exports: ["runHelenaAgent", "HelenaAgentOptions", "HelenaAgentResult"]
  key_links:
    - from: "src/lib/helena/index.ts"
      to: "src/lib/helena/orchestrator.ts"
      via: "runAgent call"
      pattern: "runAgent"
    - from: "src/lib/helena/index.ts"
      to: "src/lib/helena/complexity-classifier.ts"
      via: "classifyComplexity for mode selection"
      pattern: "classifyComplexity"
    - from: "src/lib/helena/orchestrator.ts"
      to: "src/lib/helena/response-guard.ts"
      via: "experimental_repairToolCall hook"
      pattern: "ollamaResponseGuard"
    - from: "src/lib/helena/index.ts"
      to: "src/lib/helena/tools/index.ts"
      via: "createHelenaTools for tool setup"
      pattern: "createHelenaTools"
---

<objective>
Build the Ollama response guard, complexity classifier, and unified Helena agent entry point that combines all Plan 01 (tools) and Plan 02 (orchestrator) pieces into a single callable API.

Purpose: This plan closes the loop -- after it, any downstream phase can call `runHelenaAgent()` with a user message and get back a complete agent response with trace. The response guard ensures Ollama compatibility, and the classifier enables dual-mode execution.

Output: Three modules completing the `src/lib/helena/` library, plus the public `index.ts` entry point.
</objective>

<execution_context>
@/Users/patrickbaumfalk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/patrickbaumfalk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-agent-tools-react-loop/20-RESEARCH.md
@.planning/phases/20-agent-tools-react-loop/20-01-SUMMARY.md
@.planning/phases/20-agent-tools-react-loop/20-02-SUMMARY.md

<interfaces>
<!-- From Plan 01 and Plan 02 outputs -->

From src/lib/helena/tools/index.ts (Plan 01):
```typescript
export interface CreateHelenaToolsOptions {
  prisma: PrismaClient;
  userId: string;
  userRole: UserRole;
  akteId: string | null;
  helenaUserId: string;
}
export function createHelenaTools(options: CreateHelenaToolsOptions): Record<string, CoreTool>;
```

From src/lib/helena/role-filter.ts (Plan 01):
```typescript
export function filterToolsByRole(tools: Record<string, any>, role: UserRole): Record<string, any>;
```

From src/lib/helena/system-prompt.ts (Plan 01):
```typescript
export function buildSystemPrompt(opts: { tools: Record<string, any>; akteId: string | null; userName: string; helenaMemory?: any }): string;
```

From src/lib/helena/orchestrator.ts (Plan 02):
```typescript
export interface AgentRunOptions {
  model: LanguageModel;
  modelName: string;
  tools: Record<string, CoreTool>;
  systemPrompt: string;
  messages: CoreMessage[];
  mode: "inline" | "background";
  userId: string;
  akteId: string | null;
  onStepUpdate?: (step: StepUpdate) => void;
  abortSignal?: AbortSignal;
  repairToolCall?: Function;  // Optional experimental_repairToolCall hook
}

export interface AgentRunResult {
  text: string;
  steps: AgentStep[];
  totalTokens: { prompt: number; completion: number };
  finishReason: string;
  stalled: boolean;
  truncated: boolean;
}
```

From src/lib/ai/provider.ts:
```typescript
export async function getModel(): Promise<LanguageModel>;
export async function getModelName(): Promise<string>;
export async function getProviderName(): Promise<string>;
export async function getHelenaUserId(): Promise<string | null>;
```

From AI SDK v4.3.19:
```typescript
// experimental_repairToolCall signature:
type RepairToolCall = (options: {
  system: string | undefined;
  messages: any[];
  toolCall: LanguageModelV1FunctionToolCall;
  tools: any;
  parameterSchema: (options: { toolName: string }) => any;
  error: Error;
}) => Promise<LanguageModelV1FunctionToolCall | null>;
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Ollama response guard and complexity classifier</name>
  <files>
    src/lib/helena/response-guard.ts
    src/lib/helena/complexity-classifier.ts
  </files>
  <action>
**src/lib/helena/response-guard.ts** -- Two-layer Ollama response guard:

1. `ollamaResponseGuard` -- AI SDK `experimental_repairToolCall` hook:
   - Matches the SDK signature: receives `{ system, messages, toolCall, tools, parameterSchema, error }`, returns `Promise<LanguageModelV1FunctionToolCall | null>`
   - Attempts to repair common Ollama JSON issues in `toolCall.args`:
     a. Remove trailing commas: `.replace(/,\s*}/g, "}").replace(/,\s*]/g, "]")`
     b. Single to double quotes: `.replace(/'/g, '"')`
     c. Try JSON.parse on the fixed string
     d. If parse succeeds, return `{ ...toolCall, args: JSON.stringify(fixedArgs) }`
     e. If parse fails, return `null` (skip this tool call)
   - Log repair attempts via `createLogger("helena-guard")`

2. `contentScanGuard(text: string): { detected: boolean; toolCalls?: ParsedToolCall[] }` -- Secondary content-scanning guard:
   - Checks if plain text response contains tool-call-shaped JSON
   - Regex pattern: looks for `{"name": "...", "arguments": {...}}` or `[{"name": "...", ...}]` patterns in the text
   - If detected, try to extract and parse the tool call(s)
   - Return `{ detected: true, toolCalls: [{ name, arguments }] }` if successful
   - Return `{ detected: false }` if no tool-call JSON found
   - This guard is for the orchestrator to use in `onStepFinish` to detect when Ollama emits tool calls as text content instead of proper tool_call format
   - When detected, the orchestrator can log a warning and note this for future handling (full re-injection is complex and can be deferred)

Export both functions.

**src/lib/helena/complexity-classifier.ts** -- Rule-based complexity classification:

Per RESEARCH.md open question #2, start with rule-based heuristic (NOT an LLM call):

```typescript
export interface ComplexityResult {
  mode: "inline" | "background";
  tier: 1 | 2 | 3;          // 1=small local, 2=big local, 3=cloud
  reason: string;            // Why this classification was made
}

export function classifyComplexity(query: string): ComplexityResult;
```

Classification rules (ordered, first match wins):

**Background + Tier 2** (complex multi-step tasks):
- Contains "Schriftsatz", "Entwurf", "erstelle", "verfasse", "formuliere" (drafting tasks)
- Contains "recherchiere" + any legal term ("Gesetz", "Urteil", "Paragraph", "BGH")
- Contains "vergleiche" + multiple entities (multi-Akte analysis)
- Query length > 300 characters (complex instructions)
- Contains "analysiere", "pruefe" + "alle" or "vollstaendig"

**Background + Tier 3** (cloud -- only when configured for these):
- Contains "Schriftsatz" AND ("Klage" OR "Antrag" OR "Berufung") -- legal filings get highest quality
- Note: Tier 3 is only used if admin has configured cloud for this task type. Default to Tier 2 if cloud not configured.

**Inline + Tier 1** (simple lookups):
- Contains only "was ist", "zeige", "welche", "wie viele", "wann" (simple questions)
- Query length < 80 characters
- Single-entity queries (one Akte, one Frist, one Gesetz)

**Default: Inline + Tier 2** (medium complexity):
- Everything else

Export `classifyComplexity` and `ComplexityResult`.

Also export a helper: `getModelForTier(tier: 1 | 2 | 3): Promise<LanguageModel>`:
- Reads tier1/tier2/tier3 model names from SystemSettings (keys: `ai.helena.tier1_model`, `ai.helena.tier2_model`, `ai.helena.tier3_model`)
- Falls back to: tier1 = default Ollama model, tier2 = default Ollama model, tier3 = cloud model from provider settings
- Uses `getModel()` infrastructure from `src/lib/ai/provider.ts` -- but creates provider with the tier-specific model name
- If the tier's model is empty/unconfigured, fall back to the next lower tier

Auto-escalation logic (exported as `escalateTier`):
- `escalateTier(currentTier: 1 | 2 | 3): 1 | 2 | 3` -- returns next tier up, caps at 3
- Used by orchestrator when stall is detected to retry with a more capable model
  </action>
  <verify>
    <automated>cd /Users/patrickbaumfalk/Projekte/AI-Lawyer/.claude/worktrees/dynamic-sleeping-dream && npx tsc --noEmit --pretty 2>&1 | head -50</automated>
  </verify>
  <done>
    - response-guard.ts exports ollamaResponseGuard (SDK hook) and contentScanGuard (text scanner)
    - ollamaResponseGuard repairs trailing commas, single quotes, and malformed JSON
    - contentScanGuard detects tool-call-shaped JSON in text content
    - complexity-classifier.ts exports classifyComplexity with rule-based heuristic
    - classifyComplexity returns mode (inline/background) and tier (1/2/3) with reason
    - getModelForTier reads from SystemSettings with fallback chain
    - escalateTier increments tier up to 3
    - All files compile without TypeScript errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Unified Helena agent entry point (index.ts)</name>
  <files>
    src/lib/helena/index.ts
  </files>
  <action>
**src/lib/helena/index.ts** -- Public API that wires everything together:

Define the public interface:
```typescript
export interface HelenaAgentOptions {
  prisma: PrismaClient;
  userId: string;
  userRole: UserRole;
  userName: string;
  akteId: string | null;
  message: string;                    // User's input message
  conversationHistory?: CoreMessage[]; // Prior messages in this conversation
  mode?: "inline" | "background" | "auto"; // "auto" = use classifier (default)
  onStepUpdate?: (step: StepUpdate) => void;
  abortSignal?: AbortSignal;
  helenaMemory?: any;                 // HelenaMemory.content if available
}

export interface HelenaAgentResult {
  text: string;                       // Helena's response
  mode: "inline" | "background";      // Actual mode used
  tier: 1 | 2 | 3;                   // Model tier used
  steps: AgentStep[];                 // Full trace
  totalTokens: { prompt: number; completion: number };
  finishReason: string;
  capReached: boolean;                // true if inline 5-step cap was hit
  continueInBackground?: boolean;     // true if Helena suggests continuing in bg
}
```

Implement `runHelenaAgent(options: HelenaAgentOptions): Promise<HelenaAgentResult>`:

1. **Get Helena user ID:** `const helenaUserId = await getHelenaUserId() ?? "system";`

2. **Classify complexity:** If `mode === "auto"` (default), call `classifyComplexity(options.message)` to determine mode and tier. If mode explicitly set to "inline" or "background", use that with tier from classifier.

3. **Get model for tier:** Call `getModelForTier(tier)` to get the LanguageModel instance. Also get model name for token budget.

4. **Create tools:** `const tools = createHelenaTools({ prisma, userId, userRole, akteId, helenaUserId })`

5. **Build system prompt:** `const systemPrompt = buildSystemPrompt({ tools, akteId, userName, helenaMemory })`

6. **Build messages:** Combine conversationHistory with new user message:
   ```typescript
   const messages: CoreMessage[] = [
     ...(options.conversationHistory ?? []),
     { role: "user", content: options.message },
   ];
   ```

7. **Determine provider:** `const providerName = await getProviderName()`. If provider is "ollama", pass `ollamaResponseGuard` as `repairToolCall`. For cloud providers, set to undefined.

8. **Run agent:**
   ```typescript
   const result = await runAgent({
     model,
     modelName,
     tools,
     systemPrompt,
     messages,
     mode: actualMode,
     userId: options.userId,
     akteId: options.akteId,
     onStepUpdate: options.onStepUpdate,
     abortSignal: options.abortSignal,
     repairToolCall: providerName === "ollama" ? ollamaResponseGuard : undefined,
   });
   ```

9. **Handle inline cap reached:** If mode was "inline" and finishReason indicates the step cap was hit (not all steps used but tool calls still pending):
   - Set `capReached = true`
   - Append to result text: "\n\nIch bin noch nicht fertig. Moechtest du, dass ich im Hintergrund weitermache?"
   - Set `continueInBackground = true`

10. **Auto-escalation on stall:** If result.stalled AND tier < 3:
    - Log escalation attempt
    - Get model for next tier via `escalateTier(tier)`
    - Re-run with new model (same messages + stall context)
    - If re-run succeeds, return that result
    - If re-run also stalls, return the stalled result (don't infinite loop)
    - Cap at 1 escalation attempt

11. **Return HelenaAgentResult** with all fields populated.

**Re-exports from index.ts** for public API convenience:
```typescript
export { createHelenaTools } from "./tools";
export { runAgent } from "./orchestrator";
export { classifyComplexity } from "./complexity-classifier";
export { ollamaResponseGuard } from "./response-guard";
export type { AgentRunOptions, AgentRunResult, StepUpdate, AgentStep } from "./orchestrator";
export type { ToolContext, ToolResult } from "./tools/types";
export type { ComplexityResult } from "./complexity-classifier";
```
  </action>
  <verify>
    <automated>cd /Users/patrickbaumfalk/Projekte/AI-Lawyer/.claude/worktrees/dynamic-sleeping-dream && npx tsc --noEmit --pretty 2>&1 | head -50</automated>
  </verify>
  <done>
    - index.ts exports runHelenaAgent as the primary public API
    - runHelenaAgent combines classifier + tools + systemPrompt + orchestrator + guard
    - Mode "auto" uses classifyComplexity, explicit mode overrides it
    - Ollama provider gets response guard, cloud providers do not
    - Inline cap reached triggers background continuation offer in German
    - Auto-escalation retries with higher tier on stall (max 1 attempt)
    - All public types re-exported for downstream consumption
    - TypeScript compiles without errors
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `import { runHelenaAgent } from "@/lib/helena"` resolves correctly
3. Response guard handles trailing commas, single quotes, and JSON-as-content detection
4. Complexity classifier returns correct modes for simple/medium/complex queries
5. index.ts wires all components: tools -> orchestrator -> guard -> classifier
6. Auto-escalation caps at 1 retry to prevent infinite loops
</verification>

<success_criteria>
- runHelenaAgent() is callable with { prisma, userId, userRole, userName, akteId, message }
- Auto mode classifies queries and selects appropriate mode + tier
- Ollama responses are guarded against JSON-as-content and broken tool calls
- Inline cap reached produces German continuation offer
- Auto-escalation retries with higher tier on stall
- Full library compiles and exports clean public API from src/lib/helena/index.ts
</success_criteria>

<output>
After completion, create `.planning/phases/20-agent-tools-react-loop/20-03-SUMMARY.md`
</output>
