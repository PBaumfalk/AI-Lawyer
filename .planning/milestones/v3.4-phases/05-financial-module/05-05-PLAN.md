---
phase: 05-financial-module
plan: 05
type: execute
wave: 4
depends_on: ["05-02", "05-03"]
files_modified:
  - src/lib/finance/export/datev.ts
  - src/lib/finance/export/sepa.ts
  - src/lib/finance/export/types.ts
  - src/lib/finance/banking/csv-parser.ts
  - src/lib/finance/banking/camt-parser.ts
  - src/lib/finance/banking/matcher.ts
  - src/lib/finance/banking/dedup.ts
  - src/lib/finance/banking/types.ts
  - src/lib/finance/time-tracking/timer.ts
  - src/lib/finance/time-tracking/types.ts
  - src/app/api/finanzen/export/datev/route.ts
  - src/app/api/finanzen/export/sepa/route.ts
  - src/app/api/finanzen/banking/import/route.ts
  - src/app/api/finanzen/banking/match/route.ts
  - src/app/api/finanzen/zeiterfassung/route.ts
  - src/app/api/finanzen/zeiterfassung/timer/route.ts
  - src/app/api/finanzen/taetigkeitskategorien/route.ts
  - src/app/(dashboard)/akten/[id]/page.tsx
  - src/lib/finance/export/__tests__/datev-sepa.test.ts
autonomous: true
requirements:
  - REQ-FI-008
  - REQ-FI-009
  - REQ-FI-010
  - REQ-FI-011

must_haves:
  truths:
    - "User can export Buchungsstapel to DATEV CSV with EXTF_ header and configurable SKR03/04 Kontenrahmen mapping"
    - "User can generate SEPA pain.001 (credit transfer) and pain.008 (direct debit) XML files"
    - "User can import bank statements (CSV with multi-format detection) and the system suggests invoice matches with confidence scores"
    - "Bank match confirmation cascades: auto-mark invoice paid -> auto-book Aktenkonto entry"
    - "Timer starts when user opens any Akte, one active timer at a time, with quick-switch between Akten"
    - "Manual time entries support configurable Taetigkeitskategorien with billable/non-billable flag"
  artifacts:
    - path: "src/lib/finance/export/datev.ts"
      provides: "DATEV EXTF_ Buchungsstapel CSV generation"
      exports: ["generateDatevExport"]
    - path: "src/lib/finance/export/sepa.ts"
      provides: "SEPA pain.001 + pain.008 XML generation"
      exports: ["generateSepaCreditTransfer", "generateSepaDirectDebit"]
    - path: "src/lib/finance/banking/csv-parser.ts"
      provides: "Bank CSV import with multi-format detection"
      exports: ["parseBankCsv", "detectBankFormat"]
    - path: "src/lib/finance/banking/matcher.ts"
      provides: "Invoice matching algorithm with confidence scoring"
      exports: ["matchTransactions"]
    - path: "src/lib/finance/time-tracking/timer.ts"
      provides: "Timer state management (start, stop, switch)"
      exports: ["startTimer", "stopTimer", "switchTimer", "getActiveTimer"]
    - path: "src/app/api/finanzen/zeiterfassung/route.ts"
      provides: "Time entry CRUD"
      exports: ["GET", "POST"]
  key_links:
    - from: "src/app/api/finanzen/banking/match/route.ts"
      to: "src/lib/finance/banking/matcher.ts"
      via: "matchTransactions for suggestion cards"
      pattern: "matchTransactions"
    - from: "src/app/api/finanzen/banking/match/route.ts"
      to: "src/lib/finance/aktenkonto/booking.ts"
      via: "Auto-book Aktenkonto on match confirmation"
      pattern: "createBooking|autoBookFromInvoice"
    - from: "src/app/api/finanzen/export/datev/route.ts"
      to: "src/lib/finance/export/datev.ts"
      via: "generateDatevExport for CSV download"
      pattern: "generateDatevExport"
    - from: "src/app/api/finanzen/export/sepa/route.ts"
      to: "src/lib/finance/export/sepa.ts"
      via: "SEPA XML generation"
      pattern: "generateSepa"
    - from: "src/app/(dashboard)/akten/[id]/page.tsx"
      to: "/api/finanzen/zeiterfassung/timer"
      via: "POST on page mount to auto-start timer when opening any Akte"
      pattern: "fetch.*zeiterfassung/timer|useEffect.*timer"
---

<objective>
Build DATEV export, SEPA XML generation, bank statement import with invoice matching, and time tracking with auto-timer -- completing all remaining Phase 5 requirements.

Purpose: DATEV export is the de facto standard for Steuerberater communication, SEPA enables automated payments (especially Fremdgeld forwarding), bank import closes the cash flow loop, and time tracking enables Stundenhonorar billing (BGH-mandated monthly billing).

Output: Working DATEV CSV export, SEPA pain.001/008 XML, bank CSV import with matching, and time tracking with auto-timer and Taetigkeitskategorien.
</objective>

<execution_context>
@/Users/patrickbaumfalk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/patrickbaumfalk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-financial-module/05-RESEARCH.md
@.planning/phases/05-financial-module/05-02-SUMMARY.md
@.planning/phases/05-financial-module/05-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1a: DATEV + SEPA Export Libraries + API Routes</name>
  <files>
    src/lib/finance/export/types.ts
    src/lib/finance/export/datev.ts
    src/lib/finance/export/sepa.ts
    src/lib/finance/export/__tests__/datev-sepa.test.ts
    src/app/api/finanzen/export/datev/route.ts
    src/app/api/finanzen/export/sepa/route.ts
  </files>
  <action>
    **0. Install dependency:**
    ```bash
    npm install sepa
    ```

    **1. Export Types** (src/lib/finance/export/types.ts):
    - `DatevHeader { formatVersion: 700, dataCategory: 21, ... }`
    - `DatevBooking { amount: string, debitCredit: 'S'|'H', account, contraAccount, buKey?, date, reference1?, text, costCenter1? }`
    - `SepaPayment { creditorName, creditorIban, creditorBic?, amount, reference, purpose }`
    - `SepaMandate { mandateId, creditorId, debtorName, debtorIban, signatureDate }`

    **2. DATEV Export** (src/lib/finance/export/datev.ts):
    `generateDatevExport(options: { periodeStart, periodeEnd, kanzlei, kontenrahmen: 'SKR03'|'SKR04' }): Promise<string>`:
    - Generate EXTF_ header line (version 700, category 21 = Buchungsstapel, format version 13)
    - Generate column header line (Umsatz, S/H-Kz, WKZ, Kurs, Basis-Umsatz, WKZ-Basis, Konto, Gegenkonto, BU-Schluessel, Belegdatum, Belegfeld1, Belegfeld2, Skonto, Buchungstext, ... up to ~15 most used columns)
    - Query AktenKontoBuchung for period range
    - Map each booking to DATEV row:
      - Betrag in German format ("1.234,56")
      - S/H based on buchungstyp (EINNAHME/AUSGABE mapping)
      - Konto/Gegenkonto from Kostenstelle.sachkonto or default mapping
      - BU-Schluessel for USt (9 = 19%, 8 = 7%)
      - Belegdatum as DDMM format
      - Belegfeld1 = belegnummer or rechnungsnummer
      - Buchungstext = verwendungszweck (max 60 chars, truncated)
    - Semicolon-delimited, Windows line endings (\\r\\n)
    - Return CSV string with BOM for Excel compatibility

    SKR03/SKR04 mapping (configurable via Kostenstelle.sachkonto):
    - Default SKR03: Mandantengelder 1590, Fremdgeld 1599, Honorar 8400, Auslagen 4900
    - Default SKR04: Mandantengelder 3590, Fremdgeld 3599, Honorar 4400, Auslagen 6300

    **3. SEPA XML** (src/lib/finance/export/sepa.ts):
    Use `sepa` npm package (v2.1.0).

    `generateSepaCreditTransfer(debtor, payments[], executionDate): string`:
    - Create SEPA.Document('pain.001.001.09')
    - Set group header (id, created)
    - Create PaymentInfo with debtor IBAN/BIC/name
    - Add transactions (creditor IBAN/name, amount, remittanceInfo, e2eId)
    - Return XML string

    `generateSepaDirectDebit(creditor, mandates[], collectionDate): string`:
    - Create SEPA.Document('pain.008.001.08')
    - Similar structure for direct debit
    - Include mandate reference, signature date, creditor ID

    **4. Export API Routes:**

    DATEV (src/app/api/finanzen/export/datev/route.ts):
    - POST: `{ periodeStart, periodeEnd, kontenrahmen }`. Auth: ADMIN/ANWALT. Call generateDatevExport(). Return CSV with `Content-Type: text/csv; charset=utf-8` and `Content-Disposition: attachment; filename="DATEV-Buchungsstapel-{period}.csv"`.

    SEPA (src/app/api/finanzen/export/sepa/route.ts):
    - POST pain.001: `{ debtor: { iban, bic, name }, payments: [{ creditorIban, creditorName, amount, reference }], executionDate }`. Return XML.
    - POST pain.008: Similar for direct debit with mandates.
    - Auth: ADMIN/ANWALT. Return XML with `Content-Type: application/xml`.

    **5. Tests** (src/lib/finance/export/__tests__/datev-sepa.test.ts):
    Create vitest tests covering:
    - DATEV EXTF_ header starts with `"EXTF";700;21` and uses semicolon delimiter
    - DATEV booking rows use German number format ("1.234,56") and DDMM date format
    - DATEV BU-Schluessel: 9 for 19% USt, 8 for 7% USt
    - SKR03 vs SKR04 mapping produces correct Sachkonten
    - SEPA pain.001 XML contains CstmrCdtTrfInitn namespace
    - SEPA pain.008 XML contains CstmrDrctDbtInitn namespace
    - At least 8 test cases
  </action>
  <verify>
    <automated>npx vitest run src/lib/finance/export/__tests__/datev-sepa.test.ts && npx tsc --noEmit</automated>
    <manual>Verify DATEV CSV has EXTF_ header, semicolons, German number format. Verify SEPA XML has correct namespace.</manual>
  </verify>
  <done>
    DATEV export produces valid Buchungsstapel CSV with EXTF_ header and SKR03/04 mapping. SEPA generates pain.001/008 XML. All export tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 1b: Bank Statement Import + Invoice Matching</name>
  <files>
    src/lib/finance/banking/types.ts
    src/lib/finance/banking/csv-parser.ts
    src/lib/finance/banking/camt-parser.ts
    src/lib/finance/banking/matcher.ts
    src/lib/finance/banking/dedup.ts
    src/app/api/finanzen/banking/import/route.ts
    src/app/api/finanzen/banking/match/route.ts
  </files>
  <action>
    Note: camtjs v0.0.7 is WIP. For CAMT053, if camtjs proves insufficient, use fast-xml-parser (already available) with hand-defined type mappings.

    **1. Banking Types** (src/lib/finance/banking/types.ts):
    - `BankTransaction { buchungsdatum, wertstellung?, betrag, verwendungszweck, absenderEmpfaenger?, saldo?, iban? }`
    - `BankFormat { name, dateColumn, amountColumn, purposeColumn, senderRecipientColumn, delimiter, dateFormat }`
    - `MatchResult { transaktionId, matches: [{ rechnungId, rechnungsnummer, confidence, matchReasons[] }] }`

    **2. Bank CSV Parser** (src/lib/finance/banking/csv-parser.ts):
    `detectBankFormat(csvContent: string): string`:
    Detect format by header patterns: Sparkasse, VR-Bank, Deutsche Bank, Commerzbank, generic.
    Each format has: dateColumn, amountColumn, purposeColumn, senderRecipientColumn, delimiter, dateFormat.

    `parseBankCsv(csvContent: string, format?: string): BankTransaction[]`:
    Parse CSV rows into normalized BankTransaction objects. Handle German number format (comma decimal, dot thousands). Parse dates.

    **3. CAMT Parser** (src/lib/finance/banking/camt-parser.ts):
    `parseCamt053(xmlContent: string): BankTransaction[]`:
    Parse CAMT.053.001.02 or .08 XML. Extract: booking date, value date, amount, credit/debit, purpose, sender/recipient name, IBAN. Try camtjs first; if insufficient, use DOMParser/fast-xml-parser with XPath queries for Ntry elements.

    **4. Duplicate Detection** (src/lib/finance/banking/dedup.ts):
    `hashTransaction(tx: BankTransaction): string`:
    SHA-256 hash of: date + amount + purpose + senderRecipient. Store as importHash on BankTransaktion model.
    `findDuplicates(transactions: BankTransaction[]): { unique: BankTransaction[], duplicates: BankTransaction[] }`:
    Check importHash against existing BankTransaktion records.

    **5. Invoice Matcher** (src/lib/finance/banking/matcher.ts):
    `matchTransactions(transactions: BankTransaktion[]): MatchResult[]`:
    For each unmatched transaction, score potential invoice matches:
    - Rechnungsnummer in Verwendungszweck: confidence 0.95
    - Exact betrag match (within 0.01): confidence 0.7
    - Mandant name in absenderEmpfaenger: confidence 0.5
    - Combine scores (max, not sum). Return sorted by confidence.

    **6. Banking API Routes:**

    Import (src/app/api/finanzen/banking/import/route.ts):
    - POST: Accept multipart/form-data with CSV or XML file. Detect format, parse, dedup, store as BankTransaktion records. Return: `{ imported: N, duplicates: N, total: N }`. Auth: ADMIN/ANWALT.

    Match (src/app/api/finanzen/banking/match/route.ts):
    - GET: List unmatched transactions with suggested matches (matchTransactions()). Return suggestion cards.
    - POST: Confirm match. `{ transaktionId, rechnungId }`. Cascading flow:
      1. Mark BankTransaktion as zugeordnet, link to rechnungId and akteId
      2. Create Teilzahlung on invoice (if partial) or transition invoice to BEZAHLT (if full amount)
      3. Auto-book EINNAHME in Aktenkonto via createBooking()
      Return updated transaction + invoice + booking.
    - Auth: ADMIN/ANWALT/SACHBEARBEITER.
  </action>
  <verify>
    <automated>npx tsc --noEmit</automated>
    <manual>Verify bank CSV parser handles Sparkasse format. Verify match confirmation cascades to invoice + Aktenkonto.</manual>
  </verify>
  <done>
    Bank CSV import detects format and deduplicates. CAMT053 parser extracts transactions. Matcher suggests invoice matches with confidence scores. Match confirmation cascades to invoice status + Aktenkonto booking.
  </done>
</task>

<task type="auto">
  <name>Task 2: Time Tracking (Timer + Manual Entries + API + Akte Auto-Start)</name>
  <files>
    src/lib/finance/time-tracking/types.ts
    src/lib/finance/time-tracking/timer.ts
    src/app/api/finanzen/zeiterfassung/route.ts
    src/app/api/finanzen/zeiterfassung/timer/route.ts
    src/app/api/finanzen/taetigkeitskategorien/route.ts
    src/app/(dashboard)/akten/[id]/page.tsx
  </files>
  <action>
    **1. Types** (src/lib/finance/time-tracking/types.ts):
    - `TimerState { zeiterfassungId: string, akteId: string, aktenzeichen: string, startzeit: Date, userId: string }`
    - `TimeEntryInput { akteId, datum, dauer (minutes), beschreibung, stundensatz?, kategorie?, abrechenbar? }`

    **2. Timer Logic** (src/lib/finance/time-tracking/timer.ts):
    Per user decision: "Timer starts automatically when opening ANY Akte."

    `startTimer(userId: string, akteId: string): Promise<TimerState>`:
    1. Check for existing running timer (isRunning=true for this userId)
    2. If exists: stop it first (auto-save elapsed time)
    3. Create new Zeiterfassung entry with isRunning=true, startzeit=now()
    4. Return TimerState

    `stopTimer(userId: string, beschreibung?: string): Promise<Zeiterfassung>`:
    1. Find running timer for userId
    2. Calculate dauer from startzeit to now (in minutes)
    3. Set isRunning=false, endzeit=now(), dauer
    4. If this is a Stundenhonorar-Akte and beschreibung is empty, return error (Pflichtangabe per user decision)
    5. Return completed entry

    `switchTimer(userId: string, newAkteId: string): Promise<{ stopped?: Zeiterfassung, started: TimerState }>`:
    Stop current, start new. "One active timer at a time, quick switch."

    `getActiveTimer(userId: string): Promise<TimerState | null>`:
    Find running timer for user.

    `isStundenhonorarAkte(akteId: string): Promise<boolean>`:
    Check if Akte billing type is Stundenhonorar (via Akte.rechnungstyp or similar field).

    **3. Time Entry CRUD** (src/app/api/finanzen/zeiterfassung/route.ts):
    - GET: List time entries with filters (akteId, userId, dateRange, kategorie, abrechenbar, abgerechnet). Include akte.aktenzeichen. Summary: totalMinuten, abrechenbarMinuten, effektiverStundensatz.
    - POST: Create manual time entry. `{ akteId, datum, dauer, beschreibung, stundensatz?, kategorie?, abrechenbar? }`. Look up default stundensatz from User.stundensatz or Kanzlei.defaultStundensatz. Validate Akte exists.
    - PATCH: Update entry (only if not abgerechnet). `{ id, beschreibung?, kategorie?, abrechenbar?, dauer? }`.

    **4. Timer API** (src/app/api/finanzen/zeiterfassung/timer/route.ts):
    - GET: Get active timer for current user (getActiveTimer).
    - POST: Start timer. `{ akteId }`. Calls startTimer(). Returns TimerState.
    - PATCH: Stop timer. `{ beschreibung? }`. Calls stopTimer(). If Stundenhonorar and no beschreibung, return 400 "Taetigkeitsbeschreibung ist Pflicht bei Stundenhonorar-Akten".
    - PUT: Switch timer. `{ akteId }`. Calls switchTimer().

    **5. Taetigkeitskategorien** (src/app/api/finanzen/taetigkeitskategorien/route.ts):
    - GET: List active Taetigkeitskategorien. Include default categories if none exist (Schriftsatz, Telefonat, Besprechung, Recherche, Gericht, Reise, Sonstiges).
    - POST: Create. `{ name, abrechenbar? }`. ADMIN-only.
    - PATCH: Update. `{ id, name?, abrechenbar?, aktiv? }`. ADMIN-only.

    **6. Akte Page Auto-Start Wiring** (src/app/(dashboard)/akten/[id]/page.tsx):
    Per CONTEXT locked decision: "Timer starts automatically when opening ANY Akte â€” always."
    - Add a `useEffect` on page mount that calls `POST /api/finanzen/zeiterfassung/timer` with `{ akteId }` from route params
    - The timer API already handles stopping any previous timer (one active at a time)
    - Fire-and-forget: do NOT block page rendering on timer response
    - Only trigger if user is authenticated (session check)
    - The sidebar timer widget (to be built in Plan 06 UI) will read the active timer state

    All routes: auth(), Zod validation, German error messages.
  </action>
  <verify>
    <automated>npx tsc --noEmit</automated>
    <manual>Verify timer start/stop/switch logic, Stundenhonorar Pflichtangabe enforcement, Taetigkeitskategorien defaults, Akte page triggers timer auto-start on mount</manual>
  </verify>
  <done>
    Timer auto-starts per Akte on page mount, one active at a time, quick-switch. Stundenhonorar-Akten require Taetigkeitsbeschreibung on stop. Manual time entries with configurable categories. Time entries filterable and summable per Akte/User/period. Akte detail page auto-starts timer via POST on mount.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes
- DATEV export CSV starts with "EXTF";700;21 header
- SEPA pain.001 XML validates basic structure (Document, CstmrCdtTrfInitn)
- Bank CSV parser correctly parses Sparkasse-format date and amount columns
- Invoice match confirmation creates Teilzahlung/marks paid and books Aktenkonto entry
- Timer start/stop correctly calculates elapsed minutes
- Stundenhonorar-Akte timer stop without beschreibung returns 400
</verification>

<success_criteria>
- DATEV Buchungsstapel CSV downloadable with EXTF_ header, SKR03/04 mapping, German number format
- SEPA pain.001 and pain.008 XML generated correctly via sepa npm
- Bank CSV import handles multiple German bank formats with duplicate detection
- Invoice matching suggests correct invoices with confidence scores
- Match confirmation cascades: bank -> invoice paid -> Aktenkonto booking (one confirmation, three effects)
- Timer auto-starts, one active, quick-switch. Stundenhonorar forces beschreibung.
- Taetigkeitskategorien configurable by ADMIN with sensible defaults
</success_criteria>

<output>
After completion, create `.planning/phases/05-financial-module/05-05-SUMMARY.md`
</output>
