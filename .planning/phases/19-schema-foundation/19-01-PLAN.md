---
phase: 19-schema-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - prisma/schema.prisma
  - prisma/migrations/*/migration.sql
autonomous: true
requirements:
  - TASK-02
  - DRFT-01
  - ALRT-01
  - MEM-01

must_haves:
  truths:
    - "npx prisma migrate deploy succeeds with all 5 new models in the database"
    - "HelenaTask has HelenaTaskStatus enum with 6 values (PENDING, RUNNING, DONE, FAILED, WAITING_APPROVAL, ABGEBROCHEN) and JSON steps[] field"
    - "HelenaDraft has HelenaDraftTyp enum (DOKUMENT, FRIST, NOTIZ, ALERT) and HelenaDraftStatus enum (PENDING, ACCEPTED, REJECTED, EDITED) with nullable feedback field"
    - "HelenaAlert has HelenaAlertTyp enum with 6 values and integer severity/priority fields"
    - "HelenaMemory has structured JSON content field with @unique on akteId for one-memory-per-Akte pattern"
    - "AktenActivity has AktenActivityTyp enum with 8 event types for unified feed"
    - "All new models have ON DELETE CASCADE on akteId FK for DSGVO compliance"
    - "Prisma Client generates cleanly and existing application compiles without errors"
  artifacts:
    - path: "prisma/schema.prisma"
      provides: "5 new models (HelenaTask, HelenaDraft, HelenaAlert, HelenaMemory, AktenActivity) + 5 new enums + reverse relations on User and Akte"
      contains: "model HelenaTask"
    - path: "prisma/migrations/*/migration.sql"
      provides: "Generated migration SQL for all 5 models and enums"
      contains: "CREATE TABLE"
  key_links:
    - from: "prisma/schema.prisma (HelenaTask)"
      to: "prisma/schema.prisma (Akte)"
      via: "akteId FK with onDelete: Cascade"
      pattern: "onDelete: Cascade"
    - from: "prisma/schema.prisma (HelenaTask)"
      to: "prisma/schema.prisma (User)"
      via: "userId FK"
      pattern: "User.*@relation"
    - from: "prisma/schema.prisma (HelenaMemory)"
      to: "prisma/schema.prisma (Akte)"
      via: "akteId @unique FK with onDelete: Cascade"
      pattern: "akteId.*@unique"
    - from: "prisma/schema.prisma (HelenaDraft)"
      to: "prisma/schema.prisma (HelenaTask)"
      via: "optional helenaTaskId FK for traceability"
      pattern: "helenaTaskId"
---

<objective>
Add all 5 Helena Agent Prisma models (HelenaTask, HelenaDraft, HelenaAlert, HelenaMemory, AktenActivity) with their enums, indexes, and reverse relations to the existing schema, then generate and apply the migration.

Purpose: Create the data layer foundation that every subsequent Helena Agent phase (20-26) depends on. No UI, no API endpoints, no business logic -- pure schema.
Output: Updated prisma/schema.prisma with 5 new models + 5 new enums, generated migration SQL, regenerated Prisma client with new TypeScript types.
</objective>

<execution_context>
@/Users/patrickbaumfalk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/patrickbaumfalk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-schema-foundation/19-RESEARCH.md

<interfaces>
<!-- Key locations in prisma/schema.prisma where the executor must add reverse relations -->

User model (line 341-413) -- add reverse relations after line 396 (after helenaSuggestions):
```prisma
  // AI / Helena
  isSystem            Boolean   @default(false)
  tokenUsages         TokenUsage[]
  helenaSuggestions   HelenaSuggestion[]
  // <-- ADD REVERSE RELATIONS HERE
```

Akte model (line 685-736) -- add reverse relations after line 723 (after helenaSuggestions):
```prisma
  helenaSuggestions   HelenaSuggestion[]
  // <-- ADD REVERSE RELATIONS HERE
```

HelenaSuggestion model (line 1794-1817) -- last model in schema. Add new enums and models AFTER this model.

Existing project conventions to follow exactly:
- cuid() IDs: `id String @id @default(cuid())`
- Timestamps: `createdAt DateTime @default(now())` + `updatedAt DateTime @updatedAt`
- Table mapping: `@@map("snake_case_plural")`
- Index on FK: `@@index([akteId, status])` etc.
- Cascade: `onDelete: Cascade` on all mandatory Akte FKs
- JSON defaults: `@default("[]")` for arrays, `@default("{}")` for objects
- Section comments: `// --- Section Name ---`
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add 5 Helena Agent enums and models with reverse relations to schema.prisma</name>
  <files>prisma/schema.prisma</files>
  <action>
Add the following to `prisma/schema.prisma` in this exact order:

**Step 1: Add reverse relations to User model (after line ~396, after `helenaSuggestions HelenaSuggestion[]`)**

```prisma
  // Helena Agent v0.2
  helenaTasks          HelenaTask[]
  helenaDraftsCreated  HelenaDraft[]    @relation("HelenaDraftUser")
  helenaDraftsReviewed HelenaDraft[]    @relation("HelenaDraftReviewer")
  helenaAlerts         HelenaAlert[]
  aktenActivities      AktenActivity[]
```

Note: HelenaDraft needs TWO User relations (creator userId and reviewer reviewedById), so named relations are required to disambiguate (see Pitfall 2 from RESEARCH.md).

**Step 2: Add reverse relations to Akte model (after line ~723, after `helenaSuggestions HelenaSuggestion[]`)**

```prisma
  // Helena Agent v0.2
  helenaTasks      HelenaTask[]
  helenaDrafts     HelenaDraft[]
  helenaAlerts     HelenaAlert[]
  helenaMemory     HelenaMemory?    // One-to-one via @unique on akteId
  activities       AktenActivity[]
```

**Step 3: Add new section with 5 enums AFTER the HelenaSuggestion model (end of file)**

```prisma
// --- Helena Agent v0.2: Enums ---

enum HelenaTaskStatus {
  PENDING
  RUNNING
  DONE
  FAILED
  WAITING_APPROVAL
  ABGEBROCHEN
}

enum HelenaDraftTyp {
  DOKUMENT
  FRIST
  NOTIZ
  ALERT
}

enum HelenaDraftStatus {
  PENDING
  ACCEPTED
  REJECTED
  EDITED
}

enum HelenaAlertTyp {
  FRIST_KRITISCH
  AKTE_INAKTIV
  BETEILIGTE_FEHLEN
  DOKUMENT_FEHLT
  WIDERSPRUCH
  NEUES_URTEIL
}

enum AktenActivityTyp {
  DOKUMENT
  FRIST
  EMAIL
  HELENA_DRAFT
  HELENA_ALERT
  NOTIZ
  BETEILIGTE
  STATUS_CHANGE
}
```

**Step 4: Add 5 new models AFTER the enums**

```prisma
// --- Helena Agent v0.2: Models ---

model HelenaTask {
  id          String           @id @default(cuid())
  akteId      String
  akte        Akte             @relation(fields: [akteId], references: [id], onDelete: Cascade)
  userId      String           // User who created/triggered the task
  user        User             @relation(fields: [userId], references: [id])

  auftrag     String           @db.Text  // Natural language task description
  status      HelenaTaskStatus @default(PENDING)
  modus       String           @default("BACKGROUND") // INLINE | BACKGROUND
  prioritaet  Int              @default(5)  // 1-10, higher = more urgent
  steps       Json             @default("[]") // Agent trace: [{type: "thought"|"toolCall"|"toolResult"|"error", content, timestamp}]
  ergebnis    String?          @db.Text  // Final result summary
  fehler      String?          @db.Text  // Error message if FAILED

  startedAt   DateTime?
  completedAt DateTime?
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt

  // Reverse relation for drafts created by this task
  drafts      HelenaDraft[]

  @@index([akteId, status])
  @@index([userId, status])
  @@index([status, createdAt])
  @@map("helena_tasks")
}

model HelenaDraft {
  id             String            @id @default(cuid())
  akteId         String
  akte           Akte              @relation(fields: [akteId], references: [id], onDelete: Cascade)
  userId         String            // User who requested/triggered the draft
  user           User              @relation("HelenaDraftUser", fields: [userId], references: [id])

  typ            HelenaDraftTyp
  status         HelenaDraftStatus @default(PENDING)
  titel          String
  inhalt         String            @db.Text  // Draft content (markdown or structured)
  meta           Json?             // Type-specific payload (dokumentId, fristData, etc.)
  feedback       String?           @db.Text  // Rejection reason / edit notes

  // Traceability: which task produced this draft
  helenaTaskId   String?
  helenaTask     HelenaTask?       @relation(fields: [helenaTaskId], references: [id])

  // Review tracking
  reviewedById   String?
  reviewedBy     User?             @relation("HelenaDraftReviewer", fields: [reviewedById], references: [id])
  reviewedAt     DateTime?

  createdAt      DateTime          @default(now())
  updatedAt      DateTime          @updatedAt

  @@index([akteId, status])
  @@index([userId, status])
  @@index([status, createdAt])
  @@map("helena_drafts")
}

model HelenaAlert {
  id          String         @id @default(cuid())
  akteId      String
  akte        Akte           @relation(fields: [akteId], references: [id], onDelete: Cascade)
  userId      String         // Target user (Verantwortlicher of the Akte)
  user        User           @relation(fields: [userId], references: [id])

  typ         HelenaAlertTyp
  titel       String
  inhalt      String?        @db.Text  // Detailed alert description
  severity    Int            @default(5)   // 1-10, higher = more severe
  prioritaet  Int            @default(5)   // 1-10, higher = more urgent
  meta        Json?          // Alert-specific payload (fristId, dokumentId, urteilId, etc.)

  gelesen     Boolean        @default(false)
  gelesenAt   DateTime?

  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt

  @@index([akteId, typ])
  @@index([userId, gelesen])
  @@index([typ, createdAt])
  @@map("helena_alerts")
}

model HelenaMemory {
  id        String   @id @default(cuid())
  akteId    String   @unique  // One memory per Akte (upsert pattern)
  akte      Akte     @relation(fields: [akteId], references: [id], onDelete: Cascade)

  // Structured JSON: { summary, risks, nextSteps, openQuestions, relevantNorms }
  content   Json     @default("{}")
  version   Int      @default(1)    // Incremented on refresh

  lastRefreshedAt DateTime @default(now())
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@map("helena_memories")
}

model AktenActivity {
  id        String           @id @default(cuid())
  akteId    String
  akte      Akte             @relation(fields: [akteId], references: [id], onDelete: Cascade)
  userId    String?          // null = Helena/system-generated event
  user      User?            @relation(fields: [userId], references: [id])

  typ       AktenActivityTyp
  titel     String
  inhalt    String?          @db.Text
  meta      Json?            // Event-specific payload (dokumentId, fristId, draftId, alertId, etc.)

  createdAt DateTime         @default(now())

  @@index([akteId, createdAt])
  @@index([akteId, typ])
  @@map("akten_activities")
}
```

**Key design decisions per CONTEXT.md and RESEARCH.md:**
- JSON fields for agent trace (steps[]) and memory content -- avoid over-normalization
- Strict Prisma enums for all status/type fields -- NOT strings like HelenaSuggestion uses
- ON DELETE CASCADE on ALL akteId FKs for DSGVO Art. 17
- German domain terms in enums (ABGEBROCHEN, ENTWURF), English for technical fields
- HelenaMemory uses @unique on akteId for one-per-Akte upsert pattern
- HelenaDraft has optional helenaTaskId FK for task->draft traceability (RESEARCH open question 3)
- HelenaDraft has TWO User relations with named relations (RESEARCH pitfall 2)
- AktenActivity.userId is nullable for system/Helena events (RESEARCH open question 2)
- Composite indexes on (akteId, status), (userId, status), (akteId, createdAt) for downstream query patterns
- All models have @@map("snake_case_plural") per project convention
  </action>
  <verify>
    <automated>cd /Users/patrickbaumfalk/Projekte/AI-Lawyer/.claude/worktrees/dynamic-sleeping-dream && npx prisma validate 2>&1 | head -20</automated>
  </verify>
  <done>prisma/schema.prisma contains all 5 new models (HelenaTask, HelenaDraft, HelenaAlert, HelenaMemory, AktenActivity), 5 new enums (HelenaTaskStatus, HelenaDraftTyp, HelenaDraftStatus, HelenaAlertTyp, AktenActivityTyp), reverse relations on User and Akte, and `npx prisma validate` passes without errors</done>
</task>

<task type="auto">
  <name>Task 2: Generate and apply Prisma migration, verify Prisma Client generation</name>
  <files>prisma/migrations/*/migration.sql</files>
  <action>
Run the Prisma migration and generation pipeline:

1. **Generate migration:**
   ```bash
   npx prisma migrate dev --name add_helena_agent_models --create-only
   ```
   Use `--create-only` so the migration SQL is generated but not applied yet. This allows verification before applying.

2. **Inspect the generated migration SQL:**
   Verify the migration contains:
   - 5 CREATE TYPE statements for the new enums
   - 5 CREATE TABLE statements for the new models
   - CREATE INDEX statements for all declared indexes
   - FK constraints with ON DELETE CASCADE on all akteId columns
   - A UNIQUE constraint on helena_memories.akteId

3. **Apply the migration:**
   ```bash
   npx prisma migrate dev
   ```
   If the database is not running (Docker not started), this step may fail. In that case, ensure the migration file was created correctly and the schema is valid -- the migration will be applied when Docker starts.

4. **Regenerate Prisma Client:**
   ```bash
   npx prisma generate
   ```
   This must complete without errors. The generated client should include:
   - HelenaTask, HelenaDraft, HelenaAlert, HelenaMemory, AktenActivity types
   - HelenaTaskStatus, HelenaDraftTyp, HelenaDraftStatus, HelenaAlertTyp, AktenActivityTyp enums
   - Updated User and Akte types with new relation arrays

5. **Verify TypeScript compilation:**
   ```bash
   npx tsc --noEmit 2>&1 | head -30
   ```
   Should complete with zero errors related to the new models. Existing code must not break.

**Important:** If Docker/PostgreSQL is not running, Task 2 should still succeed for `prisma generate` (generates types from schema, no DB needed) and `tsc --noEmit` (type-checks against generated types). The actual migration apply can happen when the database is available.
  </action>
  <verify>
    <automated>cd /Users/patrickbaumfalk/Projekte/AI-Lawyer/.claude/worktrees/dynamic-sleeping-dream && npx prisma generate 2>&1 | tail -5 && echo "---GENERATE OK---" && npx tsc --noEmit 2>&1 | tail -10</automated>
  </verify>
  <done>Migration SQL file exists in prisma/migrations/ with correct CREATE TABLE/TYPE/INDEX statements, Prisma Client generates cleanly with all 5 new model types and 5 new enum types, TypeScript compilation passes with zero new errors</done>
</task>

</tasks>

<verification>
1. `npx prisma validate` passes -- schema syntax is correct
2. `npx prisma generate` succeeds -- client types generated for all new models
3. `npx tsc --noEmit` passes -- no TypeScript compilation errors introduced
4. Migration SQL contains ON DELETE CASCADE for all akteId FKs (grep for "ON DELETE CASCADE" in migration file)
5. Migration SQL contains UNIQUE constraint on helena_memories.akte_id
6. All 5 enums have correct values (grep for CREATE TYPE in migration file)
7. Schema has @@map on all 5 new models (grep for @@map in new model section)
</verification>

<success_criteria>
- prisma/schema.prisma has 5 new models and 5 new enums following existing project conventions
- All new models have mandatory akteId with ON DELETE CASCADE (DSGVO compliance)
- HelenaTask has HelenaTaskStatus enum with 6 values and JSON steps[] with @default("[]")
- HelenaDraft has HelenaDraftTyp and HelenaDraftStatus enums, nullable feedback field, optional helenaTaskId FK
- HelenaAlert has HelenaAlertTyp enum with 6 values, integer severity and prioritaet
- HelenaMemory has @unique on akteId and JSON content with @default("{}")
- AktenActivity has AktenActivityTyp enum with 8 values and nullable userId
- User and Akte models have all required reverse relation arrays
- Prisma Client generates and TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/19-schema-foundation/19-01-SUMMARY.md`
</output>
