# Phase 2.1: Wire Frist-Reminder Pipeline + Settings Init - Research

**Researched:** 2026-02-24
**Domain:** BullMQ worker wiring, queue consolidation, startup initialization
**Confidence:** HIGH

## Summary

This phase is pure integration work -- all building blocks already exist in the codebase and just need to be wired together. The frist-reminder processor (`src/workers/processors/frist-reminder.ts`) exports `processFristReminders()` but is not imported or registered anywhere in `src/worker.ts`. The queue definition exists in `src/lib/queues.ts` (separate from `src/lib/queue/queues.ts`) with `getFristReminderQueue()` and `registerFristReminderJob()`, but neither function is called at runtime. The `ALL_QUEUES` array in `src/lib/queue/queues.ts` only contains `testQueue` -- the frist-reminder queue is invisible to admin monitoring. `initializeDefaults()` exists in `src/lib/settings/service.ts` but is never called at startup.

The main work involves: (1) adding a frist-reminder BullMQ Worker registration in `src/worker.ts` following the exact same pattern as the existing testWorker, (2) consolidating the dual queue files into a single registry, (3) calling `registerFristReminderJob()` at worker startup, (4) calling `initializeDefaults()` at worker startup, and (5) updating the cron schedule from the existing `*/5 7-19 * * 1-5` to a daily 6:00 AM Europe/Berlin schedule per user decision. Additionally, the CONTEXT.md specifies dual-channel delivery (in-app + email) and deduplication -- email infrastructure (nodemailer) does not yet exist and must be added, and deduplication tracking needs a DB field or table.

**Primary recommendation:** Follow the existing testWorker pattern exactly for wiring, consolidate queues into `src/lib/queue/queues.ts`, add nodemailer for email delivery, and add a `reminderSentAt` field or separate tracking table for deduplication.

<user_constraints>
## User Constraints (from CONTEXT.md)

### Locked Decisions
- Daily scan at 6:00 AM (Europe/Berlin timezone)
- Runs every day including weekends, but weekend/holiday reminders are shifted to the preceding Friday
- Scan time is admin-configurable in Kanzlei-Einstellungen from day one (stored in SystemSettings)
- Dual-channel delivery: in-app (Socket.IO bell + toast) AND email
- Notification content: Akte reference + Frist description + days remaining (e.g. "Frist in 3 Tagen: Berufungsfrist -- Akte 123/2026 Mueller ./. Schmidt")
- Email format: simple text/HTML -- no firm letterhead needed for internal reminders
- Vertretung: both primary user AND deputy receive the reminder when primary is on vacation
- initializeDefaults() runs in worker process only (not in Next.js app) -- worker starts first in Docker
- Skip silently if defaults already exist in DB -- no log output on repeat starts
- Consolidate into a single queue registry file (src/lib/queues/registry.ts) listing ALL queues including frist-reminder
- Minimal changes to worker.ts -- add import + registration only, no refactoring
- BullMQ retry: 3 attempts with exponential backoff on cron job failure
- Catch-up: scan for any unsent reminders regardless of original due date -- nothing missed after downtime
- Deduplication: track sent status per Vorfrist reminder in DB -- never send the same reminder twice
- Independent channel retry: if email fails but in-app succeeds, retry email separately
- Maximum retry age: 3 days -- stop retrying email for reminders older than 3 days
- Permanently failed reminders: visible in Bull Board as failed + admin notification sent

### Claude's Discretion
- Exact BullMQ job options (concurrency, limiter settings)
- initializeDefaults() implementation details (upsert strategy)
- Email template structure and exact wording
- Bull Board configuration for frist-reminder queue visibility

### Deferred Ideas (OUT OF SCOPE)
None -- discussion stayed within phase scope
</user_constraints>

<phase_requirements>
## Phase Requirements

| ID | Description | Research Support |
|----|-------------|-----------------|
| REQ-FK-003 | Vorfristen-Erinnerungen (konfigurierbar, Standard: 7/3/1 Tag vorher) + Vorfrist | processFristReminders() already implements Vorfrist/Halbfrist scanning; needs wiring into BullMQ worker, cron scheduling, email delivery channel, and deduplication tracking. Configurable Vorfristen already stored in SystemSettings via fristen-tab UI. |
</phase_requirements>

## Standard Stack

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| bullmq | ^5.70.1 | Job queue for cron scheduling + retry | Already installed; `upsertJobScheduler` API available in v5 for repeatable jobs |
| ioredis | ^5.9.3 | Redis connection for BullMQ | Already installed; connection helpers in `src/lib/queue/connection.ts` |
| nodemailer | ^6 | SMTP email sending | Standard Node.js email library; needed for dual-channel delivery (email not yet installed) |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| @prisma/client | existing | DB access for deduplication tracking | Track which reminders have been sent to avoid duplicates |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| nodemailer | resend / @sendgrid/mail | Heavier dependency for internal-only emails; nodemailer works with any SMTP and is self-hosted friendly |

**Installation:**
```bash
npm install nodemailer && npm install -D @types/nodemailer
```

## Architecture Patterns

### Recommended Project Structure
```
src/
├── worker.ts                              # Main worker entry point (add frist-reminder Worker + initializeDefaults call)
├── lib/
│   ├── queue/
│   │   └── queues.ts                      # CONSOLIDATE: absorb frist-reminder queue from src/lib/queues.ts
│   ├── email/
│   │   └── send.ts                        # NEW: nodemailer transport + sendEmail helper
│   ├── settings/
│   │   ├── service.ts                     # initializeDefaults() already here
│   │   └── defaults.ts                    # Add frist-related default settings
│   └── notifications/
│       └── service.ts                     # Already has createNotification() for in-app
├── workers/
│   └── processors/
│       └── frist-reminder.ts              # Already exists, needs email channel + deduplication
└── lib/queues.ts                          # DELETE after consolidation into lib/queue/queues.ts
```

### Pattern 1: Worker Registration (follow existing testWorker pattern)
**What:** Register a BullMQ Worker for the `frist-reminder` queue in `src/worker.ts`
**When to use:** Every new queue processor follows this pattern
**Example:**
```typescript
// Source: existing src/worker.ts lines 23-79
import { processFristReminders } from "@/workers/processors/frist-reminder";

const fristReminderWorker = new Worker(
  "frist-reminder",
  async (job) => {
    return processFristReminders();
  },
  {
    connection,
    concurrency: 1, // Only one scan at a time
    settings: {
      backoffStrategy: (attemptsMade: number) => calculateBackoff(attemptsMade),
    },
  }
);

fristReminderWorker.on("completed", (job) => {
  if (!job) return;
  log.info({ jobId: job.id, result: job.returnvalue }, "Frist reminder run completed");
});

fristReminderWorker.on("failed", (job, err) => {
  if (!job) return;
  log.error({ jobId: job.id, err: err.message }, "Frist reminder run failed");
  // Notify admins on final failure
  if (job.attemptsMade >= (job.opts.attempts ?? 3)) {
    socketEmitter.to("role:ADMIN").emit("notification", {
      type: "job:failed",
      title: "Fristen-Erinnerung fehlgeschlagen",
      message: `Cron-Job fehlgeschlagen: ${err.message}`,
      data: { jobId: job.id, queue: "frist-reminder" },
    });
  }
});

workers.push(fristReminderWorker);
```

### Pattern 2: Queue Consolidation
**What:** Merge `src/lib/queues.ts` (old file) into `src/lib/queue/queues.ts` (canonical registry)
**When to use:** The dual-file situation is a tech debt from Phase 2 -- consolidate now
**Example:**
```typescript
// src/lib/queue/queues.ts (consolidated)
import { Queue, type JobsOptions } from "bullmq";
import { getQueueConnection } from "@/lib/queue/connection";

const defaultJobOptions: JobsOptions = {
  attempts: 3,
  backoff: { type: "custom" },
  removeOnComplete: { age: 86_400 },
  removeOnFail: { age: 604_800 },
};

export const testQueue = new Queue("test", {
  connection: getQueueConnection(),
  defaultJobOptions,
});

export const fristReminderQueue = new Queue("frist-reminder", {
  connection: getQueueConnection(),
  defaultJobOptions,
});

/** All queues for admin monitoring auto-discovery */
export const ALL_QUEUES: Queue[] = [testQueue, fristReminderQueue];

/** Register the repeatable frist-reminder cron job */
export async function registerFristReminderJob(): Promise<void> {
  await fristReminderQueue.upsertJobScheduler(
    "frist-reminder-daily",
    {
      pattern: "0 6 * * *",   // 6:00 AM daily
      tz: "Europe/Berlin",
    },
    {
      name: "check-fristen",
      data: {},
      opts: {
        removeOnComplete: { count: 100 },
        removeOnFail: { count: 50 },
      },
    }
  );
}
```

### Pattern 3: Startup Initialization in Worker
**What:** Call `initializeDefaults()` and `registerFristReminderJob()` at worker startup
**When to use:** One-time setup before worker starts processing
**Example:**
```typescript
// At bottom of src/worker.ts
async function startup() {
  await initializeDefaults();
  await registerFristReminderJob();
  log.info(
    { concurrency, queues: ["test", "frist-reminder"] },
    "Worker started"
  );
}

startup().catch((err) => {
  log.fatal({ err }, "Worker startup failed");
  process.exit(1);
});
```

### Pattern 4: Deduplication via DB Tracking
**What:** Track sent reminders to prevent duplicates across restarts and catch-up runs
**When to use:** Every reminder send must check if already sent for this Vorfrist+date
**Example:**
```typescript
// New model or field approach -- recommended: use Notification table + unique constraint check
// Before sending, query: has a notification with type "frist:vorfrist" and
// data.kalenderEintragId + data.daysUntil already been sent today?
const existing = await prisma.notification.findFirst({
  where: {
    type: "frist:vorfrist",
    data: { path: ["kalenderEintragId"], equals: eintrag.id },
    // Check if same vorfrist date was already notified
    createdAt: {
      gte: startOfDay(new Date()),
      lt: endOfDay(new Date()),
    },
  },
});
if (existing) return; // Already sent today
```

### Pattern 5: Email Transport Helper
**What:** Thin wrapper around nodemailer for SMTP email sending
**When to use:** Dual-channel delivery for frist reminders (and future email features)
**Example:**
```typescript
// src/lib/email/send.ts
import nodemailer from "nodemailer";
import { createLogger } from "@/lib/logger";

const log = createLogger("email");

const transporter = nodemailer.createTransport({
  host: process.env.SMTP_HOST ?? "localhost",
  port: parseInt(process.env.SMTP_PORT ?? "587", 10),
  secure: process.env.SMTP_SECURE === "true",
  auth: process.env.SMTP_USER ? {
    user: process.env.SMTP_USER,
    pass: process.env.SMTP_PASS,
  } : undefined,
});

export async function sendEmail(opts: {
  to: string;
  subject: string;
  text: string;
  html?: string;
}): Promise<void> {
  const from = process.env.SMTP_FROM ?? "noreply@kanzlei.local";
  await transporter.sendMail({ from, ...opts });
  log.info({ to: opts.to, subject: opts.subject }, "Email sent");
}
```

### Anti-Patterns to Avoid
- **Importing `src/lib/queues.ts` alongside `src/lib/queue/queues.ts`:** Creates two Queue instances for the same Redis queue name, causing race conditions. Consolidate into one file.
- **Running `initializeDefaults()` in Next.js API routes:** Settings init should happen once at startup, not on every API request. The worker process is the right place per user decision.
- **Forgetting `tz` in cron schedule:** Without timezone, BullMQ uses UTC. The user explicitly wants Europe/Berlin. Use `upsertJobScheduler` with `tz: "Europe/Berlin"`.
- **Concurrency > 1 for frist-reminder:** A reminder scan reads all Fristen and sends notifications. Running two scans concurrently causes duplicate notifications. Use `concurrency: 1`.
- **Storing cron schedule time only in code:** User wants admin-configurable scan time. The cron pattern should be read from SystemSettings so admins can change it without redeployment.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Email sending | Custom HTTP calls to SMTP | nodemailer | Handles SMTP protocol, TLS, connection pooling, encoding |
| Cron scheduling | Custom setInterval/setTimeout | BullMQ upsertJobScheduler | Survives restarts, provides retry, visible in admin dashboard |
| Deduplication | In-memory Set | Prisma DB query on Notification table | Survives worker restart, works across multiple worker instances |
| Weekend shift | Manual day-of-week check | date-fns `isSaturday`/`isSunday` + `previousFriday` | Already used in codebase for Frist calculations |

**Key insight:** Every piece of infrastructure already exists -- the risk is in incorrect wiring, not in missing capabilities.

## Common Pitfalls

### Pitfall 1: Dual Queue Instance for Same Name
**What goes wrong:** `src/lib/queues.ts` creates a Queue("frist-reminder") with one connection, while `src/lib/queue/queues.ts` would create another. BullMQ creates separate Redis subscriptions per Queue instance, causing event duplication.
**Why it happens:** Phase 2 created `src/lib/queues.ts` as a standalone file; Phase 1 had already established `src/lib/queue/queues.ts` as the canonical registry.
**How to avoid:** Delete or empty `src/lib/queues.ts` after migrating `getFristReminderQueue()` and `registerFristReminderJob()` into `src/lib/queue/queues.ts`. Update all imports.
**Warning signs:** Two Queue instances in different files referencing the same queue name.

### Pitfall 2: Missing Timezone in Cron
**What goes wrong:** Without `tz: "Europe/Berlin"`, BullMQ schedules in UTC. "0 6 * * *" becomes 6:00 UTC = 7:00 or 8:00 CET/CEST.
**Why it happens:** Timezone is an optional parameter, easy to forget.
**How to avoid:** Always pass `tz` parameter in `upsertJobScheduler` second argument.
**Warning signs:** Reminders arriving at unexpected times.

### Pitfall 3: initializeDefaults() Logging on Repeat Starts
**What goes wrong:** User decision says "skip silently if defaults already exist in DB -- no log output on repeat starts." Current implementation logs when count > 0 but does not log when count === 0. This is already correct, but the planner should verify no additional logging is added.
**Why it happens:** Over-eager logging during implementation.
**How to avoid:** Check current `initializeDefaults()` -- it already skips logging when created === 0. Preserve this behavior.
**Warning signs:** Worker startup logs cluttered with "Default settings initialized" every restart.

### Pitfall 4: Email Failure Blocking In-App Notification
**What goes wrong:** If email send is awaited before in-app notification, a network timeout blocks the entire reminder.
**Why it happens:** Sequential await of both channels.
**How to avoid:** Send in-app notification first (fast, local Redis), then attempt email. Use try/catch around email to not block the overall job. Per user decision, if email fails but in-app succeeds, email should be retried independently.
**Warning signs:** Notifications not appearing in-app when SMTP is down.

### Pitfall 5: Weekend Shift Logic Gap
**What goes wrong:** User decision says "if a reminder would fire on Saturday or Sunday, send it on the preceding Friday instead." The current `processFristReminders()` does not implement this -- it checks if vorfristDate matches today. If today is Friday and the vorfrist is Saturday, no reminder fires.
**Why it happens:** Weekend shift was decided in CONTEXT.md but the existing processor was built before this decision.
**How to avoid:** When checking vorfrist dates, also check if the vorfrist falls on Saturday/Sunday and if today is the preceding Friday. Use date-fns `isSaturday`, `isSunday`, `previousFriday`.
**Warning signs:** Reminders for weekend Vorfristen never get sent.

### Pitfall 6: Catch-Up After Downtime Sends Floods
**What goes wrong:** After multi-day downtime, the catch-up scan finds many unsent reminders and sends them all at once.
**Why it happens:** "Scan for any unsent reminders regardless of original due date" + no rate limiting.
**How to avoid:** Deduplication prevents true duplicates, but consider batch size limits or a brief delay between sends to avoid SMTP rate limits. The 3-day maximum retry age for email also helps.
**Warning signs:** SMTP server rejecting emails due to rate limiting after extended downtime.

## Code Examples

### Existing Worker Registration Pattern (verified from src/worker.ts)
```typescript
// Source: src/worker.ts lines 23-33
const testWorker = new Worker<TestJobData>(
  "test",
  async (job) => testProcessor(job),
  {
    connection,
    concurrency,
    settings: {
      backoffStrategy: (attemptsMade: number) => calculateBackoff(attemptsMade),
    },
  }
);
```

### Existing Queue Registry (verified from src/lib/queue/queues.ts)
```typescript
// Source: src/lib/queue/queues.ts lines 24-31
export const testQueue = new Queue("test", {
  connection: getQueueConnection(),
  defaultJobOptions,
});

export const ALL_QUEUES: Queue[] = [testQueue];
```

### Existing Frist Reminder Processor (verified from src/workers/processors/frist-reminder.ts)
```typescript
// Source: src/workers/processors/frist-reminder.ts lines 225-326
export async function processFristReminders(): Promise<{
  deactivated: number;
  vorfristenSent: number;
  overdueSent: number;
}> {
  // Step 1: Auto-deactivate expired Vertretungen
  // Step 2: Find all active FRIST entries
  // Step 3: Check vorfristen[], vorfrist, halbfrist dates against today
  // Step 4: Check for overdue and escalate
}
```

### Existing Lazy Queue (to be consolidated, from src/lib/queues.ts)
```typescript
// Source: src/lib/queues.ts lines 34-59
export function getFristReminderQueue(): Queue { ... }
export async function registerFristReminderJob() {
  const queue = getFristReminderQueue();
  await queue.upsertJobScheduler(
    "frist-reminder-check",
    { pattern: "*/5 7-19 * * 1-5" },  // NEEDS UPDATE: should be "0 6 * * *" with tz
    { name: "check-fristen", data: {}, opts: { ... } }
  );
}
```

### BullMQ upsertJobScheduler with Timezone
```typescript
// Source: BullMQ v5 API
await fristReminderQueue.upsertJobScheduler(
  "frist-reminder-daily",
  {
    pattern: "0 6 * * *",
    tz: "Europe/Berlin",
  },
  {
    name: "check-fristen",
    data: {},
    opts: {
      removeOnComplete: { count: 100 },
      removeOnFail: { count: 50 },
    },
  }
);
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| `addRepeatable()` | `upsertJobScheduler()` | BullMQ v5 | New API is idempotent, replaces old repeatable job API |
| Separate queue files per feature | Single registry file | Convention in this project | ALL_QUEUES array drives admin monitoring -- must be single source of truth |

**Deprecated/outdated:**
- `Queue.add()` with `repeat` option: Replaced by `upsertJobScheduler()` in BullMQ v5. The codebase already uses the new API in `src/lib/queues.ts`.

## Open Questions

1. **Admin-configurable cron schedule**
   - What we know: User wants scan time configurable in Kanzlei-Einstellungen (stored in SystemSettings). The fristen-tab already has `arbeitszeitStart` / `arbeitszeitEnde` settings.
   - What's unclear: Should changing the scan time immediately reschedule the cron, or take effect on next worker restart? Immediate reschedule requires the worker to listen for settings changes (the Redis pub/sub channel `settings:changed` already exists).
   - Recommendation: Read cron time from SystemSettings at worker startup. Listen for `settings:changed` events to re-register the cron when admin changes it. Add a new setting `fristen_scan_zeit` (default "06:00") to DEFAULT_SETTINGS.

2. **Email user address source**
   - What we know: Email notifications need a recipient address. The Prisma User model likely has an `email` field.
   - What's unclear: What if a user has no email configured?
   - Recommendation: Skip email channel silently for users without email. Log a warning. In-app notification always succeeds.

3. **Holiday shift for reminders**
   - What we know: User wants weekend reminders shifted to preceding Friday. German holidays (Feiertage) are also mentioned as needing shift.
   - What's unclear: Does holiday shift apply to the reminder send date or just to Frist calculation? The Frist calculation engine already handles holidays.
   - Recommendation: Apply the same weekend/holiday shift to the vorfrist reminder date: if the vorfrist date falls on a weekend or holiday, send the reminder on the preceding business day. Use the existing feiertagejs integration for holiday checks.

## Sources

### Primary (HIGH confidence)
- `src/worker.ts` -- verified existing worker registration pattern, shutdown handling, settings subscription
- `src/workers/processors/frist-reminder.ts` -- verified processor implementation, notification routing, escalation chain
- `src/lib/queue/queues.ts` -- verified ALL_QUEUES registry, defaultJobOptions, calculateBackoff
- `src/lib/queues.ts` -- verified duplicate queue file with getFristReminderQueue and registerFristReminderJob
- `src/lib/settings/service.ts` -- verified initializeDefaults() implementation, upsert strategy
- `src/lib/settings/defaults.ts` -- verified DEFAULT_SETTINGS array, categories
- `src/lib/notifications/service.ts` -- verified createNotification() with Socket.IO emitter
- `src/lib/queue/connection.ts` -- verified getQueueConnection() and getWorkerConnection() helpers
- `src/app/api/admin/jobs/[[...path]]/route.ts` -- verified admin monitoring reads from ALL_QUEUES
- `prisma/schema.prisma` -- verified KalenderEintrag, SystemSetting, Notification models
- `package.json` -- verified bullmq ^5.70.1, ioredis ^5.9.3 installed; nodemailer NOT installed
- `docker-compose.yml` -- verified worker runs `dist-worker/index.js`, depends on Redis + DB + app

### Secondary (MEDIUM confidence)
- BullMQ v5 `upsertJobScheduler` API with `tz` parameter -- consistent with codebase usage and BullMQ v5 documentation

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH -- all libraries already installed except nodemailer; integration patterns verified in codebase
- Architecture: HIGH -- existing testWorker pattern provides exact template; consolidation path is clear
- Pitfalls: HIGH -- identified from actual codebase analysis (dual queue files, missing timezone, weekend shift gap)

**Research date:** 2026-02-24
**Valid until:** 2026-03-24 (stable -- wiring existing code, no external API changes expected)
