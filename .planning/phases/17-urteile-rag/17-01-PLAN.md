---
phase: 17-urteile-rag
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/urteile/rss-client.ts
  - src/lib/urteile/ingestion.ts
autonomous: true
requirements: [URTEIL-01]

must_haves:
  truths:
    - "fetchUrteileFeed('BAG') returns an array of UrteilRssItem with aktenzeichen, datum, leitsatz, sourceUrl for each live RSS item"
    - "ingestUrteilItem() returns 'inserted' for a PII-clean item, 'pii_rejected' for a PII-flagged item, and 'error' on failure — never throws"
    - "searchUrteilChunks() queries urteil_chunks via pgvector cosine similarity, filters out empty aktenzeichen, returns UrteilChunkResult[] sorted by score"
    - "No PII-flagged item ever has piiFiltered=true in urteil_chunks — hasPii:true always returns 'pii_rejected'"
    - "GUID cache load/save round-trips correctly via getSetting/updateSetting with key 'urteile.seen_guids'"
  artifacts:
    - path: "src/lib/urteile/rss-client.ts"
      provides: "BMJ RSS feed fetcher + XML parser + UrteilRssItem type + BMJ_RSS_FEEDS map"
      exports: ["fetchUrteileFeed", "UrteilRssItem", "BMJ_RSS_FEEDS"]
    - path: "src/lib/urteile/ingestion.ts"
      provides: "UrteilChunk ingestion with inline NER gate, GUID cache helpers, pgvector search"
      exports: ["ingestUrteilItem", "loadGuidCache", "saveGuidCache", "searchUrteilChunks", "UrteilChunkResult"]
  key_links:
    - from: "src/lib/urteile/ingestion.ts"
      to: "src/lib/pii/ner-filter.ts"
      via: "runNerFilter() called inline before any pgvector INSERT"
      pattern: "runNerFilter"
    - from: "src/lib/urteile/ingestion.ts"
      to: "prisma.$executeRaw"
      via: "DELETE+INSERT with pgvector::vector cast — same as upsertLawChunks"
      pattern: "executeRaw.*urteil_chunks"
    - from: "src/lib/urteile/ingestion.ts"
      to: "getSetting/updateSetting"
      via: "GUID cache stored as JSON in SystemSetting key 'urteile.seen_guids'"
      pattern: "urteile.seen_guids"
---

<objective>
Create the `src/lib/urteile/` library — the core data access layer for Urteile-RAG.

Purpose: All downstream plans (BullMQ processor in Plan 02, ki-chat Chain E in Plan 03) import from this library. It must exist and be correct before either can be implemented.

Output: Two TypeScript files that encapsulate RSS fetching, XML parsing, PII-gated ingestion, GUID-based deduplication, and pgvector search for urteil_chunks.
</objective>

<execution_context>
@/Users/patrickbaumfalk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/patrickbaumfalk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/17-urteile-rag/17-RESEARCH.md
@.planning/phases/16-pii-filter/16-01-SUMMARY.md

<interfaces>
<!-- Key types and contracts the executor needs — extracted from codebase. -->

From src/lib/pii/ner-filter.ts:
```typescript
export interface NerResult { persons: string[]; hasPii: boolean; }
export async function runNerFilter(text: string): Promise<NerResult>
// Throws (uncaught AbortError) on 45s timeout — BRAO §43a compliance
// NER_TIMEOUT_MS = 45_000
```

From src/lib/embedding/embedder.ts:
```typescript
export async function generateEmbedding(text: string): Promise<number[]>
export const MODEL_VERSION: string  // e.g. "mxbai-embed-large"
```

From src/lib/settings/service.ts:
```typescript
export async function getSetting(key: string): Promise<string | null>
export async function updateSetting(key: string, value: string): Promise<void>
```

From src/lib/db.ts:
```typescript
export const prisma: PrismaClient
```

From src/lib/gesetze/ingestion.ts (mirror pattern):
```typescript
// DELETE+INSERT idempotency pattern with pgvector::vector cast
await prisma.$executeRaw`DELETE FROM law_chunks WHERE "sourceUrl" = ${url}`;
await prisma.$executeRaw`INSERT INTO law_chunks (...) VALUES (..., ${vectorSql}::vector, ...)`;
// GUID cache pattern (adapted from SHA cache):
const raw = await getSetting("urteile.seen_guids");
const guids = new Set(JSON.parse(raw ?? "[]") as string[]);
await updateSetting("urteile.seen_guids", JSON.stringify([...guids]));
```

From prisma/schema.prisma — UrteilChunk model fields (verified):
```
id           String    @id @default(uuid())
aktenzeichen String
gericht      String
datum        DateTime
rechtsgebiet String?
content      String
parentContent String
embedding    Unsupported("vector(1024)")?
modelVersion String
sourceUrl    String    @unique
piiFiltered  Boolean   @default(false)
ingestedAt   DateTime  @default(now())
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create rss-client.ts — BMJ RSS feed fetcher and XML parser</name>
  <files>src/lib/urteile/rss-client.ts</files>
  <action>
Create `src/lib/urteile/rss-client.ts`. This file has no external imports beyond `fast-xml-parser` (already in package.json as v5.3.8).

**BMJ_RSS_FEEDS constant** (all 7 verified live 2026-02-27):
```typescript
export const BMJ_RSS_FEEDS: Record<string, string> = {
  BGH:    "https://www.rechtsprechung-im-internet.de/jportal/docs/feed/bsjrs-bgh.xml",
  BAG:    "https://www.rechtsprechung-im-internet.de/jportal/docs/feed/bsjrs-bag.xml",
  BVerwG: "https://www.rechtsprechung-im-internet.de/jportal/docs/feed/bsjrs-bverwg.xml",
  BFH:    "https://www.rechtsprechung-im-internet.de/jportal/docs/feed/bsjrs-bfh.xml",
  BSG:    "https://www.rechtsprechung-im-internet.de/jportal/docs/feed/bsjrs-bsg.xml",
  BPatG:  "https://www.rechtsprechung-im-internet.de/jportal/docs/feed/bsjrs-bpatg.xml",
  BVerfG: "https://www.rechtsprechung-im-internet.de/jportal/docs/feed/bsjrs-bverfg.xml",
};
```

**UrteilRssItem interface** (export):
```typescript
export interface UrteilRssItem {
  guid: string;           // idempotency key
  gericht: string;        // e.g. "BAG"
  aktenzeichen: string;   // e.g. "7 AZR 185/24"
  datum: Date;
  entscheidungstyp: string; // e.g. "Urteil", "Beschluss"
  leitsatz: string;       // may be empty for BGH items
  sourceUrl: string;
  rechtsgebiet?: string;
}
```

**RECHTSGEBIET_MAP** (non-exported, internal):
BAG → "Arbeitsrecht", BGH → "Zivilrecht", BVerwG → "Verwaltungsrecht", BFH → "Steuerrecht", BSG → "Sozialrecht", BPatG → "Patentrecht", BVerfG → "Verfassungsrecht"

**Title parsing** — use a LOOSE regex to handle BVerfG Kammerbeschluss, Nichtannahmebeschluss, Gerichtsbescheid variants:
```typescript
// Matches: "GERICHT Senat, TYPE vom DD.MM.YYYY, AZ"
const TITLE_REGEX = /^.+?,\s*(.+?)\s+vom\s+(\d{2})\.(\d{2})\.(\d{4}),\s+(.+)$/;
```
Capture groups: [1]=entscheidungstyp, [2]=day, [3]=month, [4]=year, [5]=aktenzeichen. Wrap in try/catch — on parse failure, return [] (flatMap pattern) and log the failed title.

**XMLParser config** (mirrors xjustiz/parser.ts pattern):
```typescript
const parser = new XMLParser({
  ignoreAttributes: false,
  parseAttributeValues: true,
  isArray: (name) => name === "item",
});
```

**fetchUrteileFeed(gerichtCode: string): Promise<UrteilRssItem[]>**:
1. Look up URL from BMJ_RSS_FEEDS — throw if unknown code
2. Fetch with `AbortSignal.timeout(15_000)`
3. Parse with XMLParser
4. Access `parsed?.rss?.channel?.item ?? []`
5. For each item: guid extraction handles both `string` and `{ "#text": string }` shapes
6. leitsatz = `item.description ?? ""`
7. Use flatMap so parse failures silently skip the item (return [])
8. Set rechtsgebiet from RECHTSGEBIET_MAP[gerichtCode]

**Export only:** `BMJ_RSS_FEEDS`, `UrteilRssItem`, `fetchUrteileFeed`
  </action>
  <verify>
    <automated>cd /Users/patrickbaumfalk/Projekte/AI-Lawyer && npx tsc --noEmit 2>&1 | grep -i "urteile" | head -20</automated>
  </verify>
  <done>
    src/lib/urteile/rss-client.ts exists, exports BMJ_RSS_FEEDS + UrteilRssItem + fetchUrteileFeed. `npx tsc --noEmit` shows zero errors in urteile/ files.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ingestion.ts — PII-gated ingestion, GUID cache, pgvector search</name>
  <files>src/lib/urteile/ingestion.ts</files>
  <action>
Create `src/lib/urteile/ingestion.ts`. Mirrors `src/lib/gesetze/ingestion.ts` structure exactly.

**Imports:**
```typescript
import pgvector from "pgvector";
import { prisma } from "@/lib/db";
import { generateEmbedding, MODEL_VERSION } from "@/lib/embedding/embedder";
import { runNerFilter } from "@/lib/pii/ner-filter";
import { getSetting, updateSetting } from "@/lib/settings/service";
import type { UrteilRssItem } from "./rss-client";
```

**GUID_CACHE_KEY = "urteile.seen_guids"** (module-level constant)

**loadGuidCache(): Promise<Set<string>>**:
- `getSetting(GUID_CACHE_KEY)` → if null return new Set()
- `new Set(JSON.parse(raw) as string[])`

**saveGuidCache(guids: Set<string>): Promise<void>**:
- `updateSetting(GUID_CACHE_KEY, JSON.stringify([...guids]))`

**UrteilChunkResult interface** (export):
```typescript
export interface UrteilChunkResult {
  id: string;
  aktenzeichen: string;
  gericht: string;
  datum: Date;
  rechtsgebiet: string | null;
  content: string;
  sourceUrl: string;
  score: number;
}
```

**ingestUrteilItem(item: UrteilRssItem): Promise<"inserted" | "pii_rejected" | "error">**:
1. Build `nerText`: `item.leitsatz` if non-empty, else `"${item.entscheidungstyp} des ${item.gericht} vom ${item.datum.toLocaleDateString("de-DE")} (${item.aktenzeichen})"`
2. Call `runNerFilter(nerText)` — if `result.hasPii` return `"pii_rejected"` (do NOT throw, do NOT insert)
3. Build `content`: same as nerText fallback logic — leitsatz preferred, else structured string
4. `generateEmbedding(content)` → `pgvector.toSql(embedding)` → vectorSql
5. DELETE+INSERT pattern (idempotent):
   ```sql
   DELETE FROM urteil_chunks WHERE "sourceUrl" = ${item.sourceUrl}
   INSERT INTO urteil_chunks (id, aktenzeichen, gericht, datum, rechtsgebiet, content, "parentContent", embedding, "modelVersion", "sourceUrl", "piiFiltered", "ingestedAt")
   VALUES (gen_random_uuid(), ${item.aktenzeichen}, ${item.gericht}, ${item.datum}, ${item.rechtsgebiet ?? null}, ${content}, ${content}, ${vectorSql}::vector, ${MODEL_VERSION}, ${item.sourceUrl}, true, NOW())
   ```
6. Return `"inserted"` on success
7. Wrap entire function in try/catch — catch returns `"error"` (log the error via console.error)

**CRITICAL:** On `runNerFilter` AbortError (Ollama unreachable): the abort propagates as thrown error from runNerFilter → caught by outer try/catch → returns `"error"`. Do NOT add a separate AbortError handler — the "error" result tells the processor not to mark the GUID as seen, so it retries on next cron. This is correct behavior per research Pitfall 5.

**searchUrteilChunks(queryEmbedding: number[], opts?: { limit?: number; minScore?: number }): Promise<UrteilChunkResult[]>**:
```sql
SELECT id, aktenzeichen, gericht, datum, rechtsgebiet, content, "sourceUrl",
  1 - (embedding <=> ${vectorSql}::vector) AS score
FROM urteil_chunks
WHERE embedding IS NOT NULL
  AND "piiFiltered" = true
ORDER BY embedding <=> ${vectorSql}::vector ASC
LIMIT ${limit}
```
Post-filter: filter rows where `aktenzeichen` is empty/null (URTEIL-04 compliance), then filter by minScore. Map score to `Number(r.score)`.

Default opts: `limit = 5, minScore = 0.0`

**Export:** `ingestUrteilItem`, `loadGuidCache`, `saveGuidCache`, `searchUrteilChunks`, `UrteilChunkResult`
  </action>
  <verify>
    <automated>cd /Users/patrickbaumfalk/Projekte/AI-Lawyer && npx tsc --noEmit 2>&1 | grep -i "urteile" | head -20</automated>
  </verify>
  <done>
    src/lib/urteile/ingestion.ts exists, exports ingestUrteilItem + loadGuidCache + saveGuidCache + searchUrteilChunks + UrteilChunkResult. Zero TypeScript errors in urteile/ files. Function signatures match the interface contracts above.
  </done>
</task>

</tasks>

<verification>
After both tasks:
1. `npx tsc --noEmit` exits 0 — zero TypeScript errors across all files
2. `src/lib/urteile/rss-client.ts` and `src/lib/urteile/ingestion.ts` exist
3. Both files export their required symbols (grep check):
   - `grep -n "export" src/lib/urteile/rss-client.ts` shows: BMJ_RSS_FEEDS, UrteilRssItem, fetchUrteileFeed
   - `grep -n "export" src/lib/urteile/ingestion.ts` shows: UrteilChunkResult, ingestUrteilItem, loadGuidCache, saveGuidCache, searchUrteilChunks
4. `grep "runNerFilter" src/lib/urteile/ingestion.ts` confirms PII gate is wired
5. `grep "piiFiltered.*true" src/lib/urteile/ingestion.ts` confirms only NER-clean items are inserted as piiFiltered=true
</verification>

<success_criteria>
- src/lib/urteile/rss-client.ts: BMJ_RSS_FEEDS (7 courts), UrteilRssItem interface, fetchUrteileFeed with loose title regex and graceful fallback for BGH empty descriptions
- src/lib/urteile/ingestion.ts: ingestUrteilItem with inline NER gate (hasPii → "pii_rejected", no insert), DELETE+INSERT idempotency, searchUrteilChunks with empty-aktenzeichen filter
- TypeScript compiles clean
- Plan 02 (BullMQ processor) and Plan 03 (ki-chat Chain E) can import from these files without further changes
</success_criteria>

<output>
After completion, create `.planning/phases/17-urteile-rag/17-01-SUMMARY.md`
</output>
