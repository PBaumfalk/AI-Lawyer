---
phase: 01-infrastructure-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/server.ts
  - src/lib/socket/server.ts
  - src/lib/socket/auth.ts
  - src/lib/socket/rooms.ts
  - src/lib/notifications/service.ts
  - src/lib/notifications/types.ts
  - src/components/socket-provider.tsx
  - src/components/notifications/notification-provider.tsx
  - src/components/notifications/notification-bell.tsx
  - src/components/notifications/notification-center.tsx
  - src/app/api/notifications/route.ts
  - src/app/(dashboard)/layout.tsx
autonomous: true
requirements:
  - REQ-IF-003

must_haves:
  truths:
    - "Socket.IO WebSocket connections from the browser successfully establish through the custom server.ts on port 3000"
    - "Authenticated users receive real-time toast notifications when a job completes or fails"
    - "Bell icon in the header shows unread notification count badge"
    - "Notification center dropdown displays last 50 notifications with mark-as-read and navigate actions"
    - "After disconnect and reconnect, missed notifications are fetched via catch-up API"
    - "Unauthenticated Socket.IO connections are rejected"
  artifacts:
    - path: "src/server.ts"
      provides: "Custom Next.js server with Socket.IO on same port"
      contains: "Server"
    - path: "src/lib/socket/auth.ts"
      provides: "JWT authentication middleware for Socket.IO handshake"
      exports: ["setupSocketAuth"]
    - path: "src/lib/socket/rooms.ts"
      provides: "Room join/leave logic for user, akte, role rooms"
      exports: ["setupRooms"]
    - path: "src/lib/notifications/service.ts"
      provides: "Notification CRUD (create, list, mark read, dismiss)"
      exports: ["createNotification", "getUnreadNotifications", "markAsRead"]
    - path: "src/components/notifications/notification-bell.tsx"
      provides: "Header bell icon with unread count badge"
      min_lines: 30
    - path: "src/components/notifications/notification-center.tsx"
      provides: "Dropdown showing last 50 notifications"
      min_lines: 50
    - path: "src/app/api/notifications/route.ts"
      provides: "REST API for notification catch-up and management"
      exports: ["GET", "PATCH"]
  key_links:
    - from: "src/server.ts"
      to: "src/lib/socket/server.ts"
      via: "imports Socket.IO setup function"
      pattern: "setupSocketIO"
    - from: "src/lib/socket/auth.ts"
      to: "next-auth JWT"
      via: "validates NextAuth session token in handshake"
      pattern: "verify.*token"
    - from: "src/components/socket-provider.tsx"
      to: "src/server.ts"
      via: "Socket.IO client connects to same-origin server"
      pattern: "io\\("
    - from: "src/components/notifications/notification-provider.tsx"
      to: "src/lib/notifications/service.ts"
      via: "fetches missed notifications on reconnect"
      pattern: "api/notifications"
    - from: "src/app/(dashboard)/layout.tsx"
      to: "src/components/socket-provider.tsx"
      via: "wraps dashboard in SocketProvider"
      pattern: "SocketProvider"
---

<objective>
Create the custom server.ts that wraps Next.js with Socket.IO for real-time WebSocket communication, implement the full notification system (persistence, real-time delivery, catch-up on reconnect), and integrate the notification bell + center into the dashboard layout.

Purpose: Real-time notifications are the communication backbone for the entire application. Every future feature (email sync, OCR processing, AI drafts, document collaboration) notifies users via this system. The custom server.ts replaces the default Next.js server to serve both HTTP and WebSocket on the same port.

Output: Working custom server.ts with Socket.IO, notification service with persistence, React components for notification bell + center, catch-up API for missed notifications.
</objective>

<execution_context>
@/Users/patrickbaumfalk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/patrickbaumfalk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-infrastructure-foundation/01-RESEARCH.md
@.planning/phases/01-infrastructure-foundation/01-CONTEXT.md
@.planning/phases/01-infrastructure-foundation/01-01-SUMMARY.md

@src/lib/redis.ts
@src/lib/logger.ts
@src/lib/auth.ts
@src/lib/db.ts
@src/app/(dashboard)/layout.tsx
@src/components/layout/header.tsx
@src/types/next-auth.d.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create custom server.ts with Socket.IO, JWT auth middleware, and room management</name>
  <files>
    src/server.ts
    src/lib/socket/server.ts
    src/lib/socket/auth.ts
    src/lib/socket/rooms.ts
    src/components/socket-provider.tsx
  </files>
  <action>
    1. Create `src/lib/socket/server.ts` — Socket.IO server setup function:
       - Export `setupSocketIO(httpServer: HttpServer): Server`
       - Create Socket.IO server with Redis adapter:
         - Create pub/sub Redis clients via `createRedisConnection()` from redis.ts (use .duplicate() for sub client)
         - Apply `createAdapter(pubClient, subClient)` from @socket.io/redis-adapter
         - CORS: dev mode → `"*"`, production → `false`
       - Call `setupSocketAuth(io)` for JWT middleware
       - Call `setupRooms(io)` for room management
       - Return the io instance

    2. Create `src/lib/socket/auth.ts` — JWT authentication middleware:
       - Export `setupSocketAuth(io: Server): void`
       - Implement io.use() middleware that:
         - Extracts token from `socket.handshake.auth?.token`
         - If no token: try extracting from `socket.handshake.headers.cookie` — parse the `next-auth.session-token` cookie
         - Verify token using `process.env.NEXTAUTH_SECRET` via jsonwebtoken `jwt.verify()`
         - On success: set `socket.data.userId`, `socket.data.role`, `socket.data.kanzleiId` from decoded payload
         - On failure: `next(new Error("Authentifizierung erforderlich"))` or `next(new Error("Ungueltiges Token"))`
       - Note: NextAuth v5 beta uses JWT strategy. The research noted Open Question #1 — try cookie approach first, fall back to explicit token. Implement BOTH: prefer cookie (approach a), fall back to auth.token (approach b).

    3. Create `src/lib/socket/rooms.ts` — Room join/leave logic:
       - Export `setupRooms(io: Server): void`
       - On connection:
         - Auto-join `user:{socket.data.userId}` room (personal notifications)
         - Auto-join `role:{socket.data.role}` room (role-based broadcasts)
         - Log connection with userId
       - Listen for `join:akte` event: join `akte:{akteId}` room (case-specific notifications — joined when user views an Akte)
       - Listen for `leave:akte` event: leave `akte:{akteId}` room
       - On disconnect: log disconnection (Socket.IO auto-removes from rooms)

    4. Create `src/server.ts` — Custom Next.js server entrypoint:
       - Import `next` from "next", `createServer` from "node:http"
       - Import `setupSocketIO` from lib/socket/server
       - Import `createLogger` from lib/logger
       - Standard Next.js custom server pattern:
         - `const dev = process.env.NODE_ENV !== "production"`
         - `const hostname = process.env.HOSTNAME || "0.0.0.0"`
         - `const port = parseInt(process.env.PORT || "3000", 10)`
         - Prepare Next.js app, create HTTP server from request handler
         - Call `setupSocketIO(httpServer)` to attach Socket.IO
         - Listen on port, log readiness
       - NOTE: This file is bundled by esbuild (scripts/build-server.ts from Plan 01). It MUST work with the existing esbuild config (externals: next, sharp, @prisma/client).

    5. Create `src/components/socket-provider.tsx` — React context provider:
       - "use client" component
       - Export `SocketProvider` component and `useSocket()` hook
       - Uses `useSession()` from next-auth/react to get current session
       - On session available:
         - Create Socket.IO client: `io({ auth: { token: sessionToken }, reconnection: true, reconnectionDelay: 1000, reconnectionDelayMax: 5000 })`
         - Token extraction: The session object from NextAuth v5 should contain the JWT or we need to fetch it. Use `fetch('/api/auth/session')` to get session data, or pass the access token if available.
         - Alternative approach: Don't pass explicit token — let the Socket.IO client send cookies automatically (since same-origin). The auth middleware in auth.ts handles cookie extraction.
         - Actually prefer the cookie approach (same-origin, no explicit token needed): `io({ withCredentials: true, reconnection: true, reconnectionDelay: 1000, reconnectionDelayMax: 5000 })`
       - Track connection state: `isConnected` boolean
       - Provide `{ socket, isConnected }` via context
       - Cleanup: disconnect on unmount or session change
  </action>
  <verify>
    <automated>cd /Users/patrickbaumfalk/Projekte/AI-Lawyer && npx tsc --noEmit --pretty 2>&1 | head -30</automated>
    <manual>After docker compose up, check browser dev tools Network tab for WebSocket connection to ws://localhost:3000/socket.io/</manual>
  </verify>
  <done>
    - server.ts creates HTTP server wrapping Next.js with Socket.IO attached on same port
    - Socket.IO uses Redis adapter for cross-process communication
    - JWT auth middleware validates NextAuth tokens (cookie or explicit) in handshake
    - Room management auto-joins user:{id} and role:{ROLE} rooms on connect
    - Client can join/leave akte:{id} rooms dynamically
    - SocketProvider React context provides socket instance and connection state
    - Unauthenticated connections are rejected with German error message
  </done>
</task>

<task type="auto">
  <name>Task 2: Build notification service, bell icon, notification center, and catch-up API</name>
  <files>
    src/lib/notifications/service.ts
    src/lib/notifications/types.ts
    src/components/notifications/notification-provider.tsx
    src/components/notifications/notification-bell.tsx
    src/components/notifications/notification-center.tsx
    src/app/api/notifications/route.ts
    src/app/(dashboard)/layout.tsx
  </files>
  <action>
    1. Create `src/lib/notifications/types.ts` — Notification type definitions:
       - Export `NotificationType` enum/union: "job:completed", "job:failed", "document:created", "document:updated", "email:received", "deadline:approaching", "system:alert"
       - Export `NotificationPayload` interface: `{ type: NotificationType; title: string; message: string; data?: Record<string, unknown>; soundType?: string; userId: string }`
       - Export `NotificationResponse` interface for API responses (id, type, title, message, data, read, dismissed, createdAt)

    2. Create `src/lib/notifications/service.ts` — Notification persistence + delivery:
       - Export `createNotification(payload: NotificationPayload): Promise<Notification>`:
         - Save to database via Prisma
         - Emit via Socket.IO redis emitter (`getSocketEmitter().to(\`user:${userId}\`).emit("notification", notificationData)`)
         - Return created notification
       - Export `getUnreadNotifications(userId: string, limit?: number): Promise<Notification[]>`:
         - Query: where userId, read: false, dismissed: false, orderBy createdAt desc, take limit (default 50 per user decision)
       - Export `getNotificationsSince(userId: string, since: Date): Promise<Notification[]>`:
         - Query: where userId, createdAt > since, orderBy createdAt desc
         - Used for catch-up after reconnect
       - Export `markAsRead(notificationId: string, userId: string): Promise<void>`:
         - Update where id AND userId (security: user can only mark their own)
       - Export `markAllAsRead(userId: string): Promise<void>`:
         - Update many where userId, read: false → read: true
       - Export `dismissNotification(notificationId: string, userId: string): Promise<void>`:
         - Update dismissed: true where id AND userId
       - Export `getUnreadCount(userId: string): Promise<number>`:
         - Count where userId, read: false, dismissed: false

    3. Create `src/app/api/notifications/route.ts` — REST endpoints:
       - GET handler: requires auth
         - Query params: `since` (ISO timestamp for catch-up), `limit` (default 50)
         - If `since` provided: return getNotificationsSince(userId, new Date(since))
         - Otherwise: return getUnreadNotifications(userId, limit)
         - Also return `unreadCount` in response
       - PATCH handler: requires auth
         - Body: `{ action: "read" | "readAll" | "dismiss", notificationId?: string }`
         - "read" + notificationId: markAsRead
         - "readAll": markAllAsRead
         - "dismiss" + notificationId: dismissNotification
         - Return updated unread count

    4. Create `src/components/notifications/notification-provider.tsx` — Client-side notification manager:
       - "use client" component
       - Export `NotificationProvider` wrapping children
       - Export `useNotifications()` hook returning `{ notifications, unreadCount, markAsRead, markAllAsRead, dismiss }`
       - On mount + when socket connects:
         - Fetch initial unread notifications from GET /api/notifications
         - Store in local state
       - Listen for `socket.on("notification", callback)`:
         - Add to local notifications array (prepend, cap at 50)
         - Increment unread count
         - Show sonner toast: `toast(notification.title, { description: notification.message, action: notification.data?.link ? { label: "Anzeigen", onClick: () => router.push(link) } : undefined })`
         - If notification has soundType and user has sound enabled: play sound (use Audio API)
       - On reconnect (socket "connect" event after disconnect):
         - Fetch missed notifications since last-seen timestamp via GET /api/notifications?since={lastSeenTimestamp}
         - Merge into local state, deduplicate by id
       - Request browser push notification permission on first render (Notification API):
         - Only if not already granted/denied
         - When tab is not visible (document.hidden) and notification received: show browser Notification

    5. Create `src/components/notifications/notification-bell.tsx` — Header bell icon:
       - "use client" component
       - Uses `useNotifications()` hook for unreadCount
       - Renders lucide-react `Bell` icon
       - If unreadCount > 0: show red badge with count (cap display at "99+")
       - On click: toggle notification center dropdown
       - Use Popover from shadcn/ui for dropdown positioning

    6. Create `src/components/notifications/notification-center.tsx` — Dropdown notification list:
       - "use client" component
       - Uses `useNotifications()` hook
       - Header: "Benachrichtigungen" title + "Alle gelesen" button (calls markAllAsRead)
       - List: show notifications with:
         - Icon per notification type (lucide-react icons)
         - Title (bold if unread)
         - Message (truncated to 2 lines)
         - Relative time (date-fns formatDistanceToNow with locale de)
         - Click: navigate to data.link if present, mark as read
         - Dismiss button (X icon)
       - Empty state: "Keine neuen Benachrichtigungen"
       - Scrollable (ScrollArea from shadcn/ui), max height ~400px
       - Use shadcn/ui Card, ScrollArea, Button, Separator

    7. Update `src/app/(dashboard)/layout.tsx`:
       - Import and wrap children with `SocketProvider` (inside SessionProvider)
       - Import and wrap with `NotificationProvider` (inside SocketProvider)
       - Add `NotificationBell` component to the header area (next to user menu)
       - Ensure the provider hierarchy is: SessionProvider > SocketProvider > NotificationProvider > children
  </action>
  <verify>
    <automated>cd /Users/patrickbaumfalk/Projekte/AI-Lawyer && npx tsc --noEmit --pretty 2>&1 | head -30</automated>
    <manual>After docker compose up and logging in: bell icon visible in header, click opens notification center dropdown, enqueuing a test job via /api/admin/test-job shows a toast notification</manual>
  </verify>
  <done>
    - Notification service persists notifications to DB and emits via Socket.IO
    - GET /api/notifications returns unread notifications with catch-up support (since parameter)
    - PATCH /api/notifications supports read, readAll, and dismiss actions
    - NotificationProvider manages local notification state, handles real-time events, shows toasts, handles reconnect catch-up
    - Bell icon shows unread count badge, click opens notification center
    - Notification center shows last 50 notifications with title, message, time, read/dismiss actions
    - Browser push notifications shown when tab is backgrounded
    - Dashboard layout wraps content in SocketProvider > NotificationProvider
    - All German UI text ("Benachrichtigungen", "Alle gelesen", "Keine neuen Benachrichtigungen")
  </done>
</task>

</tasks>

<verification>
1. Browser WebSocket connection establishes to ws://localhost:3000/socket.io/ after login
2. Bell icon appears in header with badge count
3. Enqueuing a test job via POST /api/admin/test-job triggers a toast notification in the browser
4. Notification center dropdown shows the notification with correct title and message
5. Clicking "Alle gelesen" marks all notifications as read (badge count resets to 0)
6. Disconnecting network and reconnecting fetches missed notifications via catch-up API
7. Unauthenticated WebSocket connection attempts are rejected
</verification>

<success_criteria>
- Custom server.ts serves both Next.js HTTP and Socket.IO WebSocket on port 3000
- Socket.IO uses Redis adapter for cross-process pub/sub
- JWT authentication validates NextAuth tokens in Socket.IO handshake
- Room strategy implemented: user:{id}, akte:{id}, role:{ROLE}
- Notifications are persisted to database and delivered in real-time
- Catch-up mechanism fetches missed notifications on reconnect
- Bell icon with badge and notification center dropdown work correctly
- German UI labels throughout
</success_criteria>

<output>
After completion, create `.planning/phases/01-infrastructure-foundation/01-02-SUMMARY.md`
</output>
