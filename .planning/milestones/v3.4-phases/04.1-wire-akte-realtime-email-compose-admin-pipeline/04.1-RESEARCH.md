# Phase 4.1: Wire Akte Real-Time + Email Compose + Admin Pipeline - Research

**Researched:** 2026-02-24
**Domain:** Cross-phase integration wiring (Socket.IO rooms, React context, admin UI)
**Confidence:** HIGH

## Summary

Phase 4.1 is a pure wiring phase that connects existing infrastructure built across Phases 1, 3.1, and 4. All backend components are already implemented and working -- the gap is entirely in the browser-side connections. Specifically: (1) Akte pages never emit `join:akte`/`leave:akte` events so the `akte:{akteId}` Socket.IO room is always empty and OCR completion events from the worker never reach the browser, (2) the email inbox has no "Neue E-Mail" FAB button to trigger `openCompose()` from the ComposeManager context, (3) there is no admin pipeline dashboard page at `/admin/pipeline`, and (4) OCR completion/failure needs global toast notifications beyond just the upload panel.

The existing code quality is high. All backend pieces are production-ready: the Socket.IO room handlers accept `join:akte`/`leave:akte` events, the worker emits `document:ocr-complete` to `akte:{akteId}` rooms, the ComposeManager context exposes `openCompose()`, and the admin pipeline API returns queue stats. No new libraries are needed.

**Primary recommendation:** Wire four client-side connections using existing infrastructure -- no new backend code, no new libraries, no new patterns. Pure React component additions and Socket.IO event wiring.

<user_constraints>
## User Constraints (from CONTEXT.md)

### Locked Decisions
- **OCR status display**: Spinner + "OCR laeuft..." in upload panel while processing. On success: fade to green checkmark + "OCR abgeschlossen". On failure: red "OCR fehlgeschlagen" + retry icon. Status visible in upload panel only (not document list or detail).
- **Admin pipeline dashboard**: Dedicated page at `/admin/pipeline`. Queue counts (pending/processing/completed/failed) per queue (OCR, embedding) + recent jobs table. Auto-refresh via polling 10-30s. Retry button per failed job row.
- **Neue E-Mail button**: FAB in bottom-right corner (Gmail-style). Pen/edit icon + "Neue E-Mail" text. Visible on all email-related pages. Multiple concurrent compose windows via ComposeManager.
- **Real-time notifications**: Toast when OCR completes ("OCR abgeschlossen: {filename}") -- auto-dismiss, clickable (navigates to document). Fire globally, not just when viewing the Akte. OCR failure toast ("OCR fehlgeschlagen: {filename}") with retry action button.

### Claude's Discretion
- Toast auto-dismiss timing and animation
- Polling interval (within 10-30s range) for admin dashboard
- FAB positioning offset and responsive behavior
- Exact retry mechanism implementation (API endpoint to call)

### Deferred Ideas (OUT OF SCOPE)
None
</user_constraints>

<phase_requirements>
## Phase Requirements

| ID | Description | Research Support |
|----|-------------|-----------------|
| REQ-DV-004 | Auto-OCR bei PDF-Upload (already implemented in Phase 4) | This phase wires the real-time status updates to the browser via `join:akte` room + `document:ocr-complete` event listener |
| REQ-DV-005 | OCR-Status speichern + anzeigen (already implemented in Phase 4) | This phase adds global toast notifications for OCR complete/failed and ensures upload panel receives events via akte room |
| REQ-EM-006 | Compose-View (already implemented in Phase 3.1) | This phase adds the FAB "Neue E-Mail" button on all email pages that calls `openCompose()` from ComposeManager |
</phase_requirements>

## Standard Stack

### Core (already installed -- no new dependencies)
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| socket.io-client | 4.x | Browser Socket.IO client | Already used via SocketProvider |
| sonner | latest | Toast notifications | Already used globally via `<Toaster>` in root layout |
| lucide-react | latest | Icons (Pen, Edit, RefreshCw) | Already used throughout the app |
| shadcn/ui | latest | UI primitives (Button, Badge, Card) | Already used throughout |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| @/components/socket-provider | n/a | useSocket() hook | For join:akte/leave:akte and OCR event listening |
| @/components/email/compose-manager | n/a | useComposeManager() hook | For openCompose() in FAB |
| @/components/providers/upload-provider | n/a | OCR status tracking | Already listens for document:ocr-complete |

### Alternatives Considered
None -- this is pure wiring of existing code. No decisions to make about libraries.

**Installation:**
```bash
# No installation needed -- all dependencies already present
```

## Architecture Patterns

### Recommended Project Structure
```
src/
├── app/(dashboard)/admin/pipeline/page.tsx   # NEW: Admin pipeline dashboard
├── components/
│   ├── email/
│   │   └── compose-fab.tsx                   # NEW: Floating action button
│   └── akten/
│       └── akte-socket-bridge.tsx            # NEW: join:akte/leave:akte + OCR toast bridge
```

### Pattern 1: Socket.IO Room Join/Leave on Mount/Unmount
**What:** Client component emits `join:akte` on mount and `leave:akte` on cleanup, matching the inbox-layout pattern for `join:mailbox`/`leave:mailbox`.
**When to use:** On every Akte page (detail page, sub-pages)
**Example:**
```typescript
// Proven pattern from src/components/email/inbox-layout.tsx lines 29-38
useEffect(() => {
  if (!socket || !isConnected || !akteId) return;
  socket.emit("join:akte", akteId);
  return () => {
    socket.emit("leave:akte", akteId);
  };
}, [socket, isConnected, akteId]);
```

### Pattern 2: Socket-to-Toast Bridge for Global OCR Notifications
**What:** Listen for `document:ocr-complete` globally (not just in upload panel) and show sonner toasts.
**When to use:** In the Akte socket bridge component or a dedicated listener in the dashboard layout.
**Example:**
```typescript
// Bridge OCR events to global toasts (runs alongside upload-provider listener)
useEffect(() => {
  if (!socket) return;
  const handleOcr = (data: { dokumentId: string; status: string; error?: string }) => {
    if (data.status === "ABGESCHLOSSEN") {
      toast.success(`OCR abgeschlossen: ${data.fileName}`, {
        action: {
          label: "Anzeigen",
          onClick: () => router.push(`/akten/${data.akteId}/dokumente/${data.dokumentId}`),
        },
      });
    } else if (data.status === "FEHLGESCHLAGEN") {
      toast.error(`OCR fehlgeschlagen: ${data.fileName}`, {
        action: {
          label: "Wiederholen",
          onClick: () => fetch(`/api/dokumente/${data.dokumentId}/ocr`, { method: "POST" }),
        },
      });
    }
  };
  socket.on("document:ocr-complete", handleOcr);
  return () => { socket.off("document:ocr-complete", handleOcr); };
}, [socket, router]);
```

### Pattern 3: FAB Component with Context Consumer
**What:** A floating action button placed in the email layout that consumes ComposeManager context.
**When to use:** On all email-related pages.
**Example:**
```typescript
// FAB component using useComposeManager()
const { openCompose } = useComposeManager();
return (
  <button
    onClick={openCompose}
    className="fixed bottom-6 right-6 z-[80] flex items-center gap-2 px-4 py-3
               bg-brand-600 hover:bg-brand-700 text-white rounded-2xl shadow-lg
               hover:shadow-xl transition-all"
  >
    <Pencil className="w-5 h-5" />
    <span className="font-medium">Neue E-Mail</span>
  </button>
);
```

### Pattern 4: Admin Dashboard with Polling
**What:** Client component fetching `/api/admin/pipeline` on interval. Proven pattern from `admin/jobs/page.tsx` and `admin/system/page.tsx`.
**When to use:** For the pipeline dashboard page.
**Example:**
```typescript
// Polling pattern from admin/system/page.tsx lines 154-158
useEffect(() => {
  if (!autoRefresh) return;
  const interval = setInterval(fetchPipelineStats, 15000); // 15s
  return () => clearInterval(interval);
}, [autoRefresh, fetchPipelineStats]);
```

### Anti-Patterns to Avoid
- **Emitting join:akte from server components:** The Akte detail page is a server component. The socket bridge MUST be a client component, either as a child or wrapper.
- **Duplicating OCR event handling:** The upload-provider already handles `document:ocr-complete` for upload panel state. The new global toast listener must coexist, not replace it. Use separate useEffect hooks.
- **Putting the FAB inside inbox-layout:** The FAB needs to be visible on ALL email pages (inbox, detail, compose, tickets, sent, drafts). It belongs in the email layout.tsx, not the inbox-layout component.
- **Creating a new API endpoint for pipeline:** `/api/admin/pipeline` already exists with GET (stats) and POST (retry-all-failed). No new endpoints needed. For per-job retry, `/api/admin/jobs/{queueName}/{jobId}/retry` already exists.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Toast notifications | Custom notification UI | sonner `toast()` / `toast.success()` / `toast.error()` | Already configured in root layout with `<Toaster>` |
| Socket room management | Custom room tracking | Built-in Socket.IO rooms via `join:akte`/`leave:akte` events | Server already handles room lifecycle |
| Queue statistics API | New API endpoint | Existing `/api/admin/pipeline` GET | Returns OCR, embedding, preview queue counts |
| Per-job retry | New retry endpoint | Existing `/api/admin/jobs/{queue}/{jobId}/retry` POST | Already implemented in admin jobs page |
| Document OCR retry | New retry endpoint | Existing `/api/dokumente/{id}/ocr` POST | Resets status and enqueues new job |

**Key insight:** Every backend piece is already built. This phase is 100% client-side wiring. If you find yourself writing a new API route, you are going off-track.

## Common Pitfalls

### Pitfall 1: OCR Events Not Reaching Browser Because Room Is Empty
**What goes wrong:** Worker emits `document:ocr-complete` to `akte:{akteId}` room, but no browser clients have joined that room because the Akte pages never emit `join:akte`.
**Why it happens:** The Akte detail page (`/akten/[id]/page.tsx`) is a server component. Socket.IO events can only be emitted from client components.
**How to avoid:** Create a lightweight client component (AkteSocketBridge) that receives `akteId` as a prop, emits `join:akte` on mount and `leave:akte` on cleanup. Render it from the Akte detail page.
**Warning signs:** Upload panel stays at "OCR wird verarbeitet" forever even after worker completes.

### Pitfall 2: Global OCR Toast Requires Filename/AkteId in Event Payload
**What goes wrong:** The worker emits `{ dokumentId, status }` but the toast needs `fileName` and `akteId` for the toast message and navigation link.
**Why it happens:** The current `document:ocr-complete` event payload only includes `dokumentId` and `status` (and optionally `error`).
**How to avoid:** Extend the worker's event payload to include `fileName` and `akteId` (both already available in `job.data`). This is a one-line change in `worker.ts`.
**Warning signs:** Toast shows "OCR abgeschlossen: undefined".

### Pitfall 3: FAB Z-Index Conflicts with ComposePopup and UploadPanel
**What goes wrong:** The compose popup (z-[90]), minimized tabs (z-[85]), and upload panel (z-50) may overlap with the FAB.
**Why it happens:** Multiple fixed-position elements in bottom-right corner.
**How to avoid:** FAB should use z-[80] (between upload panel z-50 and minimized tabs z-[85]). Hide FAB when compose popup is open or use careful positioning (FAB bottom-6 right-6, upload panel bottom-4 right-4, minimized tabs bottom-0 right-4).
**Warning signs:** FAB is hidden behind compose popup or upload panel.

### Pitfall 4: ComposeManager Context Only Available in Email Layout
**What goes wrong:** FAB tries to call `openCompose()` but gets the default no-op from the context because ComposeManager is only in the email layout.
**Why it happens:** ComposeManager wraps only the email layout children, not the whole dashboard.
**How to avoid:** The FAB is rendered INSIDE the email layout, which is already wrapped by ComposeManager. This is correct -- just ensure the FAB component is placed inside the ComposeManager provider boundary. Since the user wants it on "all email-related pages", the email layout is the right place.
**Warning signs:** Clicking FAB does nothing.

### Pitfall 5: Admin Pipeline Page Not in Admin Layout Navigation
**What goes wrong:** Page exists at `/admin/pipeline` but users can't find it.
**Why it happens:** Admin layout has hardcoded navigation array without "Pipeline" entry.
**How to avoid:** Add `{ name: "Pipeline", href: "/admin/pipeline" }` to the `adminNavigation` array in both `admin/layout.tsx` and the sidebar's `adminNavigation` array.
**Warning signs:** Page works at URL but no nav link.

## Code Examples

### Existing: Worker OCR Event Emission (worker.ts lines 234-237)
```typescript
// Already emits to akte room -- just needs browsers to join
socketEmitter.to(`akte:${job.data.akteId}`).emit("document:ocr-complete", {
  dokumentId: job.data.dokumentId,
  status: "ABGESCHLOSSEN",
});
```

### Existing: Upload Provider OCR Listener (upload-provider.tsx lines 107-127)
```typescript
// Already listens -- will work once browsers join akte room
const handleOcrComplete = (data: { dokumentId: string; status: string }) => {
  setUploads((prev) =>
    prev.map((item) =>
      item.dokumentId === data.dokumentId
        ? { ...item, status: "done" as UploadStatus }
        : item
    )
  );
};
socket.on("document:ocr-complete", handleOcrComplete);
```

### Existing: Mailbox Room Join Pattern (inbox-layout.tsx lines 29-38)
```typescript
// This exact pattern needs to be replicated for akte rooms
useEffect(() => {
  if (!socket || !isConnected || !emailStore.selectedKontoId) return;
  const kontoId = emailStore.selectedKontoId;
  socket.emit("join:mailbox", kontoId);
  return () => {
    socket.emit("leave:mailbox", kontoId);
  };
}, [socket, isConnected, emailStore.selectedKontoId]);
```

### Existing: Admin Pipeline API Response Shape
```typescript
// GET /api/admin/pipeline returns:
{
  queues: {
    ocr: { waiting, active, completed, failed, delayed },
    embedding: { waiting, active, completed, failed, delayed },
    preview: { waiting, active, completed, failed, delayed },
  },
  failedDocuments: [{ id, name, mimeType, ocrFehler, ocrVersuche, akteId, updatedAt, akte }],
  statusDistribution: { AUSSTEHEND: N, ABGESCHLOSSEN: N, FEHLGESCHLAGEN: N, ... }
}

// POST /api/admin/pipeline with { action: "retry-all-failed" }
// Per-job retry: POST /api/admin/jobs/{queueName}/{jobId}/retry
```

### Existing: ComposeManager openCompose (compose-manager.tsx lines 42-53)
```typescript
const openCompose = useCallback(() => {
  setInstances((prev) => {
    if (prev.length >= MAX_COMPOSE_INSTANCES) return prev;
    const newId = `compose-${Date.now()}-${Math.random().toString(36).slice(2)}`;
    return [...prev, { id: newId, minimized: false, betreff: "" }];
  });
}, []);
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| N/A | All patterns already current | Phase 1-4 | No changes needed |

**Deprecated/outdated:** Nothing -- all existing code uses current patterns.

## Open Questions

1. **Worker event payload extension**
   - What we know: Worker currently emits `{ dokumentId, status }` and optionally `{ error }`. For global toasts we need `fileName` and `akteId`.
   - What's unclear: Whether `akteId` is already in the payload (it is -- checking worker.ts line 234 confirms `job.data.akteId` is used for room targeting but not in the event payload).
   - Recommendation: Add `fileName: job.data.fileName` and `akteId: job.data.akteId` to the event payload in worker.ts. This is a safe, backward-compatible extension.

2. **OCR toast scope: global vs akte-room-only**
   - What we know: User decision says "Notifications fire globally across the app, not just when viewing the Akte." But `document:ocr-complete` is emitted to `akte:{akteId}` room, which only has members when someone is viewing that Akte.
   - What's unclear: How to make OCR toasts global if the event is room-scoped.
   - Recommendation: Emit the event to BOTH `akte:{akteId}` (for upload panel) AND `user:{userId}` (for global toast). The worker already knows the userId from the upload context, or can look up the document's createdById. Alternatively, the worker can emit to a separate channel like `notification` which the NotificationProvider already handles globally.

## Sources

### Primary (HIGH confidence)
- Codebase inspection: `src/lib/socket/rooms.ts` -- confirms `join:akte`/`leave:akte` handlers exist
- Codebase inspection: `src/worker.ts` -- confirms `document:ocr-complete` emission to akte room
- Codebase inspection: `src/components/email/compose-manager.tsx` -- confirms `openCompose()` API
- Codebase inspection: `src/app/api/admin/pipeline/route.ts` -- confirms pipeline API exists
- Codebase inspection: `src/components/providers/upload-provider.tsx` -- confirms OCR listener exists
- Codebase inspection: `src/components/email/inbox-layout.tsx` -- confirms mailbox room join pattern

### Secondary (MEDIUM confidence)
- Codebase inspection: `src/app/(dashboard)/email/layout.tsx` -- ComposeManager wraps email children
- Codebase inspection: `src/app/(dashboard)/admin/layout.tsx` -- admin navigation array

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - no new libraries, all existing
- Architecture: HIGH - all patterns already proven in codebase (mailbox rooms, admin pages, FAB)
- Pitfalls: HIGH - identified through direct code inspection of existing implementations

**Research date:** 2026-02-24
**Valid until:** 2026-03-24 (stable -- internal wiring only)
