---
phase: 16-pii-filter
plan: "02"
type: execute
wave: 2
depends_on:
  - "16-01"
files_modified:
  - src/lib/queue/queues.ts
  - src/lib/queue/processors/ner-pii.processor.ts
  - src/worker.ts
autonomous: true
requirements:
  - URTEIL-03
  - ARBW-03

must_haves:
  truths:
    - "nerPiiQueue is exported from queues.ts and listed in ALL_QUEUES for Bull Board discovery"
    - "processNerPiiJob({ musterId }) transitions Muster: PENDING_NER -> NER_RUNNING -> INDEXED | REJECTED_PII_DETECTED"
    - "On any error (including timeout), Muster resets to PENDING_NER before re-throwing — no NER_RUNNING stuck state"
    - "Worker registered in src/worker.ts with concurrency:1 — sequential Ollama to avoid GPU contention"
    - "Startup recovery sweep resets any NER_RUNNING rows to PENDING_NER on worker boot"
  artifacts:
    - path: "src/lib/queue/processors/ner-pii.processor.ts"
      provides: "processNerPiiJob() + NerPiiJobData interface + extractMusterText()"
      exports:
        - processNerPiiJob
        - NerPiiJobData
    - path: "src/lib/queue/queues.ts"
      provides: "nerPiiQueue added to existing queues + ALL_QUEUES"
      exports:
        - nerPiiQueue
    - path: "src/worker.ts"
      provides: "nerPiiWorker registered, started, event handlers attached"
  key_links:
    - from: "src/lib/queue/processors/ner-pii.processor.ts"
      to: "src/lib/pii/ner-filter.ts"
      via: "import { runNerFilter } from '@/lib/pii/ner-filter'"
      pattern: "runNerFilter"
    - from: "src/lib/queue/processors/ner-pii.processor.ts"
      to: "prisma.muster"
      via: "prisma.muster.update() for each state transition"
      pattern: "prisma\\.muster\\.update"
    - from: "src/worker.ts"
      to: "ner-pii queue"
      via: "new Worker('ner-pii', ...)"
      pattern: "new Worker.*ner-pii"
---

<objective>
Wire the NER core module into a BullMQ queue + processor for async Muster NER processing and register the worker in src/worker.ts.

Purpose: ARBW-03 compliance — kanzlei-eigene Muster must go through the full async state machine (PENDING_NER -> NER_RUNNING -> INDEXED | REJECTED_PII_DETECTED) with no bypass path. Phase 18 Admin Upload UI will call nerPiiQueue.add() after upload.
Output: nerPiiQueue, processNerPiiJob, nerPiiWorker — all wired and registered
</objective>

<execution_context>
@/Users/patrickbaumfalk/.claude/get-shit-done/workflows/execute-plan.md
@/Users/patrickbaumfalk/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-pii-filter/16-RESEARCH.md
@.planning/phases/16-pii-filter/16-01-SUMMARY.md

<interfaces>
<!-- Verified from project codebase — executor uses these directly -->

From src/lib/pii/ner-filter.ts (created in Plan 01):
```typescript
export interface NerResult {
  persons: string[];
  hasPii: boolean;
}
export async function runNerFilter(text: string): Promise<NerResult>;
```

From src/lib/queue/queues.ts (existing pattern to follow):
```typescript
// Existing pattern — add nerPiiQueue following same structure
export const gesetzeSyncQueue = new Queue("gesetze-sync", {
  connection: getQueueConnection(),
  defaultJobOptions: {
    attempts: 1,
    backoff: { type: "custom" },
    removeOnComplete: { age: 86_400 },
    removeOnFail: { age: 604_800 },
  },
});
// ALL_QUEUES array exists — add nerPiiQueue to it
```

From src/worker.ts (existing worker registration pattern):
```typescript
// Pattern from gesetze-sync worker (line ~515)
const nerPiiWorker = new Worker<NerPiiJobData>(
  "ner-pii",
  async (job) => processNerPiiJob(job.data),
  {
    connection,
    concurrency: 1,
    settings: {
      backoffStrategy: (attemptsMade: number) => calculateBackoff(attemptsMade),
    },
  }
);
nerPiiWorker.on("completed", (job) => { log.info(...) });
nerPiiWorker.on("failed", (job, err) => { log.error(...) });
workers.push(nerPiiWorker);
```

From src/lib/storage.ts (MinIO client for Muster text extraction):
```typescript
// Use existing MinIO client to stream Muster file content
// Pattern: getObject(bucket, key) returns stream — read to string
```

From prisma/schema.prisma (MusterNerStatus enum):
```typescript
enum MusterNerStatus {
  PENDING_NER
  NER_RUNNING
  INDEXED
  REJECTED_PII_DETECTED
}
// Muster model has: nerStatus MusterNerStatus @default(PENDING_NER)
// Muster model has: minioKey String (path to file in MinIO)
// Muster model has: dateiname String (original filename for text extraction hint)
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add nerPiiQueue to queues.ts</name>
  <files>src/lib/queue/queues.ts</files>
  <action>
Read src/lib/queue/queues.ts in full first to understand the existing pattern (Queue constructor, getQueueConnection(), ALL_QUEUES array).

Add `nerPiiQueue` export following the exact same pattern as existing queues (e.g., gesetzeSyncQueue):

```typescript
export const nerPiiQueue = new Queue("ner-pii", {
  connection: getQueueConnection(),
  defaultJobOptions: {
    attempts: 1,           // NER is non-retryable by design — timeout = permanent fail
    backoff: { type: "custom" },
    removeOnComplete: { age: 86_400 },   // 24h
    removeOnFail: { age: 604_800 },      // 7 days
  },
});
```

Add `nerPiiQueue` to the `ALL_QUEUES` array (or equivalent Bull Board registration mechanism). Check whether the existing file uses `ALL_QUEUES`, `allQueues`, or a different name — match whatever exists.
  </action>
  <verify>`cd /Users/patrickbaumfalk/Projekte/AI-Lawyer && npx tsc --noEmit 2>&1 | grep -E "queue" | head -10`</verify>
  <done>nerPiiQueue exported from queues.ts; added to ALL_QUEUES array; TypeScript compiles clean</done>
</task>

<task type="auto">
  <name>Task 2: Create ner-pii.processor.ts + wire into worker.ts</name>
  <files>
    src/lib/queue/processors/ner-pii.processor.ts
    src/worker.ts
  </files>
  <action>
**Step A — Create src/lib/queue/processors/ner-pii.processor.ts:**

Read an existing processor (e.g., src/lib/queue/processors/gesetze-sync.processor.ts or embedding.processor.ts) to match logger, import, and error-handling conventions exactly.

Export `NerPiiJobData` interface:
```typescript
export interface NerPiiJobData {
  musterId?: string;      // For Muster async NER (ARBW-03)
  urteilText?: string;    // For Urteil inline NER (URTEIL-03) — optional, Phase 17 may use
  urteilId?: string;
}
```

Export `processNerPiiJob(data: NerPiiJobData): Promise<void>`:
- If `data.musterId` is set: call `processMusterNer(data.musterId)`
- If `data.urteilText && data.urteilId` are set: call `processUrteilNer(data.urteilText, data.urteilId)`
- Otherwise: throw `new Error("NerPiiJob: neither musterId nor urteilText provided")`

Implement `processMusterNer(musterId: string): Promise<void>`:
1. `await prisma.muster.update({ where: { id: musterId }, data: { nerStatus: "NER_RUNNING" } })`
2. Wrap the rest in `try { ... } catch (err) { await prisma.muster.update({ where: { id: musterId }, data: { nerStatus: "PENDING_NER" } }); throw err; }` — CRITICAL: reset on ANY error including AbortError/timeout
3. In the try block: fetch Muster from DB to get `minioKey` and `dateiname`
4. Extract text: read from MinIO using `getObject(minioKey)` from src/lib/storage.ts. For NER window: use `text.slice(0, 6000) + "\n...\n" + text.slice(-2000)` to cover both Rubrum and signature block
5. Call `const result = await runNerFilter(nerText)`
6. If `result.hasPii`: update `nerStatus: "REJECTED_PII_DETECTED"`, log `log.warn({ musterId, persons: result.persons }, "Muster rejected: PII detected")`
7. If `!result.hasPii`: update `nerStatus: "INDEXED"`, log `log.info({ musterId }, "Muster NER passed: no PII")`

Implement `processUrteilNer(urteilText: string, urteilId: string): Promise<void>`:
- Call `runNerFilter(urteilText)`
- If `result.hasPii`: log warning, throw Error so Phase 17 caller knows to skip this Urteil
- If `!result.hasPii`: log info — Phase 17 caller handles the DB write with `piiFiltered: true`

**Step B — Add startup recovery sweep** (at the top of the module, called once at worker boot — but it should be called from worker.ts, not auto-run on import):

Export `recoverStuckNerJobs(): Promise<void>`:
```typescript
export async function recoverStuckNerJobs(): Promise<void> {
  const count = await prisma.muster.updateMany({
    where: { nerStatus: "NER_RUNNING" },
    data: { nerStatus: "PENDING_NER" },
  });
  if (count.count > 0) {
    log.warn({ count: count.count }, "Recovered stuck NER_RUNNING Muster rows to PENDING_NER");
  }
}
```

**Step C — Wire into src/worker.ts:**

Read src/worker.ts to find where other workers are registered (look for the gesetzeSyncWorker or embeddingWorker pattern).

1. Import `{ processNerPiiJob, NerPiiJobData, recoverStuckNerJobs }` from `@/lib/queue/processors/ner-pii.processor`
2. After other workers, add:
```typescript
const nerPiiWorker = new Worker<NerPiiJobData>(
  "ner-pii",
  async (job) => processNerPiiJob(job.data),
  {
    connection,
    concurrency: 1,
    settings: {
      backoffStrategy: (attemptsMade: number) => calculateBackoff(attemptsMade),
    },
  }
);
nerPiiWorker.on("completed", (job) => {
  log.info({ jobId: job.id }, "NER PII job completed");
});
nerPiiWorker.on("failed", (job, err) => {
  log.error({ jobId: job?.id, err }, "NER PII job failed");
});
workers.push(nerPiiWorker);
```
3. Call `recoverStuckNerJobs()` during startup (near where other processors do startup checks — check the existing pattern in worker.ts)

Match the exact logging and error-event style already used by adjacent workers.
  </action>
  <verify>`cd /Users/patrickbaumfalk/Projekte/AI-Lawyer && npx tsc --noEmit 2>&1 | grep -E "ner-pii|processor" | head -20`</verify>
  <done>
    - ner-pii.processor.ts exists, exports processNerPiiJob, NerPiiJobData, recoverStuckNerJobs
    - src/worker.ts has nerPiiWorker registered with concurrency:1
    - recoverStuckNerJobs() called at startup
    - TypeScript compiles clean across all three modified files
  </done>
</task>

</tasks>

<verification>
`cd /Users/patrickbaumfalk/Projekte/AI-Lawyer && npx tsc --noEmit 2>&1 | tail -10`

Full TypeScript compile must be clean. Grep confirms: `grep -n "nerPiiQueue" src/lib/queue/queues.ts` and `grep -n "ner-pii" src/worker.ts` both return matches.
</verification>

<success_criteria>
- nerPiiQueue exported and in ALL_QUEUES
- ner-pii.processor.ts: processNerPiiJob handles musterId path with 3-state transitions
- PENDING_NER reset in catch block before re-throw (no NER_RUNNING stuck state)
- recoverStuckNerJobs() clears NER_RUNNING on worker boot
- nerPiiWorker in worker.ts with concurrency:1
- No new npm packages installed
- TypeScript compiles clean
</success_criteria>

<output>
After completion, create `.planning/phases/16-pii-filter/16-02-SUMMARY.md`
</output>
